#+TITLE: Emacs Initialization
#+OPTIONS: toc:2

This is the org-mode version of my Emacs configuration. It is pretty long, but
after having a modular version I've actually found having a hyperlinked output
is super useful. Also, I do like literate programming in general although it's
hard to find a good implementation.

The following function gates logging in the rest of the file. It's first so I
can wrap it around /anything/ in the rest of this file. Note that this depends
on the value of =debug-on-error= but can easily be overridden and set/unset
explicitly.

#+BEGIN_SRC emacs-lisp
(defvar skj/debug-init t;;(and (boundp debug-on-error) debug-on-error)
  "Do I want to debug the init process?")

(defun init-message (message &rest args)
  (when skj/debug-init
    (message (concat "INIT: " message) args)))

(init-message "init file: " user-init-file)
#+END_SRC

#+RESULTS:

Set the garbage collection threshold to a high value during initialization to
speed things along.

#+BEGIN_SRC emacs-lisp
(setq gc-cons-percentage 0.6
      gc-cons-threshold most-positive-fixnum)
#+END_SRC

We'll also set up a hook to see how long startup took, and with the number of
garbage collection cycles. It's not a perfect metric, but good to know if it
changes without corresponding change to this file.

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "Emacs ready in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time
                                             before-init-time)))
                     gcs-done)))
#+END_SRC

If this all goes horribly wrong, the following installs the [[https://github.com/jschaf/esup][Emacs Startup
Profiler]] -- /Benchmark Emacs Startup time without ever leaving your Emacs./

To start Esup, run =M-x esup=, and watch the magic happen. By default, Esup
will profile =user-init-file=. To profile a custom file, call esup with a
prefix argument. That is, =C-u M-x esup=.

#+BEGIN_EXAMPLE emacs-lisp
(use-package esup)
(init-message "Type `M-x esup' to execute the Emacs Startup Profiler")
#+END_EXAMPLE

* Utility Functions

** Feature Management

A simple implementation to turn on/off blocks of initialization below.

#+BEGIN_SRC emacs-lisp :lexical t
(require 'subr-x) ;; builtin convenience functions.

(init-message "processing not-required features")

(defvar skj/feature--not-required
  '("dev/aws"
    "dev/lang/ada"
    "dev/lang/common-lisp"
    "dev/lang/dart"
    "dev/lang/ocaml"
    "dev/lang/rdf"
    "dev/lang/provers"
    "fun"
    "social"
    "writing/rfc"))

(dolist (p (split-string (or (getenv "EMACS_LOCAL_FEATURES_OFF") "") ":"))
  (when (and (stringp p) (> (length p) 0))
    (add-to-list 'skj/feature--not-required p)))

(init-message "not-required = %s" skj/feature--not-required)

(defvar skj/feature--stack '())

(defun init-message (&optional msg &rest args)
  (when skj/debug-init
	(let* ((init-prefix "INIT: ")
	       (feature-prefix (string-join (reverse (mapcar 'cadr skj/feature--stack)) " > "))
	       (has-feature-prefix (> (length feature-prefix) 0))
	       (msg (concat init-prefix
			            feature-prefix
			            (cond
			             ((and has-feature-prefix msg) (concat " :: " msg))
			             ((and (not has-feature-prefix) msg) msg)
			             ((and has-feature-prefix (not msg)) "...")))))
	  (apply 'message msg args))))

(defun skj/feature--required (name)
  (let* ((path-parts (reverse (cons name (mapcar (lambda (elt) (car elt)) skj/feature--stack))))
	     (path (string-join path-parts "/")))
	(not (seq-some (lambda (p) (or (string= path p)
				                   (string-prefix-p (concat p "/") path)))
		           skj/feature--not-required))))

(defun skj/feature-start (name &optional message)
  "Start a new feature named NAME, with the display MESSAGE.
    If MESSAGE is not specified it will be a capitalized form of the NAME."
  (let* ((name (format "%s" name))
	     (message (if message
		              message
	                (capitalize (string-replace "-" " " name))))
	     (required (skj/feature--required name)))
    (setq skj/feature--stack
	      (cons (list name message required) skj/feature--stack))
    (when skj/debug-init
      (if (skj/current-feature-required-p)
          (init-message)
        (init-message "disabled")))
    (skj/current-feature-required-p)))

(defun skj/feature-end (&optional name)
  "End the current feature."
  (when (null skj/feature--stack)
    (error "Cannot end feature %s, stack is empty" name))
  (when (and name (not (string= name (caar skj/feature--stack))))
    (error "Trying to end feature named %s, current is %s"
	       name (car skj/feature--stack)))
  (setq skj/feature--stack (cdr skj/feature--stack)))

(defsubst skj/current-feature-required-p ()
  "Is the current feature required."
  (caddr (car skj/feature--stack)))

(init-message "installed feature stack")
#+END_SRC

** Utilities

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'utilities "Utility Functions")
#+END_SRC

The functions manipulate the path for executable commands outside of
Emacs. They affect both Emacs =exec-path= variable and the =PATH=
environment variable.

#+BEGIN_SRC emacs-lisp
(defun exec-path-prepend (path)
  "Add PATH to the beginning of the current `exec-path` variable,
and the shell's `$PATH` variable."
  (unless (member path exec-path)
    (setq exec-path (cons path exec-path))
    (setenv "PATH" (concat path ":" (getenv "PATH")))))
#+END_SRC

The following is a simple predicate that allows for us to add others
and be more descriptive than dealing with the =system-type= (and other)
variables directly.

#+BEGIN_SRC emacs-lisp
(defun system-mac-p ()
  "Return `t` if this is Darwin, else nil."
  (eq system-type 'darwin))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'utilities)
#+END_SRC


* Initial Customization

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'initial "Initial Customization")
#+END_SRC

** Startup Settings

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'startup "Startup Settings")
#+END_SRC

The following should all be pretty self-explanatory.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (setq warning-suppress-log-types '((package reinitialization)))
  
  (setq echo-keystrokes 0.5
        inhibit-startup-screen t
        inhibit-startup-echo-area-message t
        ring-bell-function 'ignore))
#+END_SRC

The following enable/disable features for graphical clients only.

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p) window-system)
  
  (setq
   ;; Turn off scrollbars, who needs them!
   scroll-bar-mode -1
   
   ;; Restricts how close point can come to the top or bottom of a window, its
   ;; value is a number of screen lines.
   scroll-margin 1
   
   ;; Determines the number of lines by which to automatically scroll, when point
   ;; moves off the screen
   scroll-step 1
   
   ;; They take up space for no good reason.
   tool-bar-mode -1)
  
  (when (>= emacs-major-version 26)
    (pixel-scroll-mode))
  
  (when (>= emacs-major-version 29)
    (setq pixel-scroll-precision-mode 1)))
#+END_SRC

We do the following to suppress warnings from third-party packages during startup. These
are warnings generated when functions are redefined with =defadvice=. Note that
the package =advice= is builtin.

#+BEGIN_SRC emacs-lisp
  (require 'advice) ;; builtin and pre use-package
  (setq ad-redefinition-action 'accept)
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'startup)
#+END_SRC

** Load Path

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'load-path)
#+END_SRC

These paths get added to the module search path, the =lib= directory should be a
symlink to my local Git repository.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (add-to-list 'load-path (concat-path user-emacs-directory "lib"))
  (add-to-list 'load-path (concat-path user-emacs-directory "lib/skj")))
#+END_SRC

This is a directory that contains links to packages outside the standard load path.
For example packages still in development.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  (add-to-list 'load-path (concat-path user-emacs-directory "llib")))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'load-path)
#+END_SRC

** Personal Customization Group

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'group "Personal Customization Group")
#+END_SRC

For those things I want to ensure I can find and tweak at runtime I use the
following customization group. This allows you to /=M-x customize-group=/ and
select =skj=.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (defgroup skj nil
    "Simon's personal environment settings."
    :tag "skj"
    :prefix "skj/"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'group)
#+END_SRC

** Load Customized Values

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'custom "Load Customized Values")
#+END_SRC

It is a good idea to use a separate file for customized settings. Some users
actually create a temporary file so that changes are session-only. However,
I prefer to keep the customization and if they prove useful move them to the
main initialization files.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (setq custom-file (concat-path user-emacs-directory "custom.el")))
#+END_SRC

Assuming that the code in =custom-file= is execute before the code ahead of this
line is not a safe assumption. So load this file proactively.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (load-file custom-file))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'custom)
#+END_SRC

** User Information

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'user-information)
#+END_SRC

Basic identity values, these are my common non-work values.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (defcustom
    skj/default-user-name
    "johnstonskj"
    "A default user name, or user name prefix."
    :tag "Default user name"
    :group 'skj
    :type 'string)
  
  (defcustom
    skj/primary-email
    (concat skj/default-user-name "@gmail.com")
    "Primary, non-work, email address."
    :tag "Primary email address"
    :group 'skj
    :type 'string)

  (defcustom
    skj/full-name
    "Simon Johnston"
    "Name to go with email-address."
    :tag "Primary email name"
    :group 'skj
    :type 'string))
#+END_SRC

The following are used by Emacs.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (setq user-login-name skj/default-user-name
        user-full-name skj/full-name
        user-mail-address skj/primary-email))
#+END_SRC

This is just useful to have, the expanded version ensures that anywhere I use
it I don't have to worry about a function ignoring the tilde.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (defvar user-home-directory (expand-file-name "~")))
#+END_SRC

This sets my most common location, and while mostly used by calendaring and
[[*Org Agenda]], I keep it here. Note the three required packages are all Emacs
builtins.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  ;; All of thee three are builtins
  (use-package calendar :ensure nil :defer nil)
  
  (use-package cal-dst
    :ensure nil
    :defer 2
    :after calendar
    :config
    (setq calendar-time-zone -480
          calendar-standard-time-zone-name "PST"
          calendar-daylight-time-zone-name "PDT"))

  (use-package solar
    :ensure nil
    :defer 2
    :after calendar
    :config
    (setq calendar-latitude 47.6062
          calendar-longitude -122.3321
          calendar-location-name "Seattle, WA")))

#+END_SRC

This isn't absolutely necessary, but keeping a use-case neutral form seems
like a good idea. See also [[*Google Calendar]].

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (defvar calendar-time-zone-name "America/Los_Angeles"
    "The name of the timezone set in `cal-dst'."))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'user-information)
#+END_SRC

** Package Management Setup

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'package-manager "Package Management Setup")
#+END_SRC

This section sets up the package management used in the rest of the file. I
use =use-package= rather than calling =install-package= as it groups a lot of
configuration in a sane and readable manner.

*** Add Package Repositories

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'repositories "Package Repositories")
#+END_SRC

Add the most common package archives and set priorities. Note that this
feature cannot be disabled.

#+BEGIN_SRC emacs-lisp
(require 'package) ;; builtin and pre use-package

(add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/"))
(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
(add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/"))

(setq package-archive-priorities '(("gnu" . 30)
                                   ("melpa-stable" . 20)
                                   ("melpa" . 10)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'repositories)
#+END_SRC

*** Package Manager Configuration

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'config "Package Manager Configuration")
#+END_SRC

Ensure =use-package= is always installed/available first. Note that this
feature cannot be disabled.

#+BEGIN_SRC emacs-lisp
(when (not (package-installed-p 'use-package))

  (package-refresh-contents)
  
  (package-install 'use-package))
#+END_SRC

The use-package-always-ensure variable indicates that use-package should
always try to install missing packages. For some libraries this is not
appropriate, and in those cases you see the :ensure nil declaration as part of
the use-package statement. This applies mainly to libraries which are
installed as part of some other package (happens mostly with some libraries
that come with org-mode).

#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (setq use-package-always-ensure t))
#+END_SRC

The ~use-package-always-defer~ sets =:defer= true as the default for all package
declarations. This makes Emacs startup much faster by preventing packages from
being loaded when Emacs starts, and only doing so when they are needed. Some
packages don’t work well with this, so you’ll see some declarations when I
explicitly set =:defer nil= to force the package to be loaded at startup, or
=:defer n= to load the package, but only =n= seconds after startup.

#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (setq use-package-always-defer t))
#+END_SRC

The use-package-verbose variable enables verbose loading of packages, useful
for debugging. I set/unset this according to need.

#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (setq use-package-verbose nil))
#+END_SRC

The main advantage to the `use-package-expand-minimally' variable is that, if
you know your configuration works, it will make the byte-compiled file as
minimal as possible. It can also help with reading macro-expanded definitions,
to understand the main intent of what’s happening.

#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (setq use-package-expand-minimally nil))
#+END_SRC

Minor modes each put a word on the mode line to signify that they're
active. This can cause other displays, such as % of file that point is
at, to run off the right side of the screen. For some minor modes, such
as mouse-avoidance-mode, the display is a waste of space, since users
typically set the mode in their .emacs & never change it. For other
modes, such as my jiggle-mode, it's a waste because there's already a
visual indication of whether the mode is in effect.

A diminished mode is a minor mode that has had its mode line
display diminished, usually to nothing, although diminishing to a
shorter word or a single letter is also supported. This package
implements diminished modes -- it will be removed in favor of =use-package=.

#+BEGIN_SRC emacs-lisp
(use-package diminish)
#+END_SRC

If we are debugging, let's go ahead and get a =use-package= statistics report at
the end of the startup process.

#+BEGIN_SRC emacs-lisp
(when skj/debug-init
  (eval-and-compile (setq use-package-compute-statistics t))
  (add-hook 'emacs-startup-hook (lambda () (use-package-report))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'config)
#+END_SRC

*** System Package Manager

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'system "System Package Manager")
#+END_SRC

The [[https://gitlab.com/jabranham/system-packages][system-packages]] package is a collection of functions to make handling
installed system packages more convenient through Emacs.

#+BEGIN_SRC emacs-lisp
(use-package system-packages
  :if (skj/current-feature-required-p)
  :config
  (setq system-packages-package-manager 'brew
        system-packages-use-sudo nil))
#+END_SRC

This extension adds a ~:ensure-system-package~ keyword which allows you to
ensure system binaries exist alongside your package declarations.

#+BEGIN_SRC emacs-lisp
(use-package use-package-ensure-system-package
  :ensure t
  :if (skj/current-feature-required-p)
  :after (use-package system-packages))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'system)
#+END_SRC

*** Auto-Compile

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'auto-compile "Auto-Compile Packages")
#+END_SRC

Always compile packages, and use the newest version available.

#+BEGIN_SRC emacs-lisp
(use-package auto-compile
  :if (skj/current-feature-required-p)
  :defer nil
  :init
  (setq load-prefer-newer t)
  :custom
  (auto-compile-display-buffer nil)
  (auto-compile-mode-line-counter t)
  :config
  (auto-compile-on-load-mode))
#+END_SRC
 
#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'auto-compile)
#+END_SRC

*** Auto-Update Packages

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'auto-update "Auto-Update Packages")
#+END_SRC

[[https://github.com/rranelli/auto-package-update.el][This package]] provides functionality for automatically updating your Emacs
packages periodically. It is specially useful for people that work in multiple
machines and tend to forget to manually update packages from time to time.

Configure the update to happen every 7 days, at 3:00am, deleting any
old/obsolete packages after updating.

#+BEGIN_SRC emacs-lisp
(use-package auto-package-update
  :if (skj/current-feature-required-p)
  :defer 1
  :config (setq auto-package-update-interval 7
                auto-package-update-delete-old-versions t
                auto-package-update-hide-results t)
  (auto-package-update-at-time "03:00")
  (auto-package-update-maybe))
#+END_SRC
  
=auto-package-update-maybe= will update your installed packages, if there is an
update pending.

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'auto-update)
(skj/feature-end 'package-manager)
#+END_SRC

** More Paths

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'paths)
#+END_SRC

Additional paths and locations that are really not feature-specific.

*** Command Execution Paths

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'execution "Command Execution Paths")
#+END_SRC

[[https://brew.sh/][Homebrew]] is great, but just in case it isn't on the path, this helps a lot.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (require 'homebrew) ;; local file

  (exec-path-prepend (homebrew-prefix/bin)))
#+END_SRC

#+RESULTS:

This is a weird one, can't remember why ...

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p) (system-mac-p) window-system)
  
  (exec-path-prepend "usr/local/bin"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'execution)
#+END_SRC

*** Common Project Directory

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'projects "Common Project Directory")
#+END_SRC

Set the root for all my projects, home and work.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (defcustom
    skj/project-root-dir
    (expand-file-name "~/Projects")
    "Root directory for development projects."
    :tag "Project root directory"
    :group 'skj
    :type 'directory))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'projects)
(skj/feature-end 'paths)
(skj/feature-end 'initial)
#+END_SRC


* Generic Configuration

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'generic "Generic Configuration")
#+END_SRC

By generic I mean not /specifically/ for the major uses in [[*Org-Mode]],
[[*Other Writing Modes]], or [[*Developer Configuration]]. Some of these are not
necessarily "generic" unless you do all your work on Git for example.

** Authentication/Authorization Stores

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'auth "Authentication/Authorization Stores")
#+END_SRC

Support for the command-line [[https://www.passwordstore.org/][pass]] tool.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package password-store
    :ensure-system-package pass)

  ;; password-store-otp ?

  (use-package pass :after password-store)

  (use-package ivy-pass :after (password-store ivy)))
#+END_SRC

First, load the built-in EasyPG support. By calling (~epa-file-enable~),
Emacs automatically encrypts/decrypts files with a =.gpg= extension. By
default it asks about the key to use, but I configure it to always use
my own GPG key.

#+BEGIN_SRC emacs-lisp
(use-package epa-file
  :if (skj/current-feature-required-p)
  :ensure nil ;; included with Emacs
  :custom
  (epa-file-select-keys 'silent)
  :config
  (setq epa-file-encrypt-to (list skj/primary-email))
  (epa-file-enable))
#+END_SRC
  
And configure this in Emacs as well as using the local password store.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (setq auth-sources
        (list '(password-store)
              (concat-path user-emacs-directory "authinfo.gpg"))))
;; or?
;; (use-package auth-source)
;; (use-package auth-source-pass)
;; (auth-source-pass-enable)
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'auth)
#+END_SRC

** Core UI Settings

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'core-ui "Core UI Settings")
#+END_SRC

These are customizations beyond those needed for startup in [[*Startup Settings]].

*** Input Encoding

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'encoding "Input Encoding")
#+END_SRC

We really like UTF-8; seriously, on a modern system there isn't a good excuse
to not use it for everything.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defvar locale-language "en")
  (defvar locale-country "US")
  (defvar locale-encoding 'utf-8)

  (let ((language-string (concat locale-language "_" locale-country))
        (encoding-string  (upcase (symbol-name locale-encoding))))
    (init-message "Setting locale to %s.%s" language-string encoding-string)
    (set-locale-environment (concat language-string "." encoding-string))
    (set-language-environment encoding-string))
  
  (setq-default buffer-file-coding-system locale-encoding
                coding-system-for-read locale-encoding
                coding-system-for-write locale-encoding
                file-name-coding-system locale-encoding
                keyboard-coding-system locale-encoding
                locale-coding-system locale-encoding
                prefer-coding-system locale-encoding
                terminal-coding-system locale-encoding))
#+END_SRC

Loading this package defines three ways of entering the non-ASCII
printable characters with codes above 127: the prefix C-x 8, or the
Alt key, or a dead accent key.  For example, you can enter uppercase
A-umlaut as `C-x 8 " A' or `Alt-" A' (if you have an Alt key) or
`umlaut A' (if you have an umlaut/diaeresis key).

#+BEGIN_SRC emacs-lisp
(use-package iso-transl
  :if (skj/current-feature-required-p)
  :ensure nil)
#+END_SRC

It is worth mentioning the ~set-input-method~ (=C-x RET=) function that allows for
a number of input methods other than the usual keyboard changes. One useful
tool is to set the input method to =TeX= which allows the use of character
entities to be add by their TeX command names. Also, choose =sgml= for entering
HTML entities. See [[*Org Entities]] later for an alternative tool

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'encoding)
#+END_SRC

*** Basic Editing Customization

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'editing "Basic Editing Customization")
#+END_SRC

Because this *is not* the 1950's!

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package emacs ;; can't access `paragraphs' package directly.
    :ensure nil
    :config (setq sentence-end-double-space nil
                  colon-double-space nil)))
#+END_SRC

=TAB= and =SPC= handling.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (setq require-final-newline t)
  
  (setq-default
   indent-tabs-mode nil
   indicate-empty-lines t
   tab-always-indent 'complete
   tab-width 4))
#+END_SRC

Set the fill column value and turn on visual indicator.

#+BEGIN_SRC emacs-lisp
(use-package display-fill-column-indicator
  :if (skj/current-feature-required-p)
  :defer 1
  :hook ((org-mode prog-mode) . display-fill-column-indicator-mode)
  :init (setq-default fill-column 78))
#+END_SRC

OMG!! Enable the overwriting of selected text when you type... like
every sane editor and O/S!

#+BEGIN_SRC emacs-lisp
(use-package delsel
  :ensure nil
  :defer 1
  :if (skj/current-feature-required-p)
  :config (delete-selection-mode t))
#+END_SRC

Save place in files between sessions.

#+BEGIN_SRC emacs-lisp
(use-package saveplace
  :ensure nil
  :defer 1
  :if (skj/current-feature-required-p)
  :config (save-place-mode 1))
#+END_SRC

How does anyone work without an [[https://gitlab.com/tsc25/undo-tree][Undo Tree]]!

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :if (skj/current-feature-required-p)
  :defer 1
  :diminish undo-tree-mode
  :config
  ;; Enabling timestamps seems to make everything wonky
  ;; (setq undo-tree-visualizer-timestamps nil)
  (setq undo-tree-visualizer-diff nil)
  (global-undo-tree-mode))
#+END_SRC

While changing buffers or workspaces, the first thing you do is look for your
cursor. Unless you know its position, you can not move it efficiently. Every
time you change buffers, the current position of your cursor will be briefly
highlighted now.

#+BEGIN_SRC emacs-lisp
(use-package beacon
  :if (skj/current-feature-required-p)
  :defer 1
  :diminish beacon-mode
  :config (beacon-mode 1))
#+END_SRC

A pretty simple package, takes your cursor and semantically expands the
region, so words, sentences, maybe the contents of some parentheses, it’s
awesome, try it out.

#+BEGIN_SRC emacs-lisp
;; This seems to get in an infinte loop
;; (use-package expand-region
;;   :if (skj/current-feature-required-p)
;;   :bind ("C-=" . er/expand-region))
#+END_SRC
  
#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'editing)
#+END_SRC

*** Default Faces

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'faces "Default Faces")
#+END_SRC

These are useful things to have around.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (defcustom skj/default-font-family "fira code" 
    "Default font family."
    :tag "Default font family"
    :type 'string
    :group 'skj)

  (defcustom skj/default-font-weight 'light
    "Default font weight."
    :type '(choice (const light)
                   (const semi-light)
                   (const normal)
                   (const semi-bold)
                   (const bold))
    :tag "Default font weight"
    :group 'skj)

  (defcustom skj/default-font-size 130
    "Default font size."
    :tag "Default font size"
    :type 'int
    :group 'skj))
#+END_SRC

This isn't so useful on macOS as it doesn't seem to decode weight and width
correctly so I can't use Fira Code Light.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (set-face-attribute
   'default
   nil
   :inherit nil
   :extend nil
   :stipple nil
   :background "#fdf6e3"
   :foreground "#657b83"
   :inverse-video nil
   :box nil
   :strike-through nil
   :overline nil
   :underline nil
   :slant 'normal
   :weight skj/default-font-weight
   :height skj/default-font-size
   :width 'normal
   :foundry "nil"
   :family skj/default-font-family))
#+END_SRC

Make the menu system readable, the default colors after theming are kind of heinous.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (set-face-attribute 'tty-menu-disabled-face nil
                      :background "slategray" :foreground "lightgray")
  (set-face-attribute 'tty-menu-enabled-face nil
                      :background "slategray" :foreground "brightwhite" :weight 'bold)
  (set-face-attribute 'tty-menu-selected-face nil
                      :background "darkslategray"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'faces)
#+END_SRC

*** Theme Support

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'themes "Theme Support")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package color-theme-sanityinc-solarized
  :if (skj/current-feature-required-p)
  :init
  (setq custom-enabled-themes '(sanityinc-solarized-light)
        custom-safe-themes
        '("4cf3221feff536e2b3385209e9b9dc4c2e0818a69a1cdb4b522756bcdf4e00a4" default))
  :config (setq color-theme-is-global t)
  (color-theme-sanityinc-solarized-light))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'themes)
#+END_SRC

*** Icons

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'icons)
#+END_SRC

Good to know...

#+BEGIN_SRC emacs-lisp
(if (image-type-available-p 'imagemagick)
    (message "Emacs has imagemagick support :)")
  (message "Emacs does not have imagemagick support :("))
#+END_SRC

To ensure fonts have been installed on your system, execute:
/=M-x all-the-icons-install-fonts<RET>=/

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p) window-system)
  
  (use-package all-the-icons
    :demand t
    :config (all-the-icons-completion-mode))

  (use-package all-the-icons-completion
    :after all-the-icons))
#+END_SRC

The VSCode common icons.

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p) window-system)
  
  (use-package vscode-icon
    :commands (vscode-icon-for-file)))
#+END_SRC

Now enable modes using the icons above.

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p) window-system)
  
  (use-package mode-icons
    :config (mode-icons-mode))

  (use-package major-mode-icons
    :config (major-mode-icons-mode 1)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'icons)
#+END_SRC

*** Mode Line

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'mode-line)
#+END_SRC

I like to keep this pretty simple, certainly no powerline!. Both of these
packages are builtin.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package time
    :ensure nil
    :defer 1
    :config
    (setq display-time-string-forms
          '((propertize (concat " " 24-hours ":" minutes " "))))
    (display-time-mode t))

  (use-package simple
    :ensure nil
    :defer 1
    :config
    (line-number-mode t)
    (column-number-mode t)))
#+END_SRC

For battery mode, simplify the usual and use icons, it makes it easier to
find.

#+BEGIN_SRC emacs-lisp
(use-package battery
  :ensure nil
  :defer 2
  :if (skj/current-feature-required-p)
  :config
  (when (functionp 'battery-status-function)
    (cond ((string= "AC" (battery-format "%L" (funcall battery-status-function)))
           (setq battery-mode-line-format " "))
          ((string-match-p "N/A" (battery-format "%B" (battery-status-function)))
           (setq battery-mode-line-format " "))
          (t
           (setq battery-mode-line-format ":%p%% "))))
  (display-battery-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'mode-line)
#+END_SRC

*** Hydra

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'hydra)
#+END_SRC

I like to keep this pretty simple, certainly no powerline!. Both of these
packages are builtin.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package hydra
    :defer 3)
  
  ;; https://github.com/jerrypnz/major-mode-hydra.el
  (use-package major-mode-hydra
    :defer 3
    :after hydra
    :bind
    ("M-SPC" . major-mode-hydra))

    (use-package pretty-hydra
    :defer 3
    :after major-mode-hydra))
#+END_SRC


#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'hydra)
#+END_SRC

*** Files and Buffers

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'buffers "Files and Buffers")
#+END_SRC

[[https://github.com/Alexander-Miller/treemacs][Treemacs]] is a file and project explorer similar to NeoTree or vim’s NerdTree,
but largely inspired by the Project Explorer in Eclipse. It shows the file
system outlines of your projects in a simple tree layout allowing quick
navigation and exploration, while also possessing basic file management
utilities.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package treemacs)

  (use-package treemacs-all-the-icons
    :if window-system
    :after treemacs)

  (use-package treemacs-icons-dired
    :if window-system
    :after treemacs)

  (use-package treemacs-magit
    :after (treemacs magit))

  (use-package treemacs-projectile
    :after (treemacs projectile))

  (use-package lsp-treemacs
    :after (treemacs lsp)))
#+END_SRC

[[https://www.emacswiki.org/emacs/RecentFiles][Recentf]] is a minor mode that builds a list of recently opened files. This list
is automatically saved across sessions on exiting Emacs - you can then access
this list through a command or the menu.

#+BEGIN_SRC emacs-lisp
(use-package recentf
  :if (skj/current-feature-required-p)
  :defer 1
  :bind ("C-x C-r" . recentf-open-files)
  :custom
  (recentf-max-menu-items 100)
  (recentf-max-saved-items 100)
  :init
  (recentf-mode))
#+END_SRC

[[https://www.emacswiki.org/emacs/IbufferMode][Ibuffer]] is an advanced replacement for BufferMenu, which lets you operate on
buffers much in the same manner as Dired. The most important Ibuffer features
are highlighting and various alternate layouts. Ibuffer is part of Emacs since
version 22.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package ibuffer)

  (use-package ibuffer-sidebar
    :after ibuffer
    :bind ("C-x C-b" . ibuffer-sidebar-toggle-sidebar))

  (use-package all-the-icons-ibuffer
    :if window-system
    :after ibuffer
    :hook (ibuffer-mode . all-the-icons-ibuffer-mode)))
#+END_SRC

This [[https://github.com/lukhas/buffer-move][package]] is for lazy people wanting to swap buffers without
typing /=C-x b=/ on each window. Wind-move allows for navigating with shift
arrow keys.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package buffer-move)

  (use-package windmove
    :ensure nil
    :defer nil
    :config (windmove-default-keybindings)))
#+END_SRC

This [[https://github.com/beacoder/everlasting-scratch][package]] provides a global minor mode =everlasting-scratch-mode=
that causes the scratch buffer to respawn after it's killed and with
its content restored.

#+BEGIN_SRC emacs-lisp
(use-package everlasting-scratch
  :if (skj/current-feature-required-p)
  :hook (after-init))
#+END_SRC

Finally, set the default buffer mode.

#+BEGIN_SRC emacs-lisp
(use-package text-mode
  :ensure nil
  :if (skj/current-feature-required-p)
  :defer nil
  :after simple
  :hook (text-mode . auto-fill-mode)
  :config
  (setq-default major-mode 'text-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'buffers)
#+END_SRC

*** Multiple Cursors

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'multiple-cursors)
#+END_SRC

[[https://github.com/magnars/multiple-cursors.el][Multiple cursors]] for Emacs.

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors :if (skj/current-feature-required-p))
#+END_SRC

When you have an active region that spans multiple lines, the following will add a cursor to each line:

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines))
#+END_SRC

When you want to add multiple cursors not based on continuous lines, but based on keywords in the buffer, use:

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (global-set-key (kbd "C-c m c") 'mc/edit-lines)
  (global-set-key (kbd "C-c m >") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-c m <") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-c m *") 'mc/mark-more-like-this)
  (global-set-key (kbd "C-c m !") 'mc/mark-all-like-this))
#+END_SRC

This package contains [[https://github.com/knu/mc-extras.el][extra functions]] for multiple-cursors mode.

#+BEGIN_SRC emacs-lisp
(use-package mc-extras
  :if (skj/current-feature-required-p)
  :after multiple-cursors)
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'multiple-cursors)
#+END_SRC
*** Notifications
:PROPERTIES:
:CUSTOM_ID: core-ui-notifications
:END:

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'notifications)
#+END_SRC

[[https://github.com/jwiegley/alert][Alert]] is a Growl-workalike for Emacs which uses a common notification
interface and multiple, selectable "styles", whose use is fully customizable
by the user.

#+BEGIN_SRC emacs-lisp
(use-package alert
  :if (skj/current-feature-required-p)
  :config (setq alert-fade-time 10 ;; seconds
                alert-default-style (if (system-mac-p)
                                        'osx-notifier
                                      'notifications)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'notifications)
#+END_SRC

*** Small Stuff

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'misc)
#+END_SRC

Set fringes to appear only on the left-hand side.

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p) window-system)

  (use-package fringe
    :ensure nil
    :config
    (fringe-mode 'left-only)))
#+END_SRC

Using multiple side-by-side windows is a great way to utilize the
large high-resolution displays that exists today. This [[https://github.com/Lindydancer/multicolumn][package]]
provides the "missing features" of Emacs to create a side-by-side
layout, to navigate efficiently, and to manage the windows.

#+BEGIN_SRC emacs-lisp
(use-package multicolumn
  :if (skj/current-feature-required-p))
#+END_SRC

In OS X 10.9, each monitor is a separate space. If you want to stretch an
Emacs frame across multiple monitors, you can change this in "System
Preferences -> Mission Control -> Displays have separate Spaces".

#+BEGIN_SRC emacs-lisp
(use-package mouse
  :ensure nil
  :if (skj/current-feature-required-p)
  :defer nil
  :config
  (setq
   mouse-wheel-follow-mouse 't
   mouse-wheel-scroll-amount '(1 ((shift) . 1)))

  (xterm-mouse-mode t)
  
  (global-set-key [mouse-4] (lambda ()
                              (interactive)
                              (scroll-down 1)))
  (global-set-key [mouse-5] (lambda ()
                              (interactive)
                              (scroll-up 1))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'misc)
(skj/feature-end 'core-ui)
#+END_SRC

** Completion UI Settings

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'completion "Completion UI Settings")
#+END_SRC

*** Ivy

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'ivy)
#+END_SRC

The guidance is to do all this /before/ installing the [[https://github.com/abo-abo/swiper][ivy]] packages themselves.

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p) window-system)
  
  (use-package all-the-icons-ivy
    :config (all-the-icons-ivy-setup))

  (use-package all-the-icons-ivy-rich
    :init (all-the-icons-ivy-rich-mode 1)))
#+END_SRC

Do these *before* ivy.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package historian)

  (use-package ivy-historian
    :after historian
    :init (historian-mode +1)
    :config (ivy-historian-mode +1)))
#+END_SRC

Ivy-resume (resumes the last Ivy-based completion) and other commands.

#+BEGIN_SRC emacs-lisp
(use-package ivy
  :if (skj/current-feature-required-p)
  :defer 1
  :diminish ivy-mode
  :config
  (setq enable-recursive-minibuffers t
        ivy-count-format "(%d/%d) "
        ivy-use-virtual-buffers t)
  (global-set-key (kbd "C-c v") 'ivy-push-view)
  (global-set-key (kbd "C-c V") 'ivy-pop-view)
  (global-set-key (kbd "C-c C-r") 'ivy-resume)
  (global-set-key (kbd "C-x b") 'ivy-switch-buffer)
  (ivy-mode 1))
#+END_SRC

Swiper is a part of Ivy.

#+BEGIN_SRC emacs-lisp
(use-package swiper
  :ensure nil
  :defer 1
  ;;:if (skj/current-feature-required-p)
  :after ivy
  :config
  (global-set-key (kbd "C-s") 'swiper-isearch))
#+END_SRC

Do these *after* ivy, but right now do not activate them.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package ivy-hydra
    :ensure nil
    :after (ivy hydra))
  
  (use-package ivy-file-preview :after ivy)
  ;;  :config (ivy-file-preview-mode 1))

  (use-package ivy-rich
    :after ivy
    :pin melpa
    :config (ivy-rich-mode 1)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'ivy)
#+END_SRC

*** Counsel

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'counsel)
#+END_SRC

[[https://github.com/abo-abo/swiper][Counsel]] integrations; note that while ~counsel-osx-app~ looks good I didn't use
it.

#+BEGIN_SRC emacs-lisp
(use-package counsel
  :if (skj/current-feature-required-p)
  :defer 1
  :after ivy
  :config
  (setq counsel-find-file-ignore-regexp "\\(?:\\`\\|[/\\]\\)\\(?:[#.]\\)")

  ;; Ivy-based interface to standard commands
  (global-set-key (kbd "M-x") 'counsel-M-x)
  (global-set-key (kbd "C-x C-f") 'counsel-find-file)
  (global-set-key (kbd "M-y") 'counsel-yank-pop)
  (global-set-key (kbd "<f1> f") 'counsel-describe-function)
  (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
  (global-set-key (kbd "<f1> l") 'counsel-find-library)
  (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
  (global-set-key (kbd "<f2> u") 'counsel-unicode-char)
  (global-set-key (kbd "<f2> j") 'counsel-set-variable)

  ;; Ivy-based interface to shell and system tools
  (global-set-key (kbd "C-c c") 'counsel-compile)
  (global-set-key (kbd "C-c g") 'counsel-git)
  (global-set-key (kbd "C-c j") 'counsel-git-grep)
  (global-set-key (kbd "C-c L") 'counsel-git-log)
  (global-set-key (kbd "C-c k") 'counsel-rg)
  (global-set-key (kbd "C-c n") 'counsel-fzf)
  (global-set-key (kbd "C-x l") 'counsel-locate)
  (global-set-key (kbd "C-c J") 'counsel-file-jump)

  (global-set-key (kbd "C-c b") 'counsel-bookmark)
  (global-set-key (kbd "C-c d") 'counsel-descbinds)
  (global-set-key (kbd "C-c o") 'counsel-outline)
  (global-set-key (kbd "C-c F") 'counsel-org-file)

  (counsel-mode 1))
#+END_SRC

Counsel interface for [[https://github.com/sharkdp/fd][fd]]. If you have =fd= installed you can add the following:

- =M-x counsel-fd-dired-jump= to jump to a subdirectory under current
  directory.
- =M-x counsel-fd-file-jump= to jump to a file under current directory.

#+BEGIN_SRC emacs-lisp
(use-package counsel-fd
  :if (skj/current-feature-required-p)
  :ensure-system-package fd
  :after counsel)
#+END_SRC

Search the web with dynamic suggestions and browse the results – all from the
comfort of Emacs and ivy.

1. ~counsel-web-suggest~ prompts for a search string, displays dynamic
   suggestions, and passes the chosen suggestion to:
2. ~counsel-web-search~, which takes a search string and browses a search
   candidate.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package counsel-web
    :after counsel
    :config
    (setq counsel-web-engine 'google
          counsel-web-search-action #'browse-url
          counsel-web-search-alternate-action #'w3m))
  
  ;; Define "C-c w" as a prefix key.
  (defvar counsel-web-map
    (let ((map (make-sparse-keymap "counsel-web")))
      (define-key map (kbd "w") #'counsel-web-suggest)
      (define-key map (kbd "s") #'counsel-web-search)
      (define-key map (kbd ".") #'counsel-web-thing-at-point)
      map))
  
  (global-set-key (kbd "C-c w") counsel-web-map))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'counsel)
#+END_SRC

*** Company

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'company)
#+END_SRC

[[https://company-mode.github.io/][Company]] is a text completion framework for Emacs. The name stands for
"complete anything". It uses pluggable back-ends and front-ends to
retrieve and display completion candidate.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package company
    :defer1
    :hook (after-init . global-company-mode)
    :config
    (setq company-files-exclusions '(".git/" ".DS_Store")
          company-tooltip-align-annotations t
          company-tooltip-annotation-padding 1
          company-tooltip-flip-when-above t
          company-tooltip-margin 2
          company-tooltip-limit 4
          company-format-margin-function #'company-text-icons-margin))

  (use-package company-quickhelp
    :if window-system
    :after company))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'company)
(skj/feature-end 'completion)
#+END_SRC

** O/S Specific UI Settings

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'os-ui "O/S Specific UI Settings")
#+END_SRC

*** macOS Specifics

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'macos "macOS Specifics")
#+END_SRC

- =osx-lib=: An Emacs package with functions and commands for interacting with
  macOS.
- =osx-plist=: This is a simple parser for macOS plist files. The main entry
  points are =osx-plist-parse-file= and =osx-plist-parse-buffer=.
- =osx-trash=: Make =delete-by-moving-to-trash= do what you expect it to do on macOS.
- =reveal-in-osx-finder=: Provides the function =reveal-in-osx-finder= for file
  and dired buffers.

#+BEGIN_SRC emacs-lisp
(when (and (system-mac-p) (skj/current-feature-required-p))
  
  (use-package osx-lib)

  (use-package osx-plist)

  (use-package osx-trash
    :config (osx-trash-setup))

  (use-package reveal-in-osx-finder))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (and (system-mac-p) (skj/current-feature-required-p))
  
  (setq mac-command-modifier 'super
        mac-control-modifier 'control
        mac-option-modifier 'meta))
;; mac-right-command-modifier 'super
;; mac-right-option-modifier 'meta
;; ns-alternate-modifier mac-option-modifier
;; ns-command-modifier mac-command-modifier
;; ns-function-modifier 'hyper
;; ns-right-command-modifier mac-right-command-modifier))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'macos)
(skj/feature-end 'os-ui)
#+END_SRC

** Initial Flycheck Settings

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'flycheck "Initial Flycheck Settings")
#+END_SRC

Install the base [[https://www.flycheck.org/en/latest/][Flycheck]] package, and any generic extensions such as
[[https://github.com/flycheck/flycheck-inline][flycheck-inline]].

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package flycheck
    :hook (after-init . global-flycheck-mode)
    :diminish flycheck-mode)

  (use-package flycheck-inline
    :hook (flycheck-mode . flycheck-inline-mode)
    :diminish flycheck-inline-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'flycheck)
#+END_SRC

** Shell & Terminal Settings

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'shell "Shell & Terminal Settings")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package sh-script
    :ensure nil
    :config
    (add-to-list 'auto-mode-alist '("\\.zsh\\'" . sh-mode))
    (add-hook 'sh-mode-hook
              (lambda ()
                (if (string-match "\\.zsh$" buffer-file-name)
                    (sh-set-shell "zsh")))))

  (use-package term
    :ensure nil
    :config
    (setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *")))
#+END_SRC

Emacs-libvterm, =/vterm/=, is fully-fledged terminal emulator inside GNU Emacs
based on libvterm, a C library. As a result of using compiled code (instead of
elisp), emacs-libvterm is fully capable, fast, and it can seamlessly handle
large outputs.

#+BEGIN_SRC emacs-lisp
(use-package vterm
  :if (skj/current-feature-required-p)
  :custom
  (setq vterm-shell "zsh"
        vterm-max-scrollback 10000))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'shell)
#+END_SRC

** Remote (TRAMP) Editing

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'tramp "Remote (TRAMP) Editing")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package tramp
    :ensure nil
    :defer 2
    :config
    (setq tramp-default-method "ssh"))

  (use-package counsel-tramp
    :after (counsel tramp))

  (use-package docker-tramp
    :after tramp))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'tramp)
#+END_SRC

** Version Control

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'vcs "Version Control")
#+END_SRC

*** Core Git

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'git)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  (use-package mo-git-blame
    :config
    (global-set-key [?\C-c ?g ?c] 'mo-git-blame-current)
    (global-set-key [?\C-c ?g ?f] 'mo-git-blame-file))

  (use-package git-commit-insert-issue
    :hook (git-commit-mode))

  (use-package git-link)

  (use-package git-timemachine
    :config (setq git-timemachine-show-minibuffer-details t))

  (use-package git-modes))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'git)
#+END_SRC
*** Magit

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'magit)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package magit
    :config (setq git-commit-fill-column 72
                  magit-completing-read-function 'ivy-completing-read))

  (use-package magit-lfs :after magit))
#+END_SRC

This package displays keyword entries from source code comments and Org files
in the Magit status buffer.  Activating an item jumps to it in its file.  By
default, it uses keywords from -hl-todo-, minus a few (like "NOTE").

#+BEGIN_SRC emacs-lisp
(use-package magit-todos
  :if (skj/current-feature-required-p)
  :after magit
  :config (magit-todos-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'magit)
#+END_SRC

*** Forge Integration

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'forge "Magit Forge Integration")
#+END_SRC

To start using Forge in a certain repository visit the Magit status buffer for
that repository and type =f n= (=forge-pull=). Alternatively, you can use /=M-x
forge-add-repository=/, which makes it possible to add a forge repository
without pulling all topics and even without having to clone the respective Git
repository.

#+BEGIN_SRC emacs-lisp
(use-package forge
  :if (skj/current-feature-required-p)
  :after magit)
#+END_SRC

Forge uses the Ghub package to access the APIs of supported Git forges. How
this works and how to create and store a token is documented in the magit
[[https://magit.vc/manual/ghub.html#Getting-Started][Getting Started]] section.

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'forge)
#+END_SRC

*** Diff Highlighting

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'diff "Diff Highlighting")
#+END_SRC

`diff-hl-mode' highlights uncommitted changes on the side of the
window (using the /fringe/, by default), allows you to jump between
the hunks and revert them selectively.

#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :if (skj/current-feature-required-p)
  :after magit
  :hook ((magit-pre-refresh . diff-hl-magit-pre-refresh)
         (magit-post-refresh . diff-hl-magit-post-refresh))
  :config (global-diff-hl-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package magit-diff-flycheck
  :if (skj/current-feature-required-p)
  :after (flycheck magit))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'diff)
#+END_SRC

*** iBuffer Integration

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'ibuffer "iBuffer Integration")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package ibuffer-vc
    :after ibuffer
    :config
    (add-hook 'ibuffer-hook
              (lambda ()
                (ibuffer-vc-set-filter-groups-by-vc-root)
                (unless (eq ibuffer-sorting-mode 'alphabetic)
                  (ibuffer-do-sort-by-alphabetic)))))

  (use-package ibuffer-git
    :after ibuffer))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'ibuffer)
#+END_SRC

*** Code Reviews

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'code-review)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package code-review
  :if (skj/current-feature-required-p))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'code-review)
(skj/feature-end 'vcs)
(skj/feature-end 'generic)
#+END_SRC

** Snippet Support

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'snippets "Snippet Support")
#+END_SRC

I *always* setup =abbrev-mode= as it's builtin and this way have a backup if no
full snippet support is enabled.

#+BEGIN_SRC emacs-lisp
(use-package abbrev
  :ensure nil
  :diminish abbrev-mode
  :hook text-mode
  :custom
  ;; tell emacs where to read abbrev definitions from
  (abbrev-file-name  (concat-path user-emacs-directory "abbrev_defs"))

  ;; save abbrevs when files are saved
  (save-abbrevs 'silently)
  :config
  (if (file-exists-p abbrev-file-name)
      (quietly-read-abbrev-file)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (defcustom
    skj/snippet-repo-dir
    (concat-path skj/project-root-dir "emacs-snippets")
    "Snippet repository local path."
    :tag "Snippet repository local path"
    :group 'skj
    :type 'directory))
#+END_SRC

First of all, the primary snippet tool is =yasnippet=.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :if (skj/current-feature-required-p)
  :hook (prog-mode . yas-minor-mode)
  :diminish yas-minor-mode
  :config
  (dolist (path (list
                 (concat-path user-emacs-directory "snippets")
                 skj/snippet-repo-dir))
    (unless (member path yas-snippet-dirs)
      (setq yas-snippet-dirs
            (cons path yas-snippet-dirs))))
  (yas-global-mode 1))
#+END_SRC

Remember to execute /=M-x yas-reload-all<RET>=/ when any snippets change.

Basic snippets, pretty useful.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet-snippets
  :if (skj/current-feature-required-p))
#+END_SRC

These are super useful, create a new =.gitignore= file and type =emacs<RET>=
followed by language such as =rust<RET>= and maybe =macos<RET>= for good measure.

#+BEGIN_SRC emacs-lisp
(use-package gitignore-snippets
  :if (skj/current-feature-required-p)
  :config (gitignore-snippets-init))
#+END_SRC

These are common license files, easy to add to a new project.

#+BEGIN_SRC emacs-lisp
(use-package license-snippets
  :if (skj/current-feature-required-p))
#+END_SRC

=ivy-yasnippet= lets you preview yasnippet snippets with ivy. To use it, call
~ivy-yasnippet~ in =yas-minor-mode=.

#+BEGIN_SRC emacs-lisp
(use-package ivy-yasnippet
  :if (skj/current-feature-required-p))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'snippets)
#+END_SRC


* Org-Mode

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'org "Org-Mode")
#+END_SRC

The almighty [[https://orgmode.org/][Emacs Org Mode]]!

The following are worth reading for more details and future ideas:

- http://doc.norang.ca/org-mode.html
- https://github.com/zzamboni/dot-emacs/blob/master/init.org
- https://orgmode.org/worg/org-tutorials/encrypting-files.html
- https://github.com/daviwil/emacs-from-scratch/blob/master/show-notes/Emacs-06.org
(Agendas and Templates)
- https://orgmode.org/manual/Custom-Agenda-Views.html#Custom-Agenda-Views
- https://www.lucacambiaghi.com/vanilla-emacs/readme.html (6.4. org capture
  templates)
  
Flexible extensions

- =[[https://github.com/gizmomogwai/org-tagged][org-tagged]]=
  
Consider the following for writing extensions:

- =[[https://hg.sr.ht/~zck/org-parser][org-parser]]=
- =[[http://alhassy.com/org-special-block-extras/][org-special-block-extras]]=

** Initial Configuration

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'config "Initial Configuration")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (setq org-directory (concat-path skj/project-root-dir "emacs-org"))

  (defun org-file-name (name &optional subdirectory)
    (concat-path
     (if subdirectory
         (concat-path org-directory (format "%s" subdirectory))
     org-directory)
     (let ((fext (file-name-extension name)))
       (if (or (string= fext "org") (string= fext "gpg"))
           name
         (concat name ".org")))))
  
  (use-package org
    :mode ("\\.org\\'" . org-mode)
    :config
    (setq org-clone-delete-id t
          org-confirm-babel-evaluate nil
          org-cycle-include-plain-lists t
          org-cycle-separator-lines 2
          org-default-notes-file (org-file-name "inbox.org")
          org-edit-src-content-indentation 2
          org-ellipsis " ▾"
          org-enforce-todo-dependencies t
          org-fontify-quote-and-verse-blocks t
          org-hide-emphasis-markers t
          org-image-actual-width '(480)
          org-log-done 'time
          org-log-into-drawer t
          org-log-state-notes-insert-after-drawers nil
          org-pretty-entities t
          org-remove-highlights-with-change t
          org-src-fontify-natively t
          org-src-preserve-indentation t
          org-src-tab-acts-natively t
          org-startup-folded 'content
          org-startup-indented t
          org-startup-with-inline-images t)
    (require 'org-mouse)))
#+END_SRC

By default, org-indent produces an indicator =”Ind”= in the modeline. We use
diminish to hide it. I also like to increase the indentation a bit so that the
levels are more visible.

#+BEGIN_SRC emacs-lisp
(use-package org-indent
  :if (skj/current-feature-required-p)
  :after org
  :ensure nil
  :diminish
  :custom
  (org-indent-indentation-per-level 4))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (defconst skj/org-column-headings
    '((all-tags "%30ALLTAGS(All Tags)")
      (blocked "%1BLOCKED()")
      (category "%10CATEGORY(Category)")
      (clock-sum "%10CLOCKSUM(Actual){:}")
      (clock-sum-today "%10CLOCKSUM_T(Actual Day){:}")
      (closed "%24CLOSED(Closed on)")
      (deadline "%24DEADLINE(Deadline)")
      (effort "%10EFFORT(Effort){:}")
      (file "%15FILE")
      (item "%45ITEM(Task)")
      (name "%45ITEM(Name)")
      (priority "%1PRIORITY(!)")
      (scheduled "%24SCHEDULED(Scheduled to Start)")
      (tags "%20TAGS(Tags)")
      (todo "%10TODO(State)")))

  (defconst skj/org-column-separator " ")

  (defun skj/make-org-column-view (columns &optional column-separator)
    "Construct a column view heading string.

The argument COLUMNS is a list of symbols where each symbol is a key to
the alist in `skj/org-column-headings'. Any column symbol not
found in `skj/org-column-headings' will be discarded and the
resulting list of values combined with the value of COLUMN-SEPARATOR,
or the default value in `skj/org-column-separator'."
    (string-join
     (mapcar
      'car 
      (seq-filter
       (lambda (elt) (not (null elt)))
       (mapcar
        (lambda (column) (alist-get column skj/org-column-headings))
        columns)))
     (or column-separator skj/org-column-separator))))
#+END_SRC

Add the /official/ [[https://orgmode.org/worg/org-contrib/][contributed]] packages for =org-mode=.

#+BEGIN_SRC emacs-lisp
(use-package org-contrib
  :if (skj/current-feature-required-p)
  :after org)
#+END_SRC

The only problem with hiding emphasis markers is that rich text becomes hard
to edit because it is unclear whether your cursor is on the marker or the
first or last character. The =org-appear= package helps by displaying the
markers while the cursor is on a rich text word.

#+BEGIN_SRC emacs-lisp
(use-package org-appear
  :if (skj/current-feature-required-p)
  :after org
  :hook (org-mode . org-appear-mode))
#+END_SRC

Links in =org-mode= by default are displayed as “descriptive” links, meaning
they hide their target URLs (or a destination in general). While this looks
great, it makes it a bit tricky to figure out how you can edit their URL.

Set the default column view for all =org-mode= files.

#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure nil
  :defer 1
  :if (skj/current-feature-required-p)
  :after org
  :config
  (define-key org-mode-map (kbd "C-c h") 'org-toggle-link-display)
  (setq org-columns-default-format
        (skj/make-org-column-view
         '(item category todo priority blocked
                tags-all scheduled deadline effort))))
#+END_SRC

Load =org-crypt= to enable selective encryption/decryption using GPG within
=org-mode=.

#+BEGIN_SRC emacs-lisp
(use-package org-crypt
  :ensure nil
  :after org
  :config
  (org-crypt-use-before-save-magic)
  (setq org-tags-exclude-from-inheritance (quote ("crypt")))
  :custom
  (org-crypt-key skj/primary-email))
#+END_SRC

*** Org Query Language

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'query)
#+END_SRC

A powerful [[https://github.com/alphapapa/org-ql][query language]] for org files.

#+BEGIN_SRC emacs-lisp
(use-package org-ql
  :if (skj/current-feature-required-p)
  :after org)
#+END_SRC

The [[https://github.com/alphapapa/ts.el][ts]] package is a useful tool for a bunch of time related stuff in agenda
and more.

#+BEGIN_SRC emacs-lisp
(use-package ts :if (skj/current-feature-required-p))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'query)
#+END_SRC

*** Priorities

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'priorities)
#+END_SRC

I like using the letters for display, it's a shame that the different Org
interfaces use integers, chars, /and/ strings.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (setq
   org-priority-highest ?A
   org-priority-lowest ?E
   org-priority-default ?C)

  (setq
   org-highest-priority ?A
   org-lowest-priority ?E
   org-default-priority ?C))
#+END_SRC

Use fancy icons for different priority levels, this hooks into org-agenda but
could be used without.

#+BEGIN_SRC emacs-lisp
(use-package org-fancy-priorities
  :if (skj/current-feature-required-p)
  :hook (org-agenda)
  :config
  (setq org-fancy-priorities-list
        '((?A . "⚡") (?B . "⬆") (?C . " ") (?D . "⬇") (?E . "☕"))
        org-priority-faces
        '((?A :foreground "red" :weight bold)
          (?B :foreground "orange" :weight semi-bold)
          (?C :foreground "green" :weight normal)
          (?B :foreground "blue" :weight semi-light)
          (?C :foreground "grey" :weight light))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'priorities)
#+END_SRC

*** Categories

Would be nice to customize `org-agenda-category-icon-alist' but for two
issues:

1. Column views seem to ignore category properties and just use file names.
2. The icon list expects image data, no terminal mode.

*** Tags

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'tags)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (setq org-tag-alist
        '((:startgroup)
          ("idea" . ?i) ("call" . ?c) ("errand" . ?e) ("pay" . ?p) ("remind" . ?r) ("writing" . ?w)
          (:endgroup)
          ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          (:startgrouptag)
          ("home" . ?H)
          (:grouptags)
          ("fix" . ?f) ("clean" . ?l) ("garage" . ?g) ("yard" . ?y) ("family" . ?a) ("friends" . ?r)
          ("finance" . ?$) ("estate" . ?#) ("pets" . ?t)
          (:endgrouptag)
          ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          (:startgrouptag)
          ("activities" . ?A)
          (:grouptags)
          ("diving" . ?v) ("hacking" . ?h) ("music" . ?u) ("synth" . ?s) ("blogging" . ?b)
          (:endgrouptag)
          ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          (:startgrouptag)
          ("travel" . ?T)
          (:grouptags)
          ("flight" . ?F) ("car" . ?C) ("train" . ?R) ("hotel" . ?O) ("event" . ?V)
          (:endgrouptag)
          ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          (:startgrouptag)
          ("work" . ?W)
          (:grouptags)
          ("planning" . ?%) ("design" . ?^) ("coding" . ?!) ("meeting" . ??)
          ("admin" . ?/) ("business" . ?B) ("technical" . ?T) ("hr" . ?H)
          (:endgrouptag))))
#+END_SRC

Currently this fails!

#+BEGIN_SRC emacs-lisp
;; (use-package org-tag-beautify :config (org-tag-beautify-mode 1))
#+END_SRC

It results in the following:

#+BEGIN_EXAMPLE
all-the-icons-fileicon: Unable to find icon with name ‘svelte’ in icon set ‘fileicon’
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'tags)
#+END_SRC

*** Task Types (TODO)

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'tasks "Task Types (Keywords)")
#+END_SRC

Specify (<char>Before/After) where either Before/After may be @ for
record time AND comment, ! for just time

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (setq org-todo-keywords
        '(;; Simple reminders
          (sequence "NUDGE(g)" "|" "DONE(d!)")
          ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          ;; General to-do items
          (sequence "TODO(t)" "NEXT(n!)" "INPROGRESS(p!)"
                    "WAIT(w@/!)"
                    "|" "DONE(d!)" "CANCELED(c@)")
          ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          ;; Work-like task items
          (sequence "BACKLOG(b)" "PLAN(p!)" "READY(r!)"
                    "ACTIVE(a@/!)" "REVIEW(v)" "WAIT(w@/!)"
                    "HOLD(h)"
                    "|" "DONE(d!)" "CANCELED(c@)")
          ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          ;; Appointment and Meeting tracking
          (sequence "MEETING(M)" "RESCHEDULE(E@)"
                    "|" "DONE(c!)" "CANCELED(c@)")))

  (setq-default org-enforce-todo-dependencies t))
#+END_SRC

Edna provides an extensible means of specifying conditions which must be
fulfilled before a task can be completed and actions to take once it is.

Org Edna runs when either the BLOCKER or TRIGGER properties are set on a
heading, and when it is changing from a TODO state to a DONE state.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package org-id
    :ensure nil
    :after org
    :config
    (setq org-id-method 'uuid
          org-id-prefix nil
          org-id-include-domain nil))

  (use-package org-edna
    :after org-id
    :config (org-edna-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'tasks)
#+END_SRC

*** Capture Templates

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'capture-templates)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package org-capture
    :ensure nil
    :after org
    :defer 1)
  
  (let ((deadline "DEADLINE: %^t\n")
        (prop-id ":ID: %(org-id-new)")
        (prop-created ":CREATED: %U")
        (prop-level
         ":LEVEL: %^{Level|Team|VP|SVP|STeam|Flagship}")
        (prop-effort
         ":EFFORT: %^{Effort|1h|0:15|0:30|1h|4h|1d|2d|1w|2w|1m|3m|6m|1y}")
        (props (lambda (ps)
                 (format
                  ":PROPERTIES:\n%s:END:\n"
                  (if (null ps) "" (concat (string-join ps "\n") "\n"))))))
    
    (setq org-capture-templates
          (list
           (list
            "t" "Add a TODO entry"
            'entry
            '(file+headline org-default-notes-file "Task Inbox")
            (concat "** TODO %?\n"
                    (funcall props (list prop-created prop-id prop-effort)))
            :clock-in t
            :clock-resume t
            :empty-lines-after 1)
           ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
           (list
            "n" "Add a task as NEXT"
            'entry
            '(file+headline org-default-notes-file "Task Inbox")
            (concat "** NEXT %?\n"
                    deadline
                    (funcall props (list prop-created prop-id prop-effort)))
            :empty-lines-after 1)
           ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
           (list
            "p" "Add a project"
            'entry
            '(file+headline org-default-notes-file "Task Inbox")
            (concat "** %? [%] :project: \n"
                    deadline
                    (funcall props (list prop-created prop-id)))
            :empty-lines-after 2
            :refile-targets)
           ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
           (list
            "g" "Add a goal"
            'entry
            '(file+headline org-default-notes-file "Task Inbox")
            (concat "** %? :goal: \n"
                    deadline
                    (funcall props (list prop-created prop-id prop-level)))
            :empty-lines-after 1
            :refile-targets)
           ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
           (list
            "a" "Annotate current task"
            'plain
            '(clock)
            "- Note taken on %T \\\n  %?"
            :empty-lines-after 1)
           ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
           (list
            "m" "Add a planned meeting"
            'entry
            '(file+headline org-default-notes-file "Meeting Requests")
            (concat "** MEETING with %? :meeting: \n"
                    deadline
                    (funcall props (list prop-created)))
            :empty-lines-after 1)
           ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
           (list
            "i" "A Random idea"
            'entry
            '(file+headline org-default-notes-file "Thoughts")
            (concat "* %? :idea: \n"
                    (funcall props (list prop-created)))
            :empty-lines-after 1)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'capture-templates)
#+END_SRC

*** Refile and Archive

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'refile "Refile and Archive")
#+END_SRC

To refile tasks in Org you need to tell it where you want to refile things. I
let any file in ~org-agenda-files~ and the current file contribute to the list
of valid refile targets. Also, it's worth saving all Org buffers after
refiling.

#+BEGIN_SRC emacs-lisp
(use-package org-refile
  :ensure nil
  :if (skj/current-feature-required-p)
  :after org
  :custom
  ;; Targets include this file and any file contributing to the agenda
  (org-refile-targets
   (quote ((nil :maxlevel . 9)
           (org-agenda-files :maxlevel . 9))))
  
  ;; Refile in a single go
  (org-outline-path-complete-in-steps nil)
  
  ;; Show full paths for refiling
  (org-refile-use-outline-path t)

  ;; Use full outline paths for refile targets
  (org-refile-use-outline-path t)

  ;; Targets complete directly with IDO
  (org-outline-path-complete-in-steps nil)

  ;; Allow refile to create parent tasks with confirmation
  (org-refile-allow-creating-parent-nodes (quote confirm))

  ;; Use the current window for indirect buffer display
  (org-indirect-buffer-display 'current-window)
  
  :config
  (advice-add 'org-refile :after 'org-save-all-org-buffers))
#+END_SRC

Setup the builtin archiving to use files that use the "_archive" suffix.

#+BEGIN_SRC emacs-lisp
(use-package org-archive
  :ensure nil
  :if (skj/current-feature-required-p)
  :after org
  :custom
  (org-archive-location "%s_archive::"))
#+END_SRC

This gives you a chance to get rid of old entries in your Org files by
expiring them. The package is a part of =org-contrib=.

#+BEGIN_SRC emacs-lisp
(use-package org-expiry
  :ensure nil
  :if (skj/current-feature-required-p)
  :after org-contrib
  :config
  (setq org-expiry-handler-function 'org-expiry-add-keyword))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'refile)
#+END_SRC

*** Faces

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'faces)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (setq org-todo-keyword-faces
        '(("NEXT" . (:foreground "green" :weight bold))
          ("PLAN" . (:foreground "green" :weight bold))
          ("INPROGRESS" . (:foreground "blue" :weight bold))
          ("ACTIVE" . (:foreground "blue" :weight bold))))

  (add-hook 'org-mode-hook #'turn-on-font-lock))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'faces)
#+END_SRC

*** Project File Integration

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'project "Project File Integration")
#+END_SRC

Adds all TODO items from a =todo.org= file in the magit project's root
to the magit status buffer.

#+BEGIN_SRC emacs-lisp
(use-package magit-org-todos
  :if (skj/current-feature-required-p)
  :after (magit org)
  :config
  (magit-org-todos-autoinsert))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'project)
(skj/feature-end 'config)
#+END_SRC

** Core UI Additions

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'ui "Core UI Additions")
#+END_SRC

The Org-Superstar package improves the look of Org mode headings by replacing
the asterisk symbols with nicer looking circles. The package also enhances the
looks of plain lists and todo items.

#+BEGIN_SRC emacs-lisp
(use-package org-superstar
  :if (skj/current-feature-required-p)
  :after org
  :hook (org-mode . org-superstar-mode))
#+END_SRC

The [[https://github.com/minad/org-modern][org-modern]] package implements a “modern” style for your Org buffers using font
locking and text properties. The package styles headlines, keywords, tables
and source blocks.

#+BEGIN_SRC emacs-lisp
(use-package org-modern
  :if (and (skj/current-feature-required-p) window-system)
  :after org)
#+END_SRC

I use the [[https://github.com/sabof/org-bullets][org-bullets]] package to display the titles with nice Unicode bullets
instead of the text ones.

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :if (skj/current-feature-required-p)
  :after org
  :config
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC

The [[https://orgmode.org/worg/org-contrib/org-collector.html][org-collector]] package collects headline properties into tables with
optional pre-processing.

#+BEGIN_SRC emacs-lisp :exports none
(use-package org-collector
  :ensure nil
  :if (skj/current-feature-required-p)
  :after org-contrib)
#+END_SRC

The [[https://github.com/nobiot/org-transclusion][org-transclusion]] package lets you insert a copy of text content via a file
link or ID link within an Org file. It lets you have the same content present
in different buffers at the same time without copy-and-pasting it.

#+BEGIN_SRC emacs-lisp :exports none
(use-package org-transclusion
  :if (skj/current-feature-required-p)
  :after org)
#+END_SRC

The [[https://github.com/eliascotto/accent][accent]] package shows a popup with accented characters based on the current
letter under the cursor. Based on the MacOS features for adding accented
letters with a long keypress.

#+BEGIN_SRC emacs-lisp :exports none
(use-package accent
  :if (skj/current-feature-required-p)
  :config
  (global-set-key (kbd "C-x C-a") 'accent-menu)
  (setq accent-position 'after))
#+END_SRC

The [[https://github.com/spegoraro/org-alert][org-alert]] provides notifications for scheduled or deadlined agenda
entries. This uses the =alert= package configured in [[#core-ui-notifications]]
above.

#+BEGIN_SRC emacs-lisp
(use-package org-alert
  :if (skj/current-feature-required-p)
  :after org
  :config (setq org-alert-interval 300
                org-alert-notify-cutoff 10
                org-alert-notify-after-event-cutoff 10
                org-alert-notification-title "Org Agenda"))
#+END_SRC

The [[https://github.com/emacs-mirror/emacs/blob/master/lisp/org/org-entities.el][org-entities]] package included in Org Mode allows for entering character
entries in TeX-like form, so =\approx= becomes =≈=. You can toggle the display
between the entered form and the display form with
~org-toggle-pretty-entities~ (=C-c C-x \=). Additionally, ~org-entities-help~ will
show a table of supported entities.

*** References

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'references)
#+END_SRC

This adds [[https://github.com/jkitchin/org-ref][org-ref]] for citations and references, along with the nice
[[https://github.com/alezost/org-ref-prettify.el][org-ref-prettify]].

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package org-ref :after org)

  (use-package org-ref-prettify
    :after org-ref
    :hook (org-mode . org-ref-prettify-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'references)
#+END_SRC

*** Completion Integration

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'completion)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  (use-package company-org-block
    :after (company org)
    :config
    ;; style: 'auto, 'prompt, or 'inline
    (setq company-org-block-edit-style 'auto)
    (add-hook 'org-mode-hook
              (lambda ()
                (add-to-list (make-local-variable 'company-backends)
                             'company-org-block))))

  (use-package org-ivy-search
    :after (org ivy)
    :bind ("C-c o" . org-ivy-search-view))

  (use-package ivy-todo
    :after (org ivy)
    :bind ("C-c t" . ivy-todo)
    :commands ivy-todo
    :config (setq ivy-todo-default-tags '("PROJECT"))))
#+END_SRC

The following is installed by =org-ref= we just pull it in here.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  ;; all builtin
  (use-package org-ref
    :ensure nil
    :after org)
  
  (use-package org-ref-ivy
    :ensure nil
    :after (org ivy)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'completion)
(skj/feature-end 'ui)
#+END_SRC

** Agenda

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'agenda)
#+END_SRC

Set basic things for Org Agenda management. Note that we don't append to the list
~org-agenda-files~ as this should be the first usage and so let's make it clean.

#+BEGIN_SRC emacs-lisp
(use-package org-agenda
  :if (skj/current-feature-required-p)
  :ensure nil
  :after org
  :config
  (setq org-agenda-files
        (list (org-file-name "inbox.org")
              (org-file-name "todo.org")
              (org-file-name "gcal.org"))
        org-agenda-hide-tags-regexp "."
        org-agenda-log-mode-items '(closed clock state)))
#+END_SRC

Because opening the agenda has a tendency to "mess up" window layout...

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  (setq org-agenda-window-setup 'current-window
        org-agenda-restore-windows-after-quit t))
#+END_SRC

The [[https://github.com/Malabarba/org-agenda-property][org-agenda-property]] package can be customized with ~org-agenda-property-list~ and
~org-agenda-property-position~.

#+BEGIN_SRC emacs-lisp
(use-package org-agenda-property
  :if (skj/current-feature-required-p))
#+END_SRC

The [[https://github.com/alphapapa/][org-super-agenda]] package lets you /supercharge/ your Org daily/weekly agenda. The idea is
to group items into sections, rather than having them all in one big list.

#+BEGIN_SRC emacs-lisp
(use-package org-super-agenda
  :if (skj/current-feature-required-p)
  :after org
  :defer 1
  :custom
  (org-super-agenda-groups '((:auto-dir-name t)))
  :config
  (org-super-agenda-mode))
#+END_SRC

The [[https://github.com/alphapapa/org-sidebar][org-sidebar]] package presents helpful sidebars for Org buffers. Sidebars
are customizable using [[*Org Query Language][org-ql]] queries and [[https://github.com/alphapapa/org-super-agenda][org-super-agenda]] grouping. The
default sidebar includes a chronological list of scheduled and deadlined items
in the current buffer (similar to the Org agenda, but without all its
features) at the top, and a list of all other non-done to-do items below. If
the buffer is narrowed, the sidebar only shows items in the narrowed portion;
this allows seeing an overview of tasks in a subtree.

- Use ~org-sidebar~ to show the sidebar
- Use ~org-sidebar-tree~ to show the tree sidebar
  - ~org-sidebar-tree-toggle~
- Use =C-c C-s= to use a relative time for schedule

#+BEGIN_SRC emacs-lisp
(use-package org-sidebar
  :if (skj/current-feature-required-p)
  :after org-super-agenda)
#+END_SRC

*** Custom Views

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'views)
#+END_SRC

Set a sensible default column view for all agenda views.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  (setq org-columns-default-format-for-agenda
        (skj/make-org-column-view
         '(item todo priority blocked tags-all
                scheduled deadline effort clock-sum clock-sum-today))))
#+END_SRC

This is useful for filtering by priority, when not using tag queries.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  (defun skj/org-skip-subtree-if-priority (priority)
    "Skip an agenda subtree if it has a priority of PRIORITY.
  
  PRIORITY must be string between =\"A\"= and =\"E\"=."
    (let ((subtree-end (save-excursion (org-end-of-subtree t)))
          (pri-current (org-element-property :priority (org-element-at-point))))
      (if (equal priority pri-current)
          subtree-end
        nil))))
#+END_SRC

Set up some useful Agenda views.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  (setq org-agenda-custom-commands
        '(("p"
           "People"
           tags "CATEGORY=\"People\""
           ((org-agenda-overriding-header "People:")
            (org-agenda-sorting-strategy '(scheduled-up))
            (org-agenda-overriding-columns-format
             (skj/make-org-column-view
              '(name scheduled priority tags)))
            (org-agenda-view-columns-initially t)))
          ("c"
           "TODO closed last week"
           tags "CLOSED>=\"<-1w>\"&+TODO=\"DONE\"|+TODO=\"CANCELED\""
           ((org-agenda-overriding-header "TODO Closed last week:")
            (org-agenda-sorting-strategy '(priority-down effort-down))
            (org-agenda-overriding-columns-format
             (skj/make-org-column-view
              '(item priority scheduled deadline closed tags-all)))
            (org-agenda-view-columns-initially t)))
          ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          ("d"
           "Daily agenda review"
           ((tags "PRIORITY=\"A\"&-TODO=\"DONE\""
                  ((org-agenda-overriding-header "High-priority unfinished tasks:")
                   (org-agenda-sorting-strategy '(todo-state-down effort-up))))
            ;; --=--=--=--=--=--=--=--=--=--=
            (agenda "")
            ;; --=--=--=--=--=--=--=--=--=--=
            (alltodo ""
                     ((org-agenda-skip-function
                       '(or (skj/org-skip-subtree-if-priority ?A)
                            (org-agenda-skip-if nil '(scheduled deadline))))
                      (org-agenda-sorting-strategy
                       '(priority-down todo-state-down effort-up)))))
           nil
           ("~/daily-agenda.html")))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'views)
#+END_SRC

*** Run on Idle

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'run-on-idle)
#+END_SRC

Basically, if you don't touch Emacs =idle-org-agenda= will display your
org-agenda after certain time. That can be useful to remember tasks after come
back to work.

#+BEGIN_SRC emacs-lisp
(use-package idle-org-agenda
  :if (skj/current-feature-required-p)
  :after org
  :config (idle-org-agenda-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'run-on-idle)
#+END_SRC

*** Clock Tracking

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'clock-tracking)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-clock
  :ensure nil
  :if (skj/current-feature-required-p)
  :after org
  :config
  (setq
   ;; Save the running clock and all clock history when exiting Emacs, load it on startup
   org-clock-persist 'history
   
   ;; Show lot of clocking history so it's easy to pick items off the C-F11 list
   org-clock-history-length 23

   ;; Separate drawers for clocking and logs
   org-drawers (quote ("PROPERTIES" "LOGBOOK"))

   ;; Save clock data and state changes and notes in the LOGBOOK drawer
   org-clock-into-drawer t

   ;; Resume clocking task on clock-in if the clock is open
   org-clock-in-resume t
   
   ;; This removes clocked tasks with 0:00 duration
   org-clock-out-remove-zero-time-clocks t

   ;; Clock out when moving task to a done state
   org-clock-out-when-done t
   
   ;; Do not prompt to resume an active clock
   org-clock-persist-query-resume nil
   
   ;; Enable auto clock resolution for finding open clocks
   org-clock-auto-clock-resolution (quote when-no-clock-is-running)
   
   ;; Include current clocking task in clock reports
   org-clock-report-include-clocking-task t

   org-remember-clock-out-on-exit t)
  
  ;; Resume clocking task when emacs is restarted
  (org-clock-persistence-insinuate)

  ;; Agenda clock report parameters
  (setq org-agenda-clockreport-parameter-plist
        (quote (:link t :maxlevel 5 :fileskip0 t :compact t :narrow 80)))

  (pretty-hydra-define hydra-org-clock
    (:color amaranth :quit-key "q" :title " Org Clock")
    ("Clock"
     (("i"   org-clock-in          "Clock In")
      ("c"   org-clock-in-last     "Continue")
      ("o"   org-clock-out         "Clock Out")
      ("q"   org-clock-cancel      "Clock Cancel"))
     "Reporting"
     (("e"   org-clock-modify-effort-estimate "Edit Effort")
      ("g"   org-clock-goto        "Goto Entry")
      ("d"   org-clock-display     "Display Time")
      ("r"   org-clock-report      "Clock Report"))
     "Timer"
     (("n"   org-timer-set-timer   "New")
      ("r"   org-timer-start       "Start")
      ("p"   org-timer-pause-or-continue    "Pause/Continue")
      ("s"   org-timer-stop        "Stop")
      ("m"   org-timer             "Insert Timer")
      ("t"   org-timer-item        "Insert Timer Item"))))

(bind-key "<f9> c" 'hydra-org-clock/body))
#+END_SRC

Active notifications are shown every 3 minute, inactive every 3

#+BEGIN_SRC emacs-lisp
(use-package org-clock-reminder
  :if (skj/current-feature-required-p)
  :after org-clock
  :config (setq org-clock-reminder-interval (cons 3 10))
  (org-clock-reminder-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'clock-tracking)
#+END_SRC

*** Habit Tracking

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'habit-tracking)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package org-habit
    :ensure nil
    :after org)

  (use-package org-habit-stats
    :after org-habit
    :custom
    (org-habit-following-days 7)
    (org-habit-graph-column 60)
    (org-habit-preceding-days 28)
    (org-habit-show-all-today nil)
    (org-habit-show-done-always-green t)
    (org-habit-show-habits-only-for-today t)))
#+END_SRC

This is an analog to ~org-time-stamp-format~ from org-mode which allows for
formatting repeating timestamps. Unlike the original it does not format
inactive time-stamps as these can't be used for repeating tasks. 

#+BEGIN_SRC emacs-lisp
(defun habit-time-stamp-format (interval &optional with-time)
  (if (string-match "[0-9]+[hdwmy]" interval)
      (format "<%s .+%s>"
              (funcall (if with-time #'cdr #'car) org-time-stamp-formats)
              interval)
    (throw :repeat interval)))
#+END_SRC

Checklists are great for repeated tasks with lots of things that need to be
done. For a long time I was manually resetting the check boxes to unchecked
when marking the repeated task =DONE= but no more! There's a contributed
[[https://orgmode.org/worg/org-contrib/org-checklist.html][org-checklist]] that can uncheck the boxes automagically when the task is marked
done (and has the property =RESET__CHECK__BOXES= set).

#+BEGIN_SRC emacs-lisp
(use-package org-checklist
  :ensure nil
  :if (skj/current-feature-required-p)
  :after org-contrib)

#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'habit-tracking)
#+END_SRC

*** Progress Reporting

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'progress "Progress Reporting")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defun skj/org-dashboard-filter (entry)
    (and (> (plist-get entry :progress-percent) 0)
         (< (plist-get entry :progress-percent) 100)
         (not (member "archive" (plist-get entry :tags)))))

  (use-package org-dashboard
    :config (setq org-expiry-add-keyword t
                  org-dashboard-filter 'skj/org-dashboard-filter)))
#+END_SRC

Might also consider:

- =[[https://github.com/gizmomogwai/org-kanban][org-kanban]]=
- =[[https://github.com/ianxm/emacs-scrum][org-scrum]]=
- =[[orgtbl-ascii-plot]]= -- support for histograms within tables.
- =[[https://github.com/tbanel/orgaggregate/blob/master/README.org][orgtbl-aggregate]]=
  -- aggregating a table is creating a new table by computing sums, averages,
  and so on, out of material from the first table.

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'progress)
#+END_SRC

*** Standard Calendars

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'calendars)
#+END_SRC

Remove the Bahá'í holidays, really not sure they add anything for
me. But, Mexican holidays  are rather good to know!

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package holidays
    :ensure nil
    :defer 3
    :config
    (setq holiday-bahai-holidays nil
          holiday-hebrew-holidays nil
          holiday-islamic-holidays nil))

  (use-package mexican-holidays
    :after holidays
    :config
    (add-to-list 'calendar-holidays holiday-mexican-holidays)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'calendars)
#+END_SRC

*** Google Calendar

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'google-calendar)
#+END_SRC

Emacs own /EasyPG/ picks up the wrong key if I use the primary email address, it
seems to ignore the fact that it has been revoked. Using the alternate email
for this key, should work?

#+BEGIN_SRC emacs-lisp
(use-package plstore
  :ensure nil
  :if (skj/current-feature-required-p)
  :custom
  (setq plstore-encrypt-to "simonkjohnston@mac.com"))
#+END_SRC

Use my secrets store to load the Google Calendar credentials.

#+BEGIN_SRC emacs-lisp
(use-package skj-secrets
  :if (skj/current-feature-required-p)
  :ensure nil ;; locally stored
  :custom
  (setq org-gcal-client-id (skj/secrets-value 'gcal-id)
        org-gcal-client-secret (skj/secrets-value 'gcal-secret)))
#+END_SRC

Store synced calendar entries in the following file.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (defcustom skj/org-gcal-file
    (org-file-name "gcal.org")
    "Location of `org-mode' file to sync with Google Calendar."
    :tag "Org Agenda file for Google Calendar"
    :group 'skj
    :type 'file))
#+END_SRC

Now setup the client.

#+BEGIN_SRC emacs-lisp
(use-package org-gcal
  :if (skj/current-feature-required-p)
  :after org
  :custom
  (setq org-gcal-fetch-file-alist (list (cons skj/primary-email
                                              skj/org-gcal-file))
        org-gcal-local-timezone calendar-time-zone-name))
#+END_SRC

Execute /=M-x org-gcal-fetch<RET>=/ to fetch new calendar updates. Or, execute
/=M-x org-gcal-post-at-point<RET>=/ to turn a =TODO= into a calendar entry.

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'google-calendar)
#+END_SRC

*** Appointment Integration

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'appt "Appointment Integration")
#+END_SRC

Configure the base =appt= package.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package calendar
    :ensure nil
    :config
    (setq diary-file (concat-path user-emacs-directory "diary")))
  
  (use-package appt
    :ensure nil
    :config
    (setq appt-audible t
          appt-display-duration 30
          appt-display-format 'window
          appt-display-mode-line t)
    (appt-activate t)))
#+END_SRC

Rebuild the reminders every time we display the  agenda.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (defun skj/org-agenda-to-appt ()
    "Erase all reminders and rebuilt reminders for today from the agenda."
    (interactive)
    (setq appt-time-msg-list nil)
    (org-agenda-to-appt))

  ;; Add hook to do this when we finalize an agenda view
  (add-hook 'org-agenda-finalize-hook 'skj/org-agenda-to-appt 'append)

  ;; If we leave Emacs running overnight - reset the appointments one
  ;; minute after midnight
  (run-at-time "24:01" nil 'skj/org-agenda-to-appt)
  
  ;; Finally, run during startup so that appointments are rebuilt.
  (skj/org-agenda-to-appt))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'appt)
(skj/feature-end 'agenda)
#+END_SRC

** Babel

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'babel)
#+END_SRC

This function is useful as we want to always add to the list of babel
languages, but also it's nice to be able to pass a single value rather
than a list in all cases.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (defun skj/org-babel-load-languages (languages)
    "Add language to babel and load.

Add LANGUAGES to `'org-babel-load-languages' where LANGUAGES may
be one of the following:

1. a single symbol,
1. a pair with a symbol and a value to denote the enable
   state of the language,
1. or a list where each element is one of the two above.

Finally, the `org-babel-do-load-languages' is called with the
normalized values of LANGUAGES."
    (if (symbolp languages)
        (add-to-list 'org-babel-load-languages (cons languages t))
      (dolist (lang-pair languages)
        (let ((language (cond
                         ((symbolp lang-pair)
                          (cons lang-pair t))
                         ((and (consp lang-pair) (symbolp (car lang-pair)) (booleanp (cdr lang-pair)))
                          lang-pair)
                         (t (error "Invalid value for language: %s" lang-pair)))))
          (add-to-list 'org-babel-load-languages language))))
    (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages)))
#+END_SRC

Load some common builtin languages, these do not have their own
sections as they do not have any specific configuration.

- [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-elisp.html][Emacs Lisp]] ...
- [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-sqlite.html][sqlite]] is a software library that implements a self-contained, serverless,
  zero-configuration, transactional SQL database engine.
- Org Babel works with several text based [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-shell.html][shells]].

Also, always redisplay images after =C-c C-c.=

#+BEGIN_SRC emacs-lisp
(use-package ob
  :ensure nil
  :if (skj/current-feature-required-p)
  :after org
  :config
  (skj/org-babel-load-languages '(emacs-lisp sqlite shell))
  (add-hook 'org-babel-after-execute-hook
            'org-display-inline-images
            'append))
#+END_SRC

*** JavaScript

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'js "JavaScript")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ob-js
  :ensure nil
  :if (skj/current-feature-required-p)
  :after ob
  :config
  (skj/org-babel-load-languages 'js)
  (add-to-list 'org-babel-tangle-lang-exts '("js" . "js")))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'js)
#+END_SRC

*** ditaa

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'ditaa)
#+END_SRC

DIagrams Through Ascii Art ([[https://ditaa.sourceforge.net/][ditaa]], [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-ditaa.html][ob-ditaa]]) is a command-line utility that converts
diagrams drawn using ASCII art into bitmap graphics.

#+BEGIN_SRC emacs-lisp
(use-package ob-ditaa
  :ensure nil
  :if (skj/current-feature-required-p)
  :ensure-system-package ditaa
  :config
  (skj/org-babel-load-languages 'ditaa))

;; The following should be unnecessary:
;; (setq org-ditaa-jar-path
;;       "/opt/homebrew/opt/ditaa/libexec/ditaa-0.11.0-standalone.jar")
#+END_SRC

Use =artist-mode= when drawing diagrams in ditaa.

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'ditaa)
#+END_SRC

*** GNUPlot

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'gnuplot "GNUPlot")
#+END_SRC

Enable the builtin [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-gnuplot.html][gnuplot babel]] support after adding the editing mode.

#+BEGIN_SRC emacs-lisp
(use-package gnuplot
  :if (skj/current-feature-required-p)
  :ensure-system-package gnuplot
  :mode ("\\.gp$" . gnuplot-mode)
  :config
  (skj/org-babel-load-languages 'gnuplot))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'gnuplot)
#+END_SRC
*** GraphViz

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'dot "GraphViz")
#+END_SRC

Enable the builtin [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-dot.html][dot babel]] support after adding the editing mode.

#+BEGIN_SRC emacs-lisp
(use-package graphviz-dot-mode
  :if (skj/current-feature-required-p)
  :ensure-system-package graphviz
  :config
  (unless (version<= emacs-version "26")
    (setq graphviz-dot-indent-width tab-width))
  (skj/org-babel-load-languages 'dot))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'dot)
#+END_SRC

*** PlantUML

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'puml "PlantUML")
#+END_SRC

Enable the builtin [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-plantuml.html][PlantUML babel]] support after adding the editing mode.
Configuring this to use the =plantuml= executable.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package plantuml-mode
    :ensure-system-package plantuml
    :config
    (setq plantuml-default-exec-mode 'executable)
    (skj/org-babel-load-languages 'plantuml))

  (use-package flycheck-plantuml
    :after plantuml-mode
    :config (flycheck-plantuml-setup)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'puml)
(skj/feature-end 'babel)
#+END_SRC

** Export

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'export)
#+END_SRC

Load the underlying org-export package.

#+BEGIN_SRC emacs-lisp
(use-package ox
  :if (skj/current-feature-required-p)
  :ensure nil
  :after org)
#+END_SRC

The package [[https://github.com/emacsorphanage/ox-pandoc][ox-pandoc]] is an exporter for Org mode which converts Org-mode files to a wide
variety of other formats using the [[https://pandoc.org/][pandoc]] tool. Pandoc can produce PDFs, HTML,
presentations, markdown files, office documents and e-pub publications as well
as a number of other more specialised formats.

#+BEGIN_SRC emacs-lisp
(use-package ox-pandoc
  :if (skj/current-feature-required-p)
  :ensure-system-package pandoc
  :defer 5
  :after ox)
#+END_SRC

Add Org exporter backends for Markdown and [[https://github.com/larstvei/ox-gfm][Github-Flavored Markdown]].

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

 (use-package ox-md
   :ensure nil
   :defer 3
   :after ox)

  (use-package ox-gfm
    :after ox-md
    :commands (org-gfm-export-as-markdown
               org-gfm-export-to-markdown)))
#+END_SRC

The best way to produce a PDF from an org file is to export it to a
=.texi= file, and then use =texi2pdf= to produce the PDF.

#+BEGIN_SRC emacs-lisp
(use-package ox-texinfo
  :ensure nil
  :if (skj/current-feature-required-p)
  :ensure-system-package texinfo
  :defer 3
  :after ox)
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'export)
#+END_SRC
q
** Key Bindings

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'key-bindings)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (global-set-key (kbd "C-c l") #'org-store-link)
  (global-set-key (kbd "C-c a") #'org-agenda)
  (global-set-key (kbd "C-c c") #'org-capture)

  (global-set-key (kbd "<f5>") 'org-agenda)
  (global-set-key (kbd "C-<f5>") 'org-store-agenda-views)

  (global-set-key (kbd "<f6> i") 'org-clock-in)
  (global-set-key (kbd "<f6> o") 'org-clock-out)
  (global-set-key (kbd "<f6> g") 'org-clock-goto)
  (global-set-key (kbd "<f6> <f6>") 'org-clock-menu))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'key-bindings)
(skj/feature-end 'org)
#+END_SRC


* Other Writing Modes

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'writing "Other Writing Modes")
#+END_SRC

For distraction-free editing, use the command /=M-x focus-mode=/ which will dim
all but the block of text/code you are currently within.

#+BEGIN_SRC emacs-lisp
(use-package focus
  :if (skj/current-feature-required-p)
  :custom-face
  (focus-unfocused ((t (:inherit font-lock-comment-face :foreground "white")))))
#+END_SRC

Add lorem ipsum filler text inro an Emacs buffer.

#+BEGIN_SRC emacs-lisp
(use-package lorem-ipsum
  :if (skj/current-feature-required-p)
  :config (lorem-ipsum-use-default-bindings))
#+END_SRC

This will setup the following keybindings:

| Key Binding | Function                        |
|-------------+---------------------------------|
| =C-c l p=     | `lorem-ipsum-insert-paragraphs' |
| =C-c l s=     | `lorem-ipsum-insert-sentences'  |
| =C-c l l=     | `lorem-ipsum-insert-list'       |

** Emoji Support

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'emoji)
#+END_SRC

Emacs has to be able to properly render emojis as characters, so a suitable font is
required. Noto Color Emoji is recomended for optimal results.

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p) window-system)
  (set-fontset-font t 'symbol (font-spec :family "Noto Color Emoji") nil 'prepend))
#+END_SRC

[[https://github.com/iqbalansari/emacs-emojify][Emojify]] is an Emacs extension to display emojis. It can display github style
emojis like =:smile:= or plain ascii ones like =:)=. It tries to be as efficient
as possible, while also providing a lot of [[https://github.com/iqbalansari/emacs-emojify#customizations][flexibility]]

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p) window-system)
  (use-package emojify))
#+END_SRC

=emojify-mode= can be enabled/disabled separately for a buffer by using the
command =emojify-mode=, to enable/disable it globally use the command
=global-emojify-mode=.

#+BEGIN_SRC emacs-lisp
(use-package company-emoji
  :if (skj/current-feature-required-p)
  :after (company)
  :if window-system
  :config
  (add-to-list 'company-backends 'company-emoji)
  
  (defun --set-emoji-font (frame)
    "Adjust the font settings of FRAME so Emacs can display emoji properly."
    (if (system-mac-p)
        ;; For NS/Cocoa
        (set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji") frame 'prepend)
      ;; For Linux
      (set-fontset-font t 'symbol (font-spec :family "Symbola") frame 'prepend)))
  
  ;; For when Emacs is started in GUI mode:
  (--set-emoji-font nil)
  ;; Hook for when a frame is created with emacsclient
  ;; see https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Frames.html
  (add-hook 'after-make-frame-functions '--set-emoji-font))
#+END_SRC

Setup ivy emoji support to use the same list as company, for consistency.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package ivy-emoji
    :after (ivy company-emoji)
    :if window-system
    ;; mnemonics i e = insert emoji
    :bind ("C-c i e" . ivy-emoji))

  (use-package company-emoji-list
    :ensure nil
    :after ivy-emoji
    :config  
    (setq ivy-emoji-list
          (mapcar #'(lambda (emoji)
                      (concat
                       (get-text-property 0 :unicode emoji) " "
                       (substring-no-properties emoji)))
                  (company-emoji-list-create)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'emoji)
#+END_SRC

** Markdown and Polymode

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'markdown)
#+END_SRC

The [[https://jblevins.org/projects/markdown-mode/][markdown-mode]] package is a major mode for editing Markdown-formatted text.
Note that this package provides major modes for generic markdown and
GitHub-flavored markdown.

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :if (skj/current-feature-required-p)
  :mode (("\\.markdown\\'" . markdown-mode)
         ("\\.md\\'" . markdown-mode)
         ("README\\.md\\'" . gfm-mode)))
#+END_SRC

Polymode is a framework for multiple major modes (MMM) inside a single Emacs
buffer. It is fast and has a simple but flexible object oriented design.
Creating new polymodes normally takes a few lines of code.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package polymode)

  (use-package poly-markdown
    :after (polymode markdown-mode)
    :mode ("\\.md" . poly-markdown-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'markdown)
#+END_SRC

** Blogging

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'blogging)
#+END_SRC

Editing jekyll files, using =polymode= for the mix of YAML and Markdown.

#+BEGIN_SRC emacs-lisp
(use-package jekyll-modes
  :if (skj/current-feature-required-p)
  :after (poly-markdown))
;;  :mode ("\\.md$" . jekyll-markdown-mode)
#+END_SRC

Emacs major mode for managing [[https://jekyllrb.com/][jekyll]] blogs ([[https://github.com/masasam/emacs-easy-jekyll][repo]]).

#+BEGIN_SRC emacs-lisp
(use-package easy-jekyll
  :if (skj/current-feature-required-p))
#+END_SRC

Thanks to https://cute-jumper.github.io/emacs/2013/10/06/orgmode-to-github-pages-with-jekyll
  
#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (defun org-jekyll-post-link-follow (path)
    (org-open-file-with-emacs path))

  (defun org-jekyll-post-link-export (path desc format)
    (cond
     ((eq format 'html)
      (format "<a href=\"{%% post_url %s %%}\">%s</a>" (file-name-sans-extension path) desc))))

  (org-add-link-type "jekyll-post" 'org-jekyll-post-link-follow 'org-jekyll-post-link-export))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'blogging)
#+END_SRC

** Wiki Stuff

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'wikis)
#+END_SRC

This allows direct access to edit files on the Wiki, and an Org mode exporter
via /=M-x org-mw-export-as-mediawiki<RET>=/.

#+BEGIN_SRC emacs-lisp
;; (use-package mediawiki)

(use-package ox-mediawiki
  :if (skj/current-feature-required-p)
  :after (ox mediawiki))
#+END_SRC

XWiki mode is an offline editing mode only.

#+BEGIN_SRC emacs-lisp
(use-package xwiki-mode
  :if (skj/current-feature-required-p))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'wikis)
#+END_SRC

** LaTeX

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'latex "LaTeX")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (defcustom
    skj/latex-shared-paths
    (list (expand-file-name "~/Projects/latex/texmf"))
    "A list of directories holding shared files for LaTeX writing."
    :tag "Shared LaTeX directories"
    :group 'skj
    :type '(repeat directory))

  (defcustom
    skj/bibtex-files
    (list (expand-file-name "~/Projects/latex/personal.bib"))
    "A list of BibTeX files."
    :tag "Shared BibTeX files"
    :group 'skj
    :type '(repeat file)))
#+END_SRC

*** AUCTeX

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'auctex "AUCTeX")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  (use-package tex
    :ensure auctex)

  (setq latex-run-command "xelatex"
        TeX-auto-save t
        TeX-parse-self t)

  (use-package auctex-latexmk
    :after auctex)

  (use-package latex-pretty-symbols)

  (use-package latex-extra
    :after auctex
    :hook (LaTeX-mode . latex-extra-mode)))
#+END_SRC

This is a group of backends for =company-mode= providing auto-completion for
AUCTeX.

#+BEGIN_SRC emacs-lisp
(use-package company-auctex
  :if (skj/current-feature-required-p)
  :config (company-auctex-init))
#+END_SRC

This add-on defines three =company-mode= backends.

#+BEGIN_SRC emacs-lisp
(use-package company-math
  :if (skj/current-feature-required-p)
  :config
  (setq company-tooltip-align-annotations t)
  ;; global activation of the unicode symbol completion
  (add-to-list 'company-backends 'company-math-symbols-unicode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'auctex)
#+END_SRC

*** Bibliographies

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'bibliographies)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package biblio)

  (use-package bibtex-utils))
#+END_SRC

Completion, using [[https://github.com/gbgar/company-bibtex][company-bibtex]] and [[https://github.com/tmalsburg/helm-bibtex/blob/master/README.org][ivy-bibtex]] packages.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package company-bibtex
    :config (setq company-bibtex-bibliography skj/bibtex-files)
    (add-to-list 'company-backends 'company-bibtex))

  (use-package ivy-bibtex
    :config (setq bibtex-completion-bibliography skj/bibtex-files)))
#+END_SRC

Tools to retrieve content.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package bibretrieve)

  (use-package gscholar-bibtex))
#+END_SRC

The [[https://github.com/emacs-citar/citar][ccitar]] package provides a completing-read front-end to browse and act on BibTeX,
BibLaTeX, and CSL JSON bibliographic data, and LaTeX, markdown, and org-cite
editing support. See [[https://kristofferbalintona.me/posts/202206141852/#citar][this page]] for some configuration ideas.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package citar
    :config (setq citar-bibliography skj/bibtex-files)))

;;(use-package citar-org
;;  :after oc
;;  :config (setq org-cite-insert-processor 'citar
;;                org-cite-follow-processor 'citar
;;                org-cite-activate-processor 'citar))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'bibliographies)
#+END_SRC

*** Preview

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'preview)
#+END_SRC

Use /=M-x latex-math-preview-expression=/

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p) window-system)
  
  (use-package latex-math-preview)

  (use-package latex-preview-pane
    :config (latex-preview-pane-enable)))
#+END_SRC

Automatically toggle Org mode LaTeX fragment previews as the cursor enters and exits them

#+BEGIN_SRC emacs-lisp
(use-package org-fragtog
  :if (and (skj/current-feature-required-p) window-system)
  :hook (org-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'preview)
(skj/feature-end 'latex)
#+END_SRC

** RFC Reader

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'rfc "RFC Editing")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package rfc-mode
  :if (skj/current-feature-required-p)
  :commands (rfc-mode-browse rfc-mode-read)
  :config
  (setq rfc-mode-directory (expand-file-name "~/Documents/rfc/")))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'rfc)
#+END_SRC


** Spell and Style Checking

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'spelling "Spell and Style Checking")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (let* ((env-language (getenv "LANG"))
	     (dictionary (first (split-string env-language "\\."))))
    (setq ispell-extra-args (list (concat "--lang=" dictionary))))
  
  (use-package flyspell
    :if (skj/current-feature-required-p)
    :defer 1
    :diminish
    :hook ((text-mode . flyspell-mode)
           (prog-mode . flyspell-prog-mode))
    :config (setq flyspell-issue-message-flag nil
                  ispell-program-name "aspell"))

  (use-package auto-dictionary
    :if (skj/current-feature-required-p)
    :config
    (add-hook 'flyspell-mode-hook (lambda () (auto-dictionary-mode 1))))

  (use-package flyspell-correct-ivy
    :init
    (setq flyspell-correct-interface #'flyspell-correct-ivy)))
#+END_SRC

[[https://github.com/bnbeckwith/writegood-mode][Writegood mode]] is a minor mode to aid in finding common writing problems. Matt
Might’s [[http://matt.might.net/articles/shell-scripts-for-passive-voice-weasel-words-duplicates/][weaselwords]] scripts inspired this mode. As well as the additional
weasel words it is possible to add to the irregular passive voice verbs in
=writegood-passive-voice-irregulars=.

#+BEGIN_SRC emacs-lisp
(use-package writegood-mode
  :if (skj/current-feature-required-p)
  :bind (("\C-c g" . writegood-mode)
         ("\C-c \C-g g" . writegood-grade-level)
         ("\C-c \C-g e" . writegood-reading-ease))
  :hook ((markdown-mode . writegood-mode)
         (gfm-mode . writegood-mode)
         (LaTeX-mode . writegood-mode)
         (org-mode . writegood-mode)
         (text-mode . writegood-mode))
  :config (setq writegood-weasel-words
                (append '("least" "most" "occasionally") writegood-weasel-words)))
#+END_SRC

This is more a batch checker, you run the external tool =style= on a buffer or
region. To check writing style, execute: /=M-x smog-check-buffer<RET>=/.

#+BEGIN_SRC emacs-lisp
(use-package smog
  :if (skj/current-feature-required-p)
  :ensure-system-package style
  :config
  (setq smog-command "style -L en"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'spelling)
(skj/feature-end 'writing)
#+END_SRC


* Developer Configuration

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'dev "Development Configuration")
#+END_SRC

** UI Settings

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'ui "UI Settings")
#+END_SRC

*** Prettify Things

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'pretty "Prettify Things")
#+END_SRC

Emacs 24.4 comes with a builtin =prettify-symbols-mode=. It is customized by
changing =prettify-symbols-alist=.

#+BEGIN_SRC emacs-lisp
(use-package prog-mode
  :ensure nil
  :if (skj/current-feature-required-p)
  :hook (prog-mode . prettify-symbols-mode))
#+END_SRC

The packages =prettify-math= and =prettify-greek= extend the configuration above.
The math package requires we set the delimiters before the module loaded.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package prettify-math
    :config
    (setq prettify-math-delimiters-alist
          '(("$" tex)
            ("$$" tex block)
            (("\\(" . "\\)") tex block)
            ("`" asciimath)
            ("``" asciimath block))))

  (use-package prettify-greek
    :config (setq prettify-symbols-alist
                  (append prettify-symbols-alist prettify-greek-lower))))
#+END_SRC

=fira-code-mode= is a simple minor mode for [[https://github.com/tonsky/FiraCode][Fira Code]] ligatures. You can
pre-install the fonts with the command /=M-x fira-code-mode-install-fonts<RET>=/.

#+BEGIN_SRC emacs-lisp
(use-package fira-code-mode
  :if (and (skj/current-feature-required-p) window-system)
  :hook (prog-mode . fire-code)
  :config (fira-code-mode-set-font))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'pretty)
#+END_SRC

*** Structural Editing

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'structure "Structural Editing")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package smartparens
    :diminish smartparens-mode
    :hook
    ((clojure-mode
      emacs-lisp-mode
      lisp-mode
      cider-repl-mode
      racket-mode
      racket-repl-mode) . smartparens-strict-mode))

  (use-package smartparens-config
    :ensure nil
    :after smartparens))
#+END_SRC

Add [[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] for easy parenthesis matching.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :if (skj/current-feature-required-p)
  :diminish rainbow-delimiters-mode
  :hook (prog-mode . 'rainbow-delimiters))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :if (skj/current-feature-required-p)
  :diminish aggressive-indent-mode
  :hook
  (prog-mode . aggressive-indent-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package highlight-indent-guides
  :if (skj/current-feature-required-p)
  :hook (prog-mode)
  :config
  (setq highlight-indent-guides-method 'character
        highlight-indent-guides-responsive 'stack)
  (set-face-foreground 'highlight-indent-guides-character-face "brightmagenta"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'structure)
#+END_SRC

*** Odds & Ends

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'oae "Odds & Ends")
#+END_SRC

This package [[https://github.com/tarsius/hl-todo][highlights TODO]]-like tags in buffers.

#+BEGIN_SRC emacs-lisp
(use-package hl-todo
  :if (skj/current-feature-required-p)
  :diminish hl-todo-mode
  :hook (prog-mode . hl-todo-mode))
#+END_SRC

Turns on /sub-word/ [[https://www.gnu.org/software/emacs/manual/html_node/ccmode/Subword-Movement.html][movement and editing]].

#+BEGIN_SRC emacs-lisp
(use-package subword
  :if (skj/current-feature-required-p)
  :diminish subword-mode)
#+END_SRC

A simple but effective thing, `eldoc-mode= is a MinorMode which [[https://www.emacswiki.org/emacs/ElDoc][shows you]],
in the echo area, the argument list of the function call you are currently
writing.

#+BEGIN_SRC emacs-lisp
(use-package eldoc
  :if (skj/current-feature-required-p)
  :diminish eldoc-mode
  ;; The following works as expected
  :hook (emacs-lisp-mode cider-mode))

;; The following doesn't.
;; (turn-on-eldoc)
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'oae)
(skj/feature-end 'ui)
#+END_SRC

** Project Support

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'project "Project Support")
#+END_SRC

*** Projectile

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'projectile)
#+END_SRC

Projectile is a project interaction library for Emacs. Its goal is to provide
a nice set of features operating on a project level without introducing
external dependencies (when feasible).

=projectile-git-autofetch= is a minor mode for Emacs to automatically fetch
repositories you are currently working on (by default, all open repositories
known to projectile).

=project-explorer= provides a tree-based project explorer sidebar.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package projectile
    :defer 2
    :diminish projectile-mode
    :after (ivy hydra)
    :config
    (setq projectile-completion-system 'ivy
          projectile-require-project-root t
          projectile-project-search-path
          (mapcar (lambda (p)
                    (concat (file-name-as-directory skj/project-root-dir) p))
                  '("emacs-little-packages" "racket" "rust" "Amazon")))
    
    (when (system-mac-p)
      (define-key projectile-mode-map (kbd "s-p") 'projectile-command-map))
    
    (pretty-hydra-define hydra-projectile
      (:color amaranth :quit-key "q" :title "Projectile")
      ("Projects"
       (("s"   projectile-switch-project           "Switch Project")
        ("x"   projectile-remove-known-project     "Remove Known Project")
        ("c"   projectile-invalidate-cache         "Clear Cache")
        ("X"   projectile-cleanup-known-projects   "Cleanup Known Projects"))
       "Directories"
       (("d"   projectile-find-dir                 "Find Directory"))
       "Files"
       (("f"   projectile-find-file                "Find File")
        ("r"   projectile-recentf                  "Recent Files")
        ("z"   projectile-cache-current-file       "Cache Current File"))
       "Buffers"
       (("o"   projectile-multi-occur              "Multi Occur")
        ("b"   projectile-switch-to-buffer         "Switch to Buffer")
        ("k"   projectile-kill-buffers             "Kill Buffers"))))
    (bind-key "<f9> p" 'hydra-projectile/body)
    
    (projectile-global-mode))

  (use-package projectile-git-autofetch
    :after projectile
    :config (projectile-git-autofetch-mode 1))

  (use-package projectile-ripgrep
    :after (ripgrep projectile))

  (use-package counsel-projectile
    :after (counsel projectile)
    :config
    (counsel-projectile-mode 1)
    (projectile-mode +1))

  ;; invoke via flycheck-projectile-list-errors
  (use-package flycheck-projectile
    :after (flycheck projectile)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'projectile)
#+END_SRC

*** iBuffer Integration

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'ibuffer "iBuffer Integration")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ibuffer-projectile
  :if (skj/current-feature-required-p)
  :config (add-hook 'ibuffer-hook
                    (lambda ()
                      (ibuffer-projectile-set-filter-groups)
                      (unless (eq ibuffer-sorting-mode 'alphabetic)
                        (ibuffer-do-sort-by-alphabetic)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'ibuffer)
#+END_SRC

*** Project Explorer

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'explorer)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package project-explorer
  :if (skj/current-feature-required-p)
  :bind ("<f8>" . project-explorer-toggle)
  :config (setq pe/filenotify-enabled t
                pe/inline-folders t
                pe/omit-gitignore t
                pe/side 'left
                pe/width 40))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'explorer)
#+END_SRC

*** Find Files

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'ivy "Ivy Find Files")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package find-file-in-project
  :if (skj/current-feature-required-p)
  :config (ivy-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'ivy)
(skj/feature-end 'project)
#+END_SRC

** Language Server (Generic)

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'lsp "Language Server (Generic)")
#+END_SRC

- Documentation: https://emacs-lsp.github.io/lsp-mode/
- Supported language servers: https://emacs-lsp.github.io/lsp-mode/page/languages/

#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :if (skj/current-feature-required-p)
  :init
  (setq lsp-keymap-prefix "M-o")
  :commands lsp
  :config (setq lsp-eldoc-render-all t
                lsp-idle-delay 0.6
                lsp-keep-workspace-alive nil
                lsp-completion-provider :capf
                lsp-signature-doc-lines 5))
#+END_SRC

This package contains all the higher level UI modules of =lsp-mode=, like
flycheck support and code lenses.
 
#+BEGIN_SRC emacs-lisp
(use-package lsp-ui
  :if (skj/current-feature-required-p)
  :hook (lsp-mode)
  :config (setq lsp-ui-doc-enable nil
                lsp-ui-doc-position 'bottom
                lsp-ui-peek-always-show t
                lsp-ui-peek-fontify 'always
                lsp-ui-sideline-enable t
                lsp-ui-sideline-show-hover t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;;;###autoload
(defun skj/imenu-toggle-maybe-lsp ()
  "Toggle an imenu list popup; it will use lsp-ui if it is enabled."
  (interactive)
  (if (bound-and-true-p lsp-mode)
	  (lsp-ui-imenu)
    (imenu-list-smart-toggle)))
#+END_SRC

This package provides an interactive =ivy= interface to the workspace symbol
functionality offered by =lsp-mode=.

- ~lsp-ivy-workspace-symbol~ - workspace symbols for the current workspace
- ~lsp-ivy-global-workspace-symbol~ - workspace symbols from all of the active
  workspaces.

#+BEGIN_SRC emacs-lisp :exports none
(use-package lsp-ivy
  :if (skj/current-feature-required-p)
  :after (lsp ivy))
#+END_SRC

*Key Bindings/Commands*

- =completion-at-point= for completions
- Signatures when writing methods (/=C-n=/, /=C-p=/ to cycle signatures)
- =lsp-find-definition=: /=C-c l g r=/
- =lsp-find-references=: /=C-c l g g=/
- =lsp-rename=: /=C-c l r r=/
- =lsp-format-buffer=: /=C-c l ==/
- =lsp-ui-peek-find-references= to show references inline (/=M-n=/, /=M-p=/ to cycle)

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'lsp)
#+END_SRC

** Test and Debug

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'test "Test and Debug")
#+END_SRC

Toggle Test allows you to quickly switch between test and test subject. This
is a very useful tool to have when you are TDDing.

#+BEGIN_SRC emacs-lisp
(use-package toggle-test
  :config
  (global-set-key (kbd "C-c t") 'tgt-toggle))
#+END_SRC

cov shows code coverage data for your program in emacs. Currently, it supports
gcov, lcov, coverage.py, and clover output, as well as the Coveralls format
produced by undercover.el.

#+BEGIN_SRC emacs-lisp
(use-package cov)
#+END_SRC

Need to customize either `cov-coverage-file-paths' or
`cov-coverage-file-paths' for different coverage tools/languages.

*** DAP Settings

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'dap "DAP Settings")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package dap-mode
    :config (setq dap-auto-configure-features
                  '(sessions locals controls tooltip))
    (dap-mode 1))
  
  (use-package dap-ui
    :ensure nil
    :config
    (dap-ui-mode 1)
    (dap-ui-controls-mode 1)
    ;; Enables mouse hover support
    (dap-tooltip-mode 1)
    ;; Use tooltips for mouse hover,
    ;; if it is not enabled `dap-mode' will use the minibuffer.
    (tooltip-mode 1)
    ;; Displays floating panel with debug buttons
    (dap-ui-controls-mode 1)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'dap)
#+END_SRC

*** REST & SOAP Clients

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'clients "REST & SOAP Clients")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  (use-package restclient)

  (use-package company-restclient
    :after restclient
    :config (add-to-list 'company-backends 'company-restclient))

  (use-package restclient-test
    :after restclient)

  (use-package ob-restclient
    :after (org restclient)
    :config (skj/org-babel-load-languages '(restclient))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package soap-client
  :if (skj/current-feature-required-p))
#+END_SRC

To inspect a loaded WSDL document, you can do the following:

#+BEGIN_EXAMPLE emacs-lisp
(use-package soap-inspect
  :ensure nil :defer nil)

(soap-inspect previously-loaded-wsdl)
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'clients)
#+END_SRC

*** Swagger

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'swagger)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package swagger-to-org
  :if (skj/current-feature-required-p))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'swagger)
(skj/feature-end 'test)
#+END_SRC

** Data Formats

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'data "Data Formats")
#+END_SRC

*** CSV

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'csv)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package pcsv)

  (use-package csv-mode :mode "\\.csv\\'"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'csv)
#+END_SRC

*** JSON

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'json)
#+END_SRC

The JSON parser package `json' is builtin.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package json-mode :mode "\\.json\\'")

  (use-package json-navigator))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'json)
#+END_SRC

*** TOML

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'toml)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package toml)

  (use-package toml-mode :mode "\\.toml\\'"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'toml)
#+END_SRC

*** YAML

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'yaml)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package yaml-mode
    :mode "\\.yaml\\'")

  (use-package yaml-imenu
    :after yaml-mode
    :config (yaml-imenu-enable))

  (use-package yaml)

  (use-package yaml-pro
    :after yaml)

  (use-package flycheck-yamllint
    :defer t
    :init
    (eval-after-load 'flycheck
      '(add-hook 'flycheck-mode-hook 'flycheck-yamllint-setup))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'yaml)
(skj/feature-end 'data)
#+END_SRC

** Language Environments

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'lang "Language Environments")
#+END_SRC

Emacs Refactor ([[https://github.com/Wilfred/emacs-refactor][EMR]]) is a framework for providing language-specific
refactoring in Emacs. It includes refactoring commands for a variety of
languages, including elisp itself!

#+BEGIN_SRC emacs-lisp
(use-package emr
  :if (skj/current-feature-required-p)
  :after projectile
  :config
  (define-key prog-mode-map (kbd "M-RET") 'emr-show-refactor-menu))
#+END_SRC
  
*** BNF-like

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'bnf "BNF-like")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package bnf-mode)

  (use-package ebnf-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'bnf)
#+END_SRC

*** Emacs Lisp

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'elisp "Emacs Lisp")
#+END_SRC

[[https://www.emacswiki.org/emacs/CheckDoc][CheckDoc]] checks your Emacs Lisp code for errors in documentation and style.
Running CheckDoc is a must before posting to =gnu.emacs.sources= or uploading to
the [[https://www.emacswiki.org/emacs/ElispArea][ElispArea]].

#+BEGIN_SRC emacs-lisp
(use-package checkdoc
  :if (skj/current-feature-required-p)
  :ensure nil
  :hook (emacs-lisp-mode . checkdoc-minor-mode))
#+END_SRC

The [[https://github.com/Boruch-Baum/emacs-pkg-overview][pkg-overview]] package parses an elisp file's comments, definitions,
docstrings, and other documentation into a hierarchical =org-mode= buffer. It is
intended to facilitate familiarization with a file's contents and organization
/ structure. The viewer can quickly swoop in and out and across the file
structure using standard =org-mode= commands and keybindings.

#+BEGIN_SRC emacs-lisp
(use-package pkg-overview
  :if (skj/current-feature-required-p)
  :after org)
#+END_SRC

The [[https://github.com/purcell/package-lint][package-lint]] library provides a linter for the metadata in Emacs Lisp
files which are intended to be packages. You can integrate it into your build
process. package-lint detects various issues that may make your package
uninstallable or unusable for some users, and it warns about significant
deviations from the Elisp coding conventions, such as non-compliant symbol
naming, and use of reserved keybindings. Among other community uses,
=package-lint= is a prerequisite for submission of packages to MELPA.

Currently the /flycheck/-checker is only activated if a =;; Package-Requires:=, =;;
Version:= or =;; Package-Version:= header is present in the current buffer.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package package-lint)

  (use-package flycheck-package
    :after (flycheck package-lint)))
#+END_SRC

[[https://github.com/mattiase/relint][Relint]] scans Emacs Lisp files for mistakes in regexps, including deprecated
syntax and bad practice. Can be called interactively with =M-x relint-file= or
=M-x relint-current-buffer=. It also checks the regexp-like arguments to the
functions `skip-chars-forward', `skip-chars-backward', `skip-syntax-forward'
and `skip-syntax-backward'. Additionally [[https://github.com/purcell/flycheck-relint][flycheck-relint]] performs these checks
continuously.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package relint)
  
  (use-package flycheck-relint
    :after (flycheck relint)
    :config (flycheck-relint-setup)))
#+END_SRC

For unit testing, start with the builtin ERT (Emacs Lisp Regression Testing)
library.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package ert :ensure nil)

  (use-package ert-expectations :after ert)

  (use-package ert-modeline
    :after ert
    :hook emacs-lisp-mode))
#+END_SRC

Eldev (Elisp development tool) is an Emacs-based build tool, targeted solely
at Elisp projects. It is an alternative to Cask. Unlike Cask, Eldev itself is
fully written in Elisp and its configuration files are also Elisp programs. If
you are familiar with Java world, Cask can be seen as a parallel to Maven — it
uses project /description/, while Eldev is sort of a parallel to Gradle — its
configuration is a /program/ on its own.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (unless (executable-find  "eldev")
    
    (use-package f
      :defer nil
      :config
      (defun skj/install-string-as-script (text name &optional bin-dir)
        (let* ((bin-dir (or bin-dir (concat-path user-home-directory "bin")))
               (bin-file (concat-path bin-dir name)))
          (f-write-text text 'utf-8 bin-file)
          (set-file-modes bin-file 755))))

    (use-package request
      :defer nil
      :after f
      :config
      (request "https://raw.github.com/doublep/eldev/master/bin/eldev"
        :success (lambda (&rest arg-plist) (skj/install-string-as-script
                                            (plist-get arg-plist :data)
                                            "eldev")))))

  (when (executable-find  "eldev")

    (use-package eldev)

    (use-package flycheck-eldev
      :after (flycheck eldev))))
#+END_SRC

Because the builtin =ielm=, /inferior emacs lisp mode/, is damn hard to remember, here's a
simple shortcut.

#+BEGIN_SRC emacs-lisp
(use-package ielm
  :ensure nil
  :if  (skj/current-feature-required-p)
  :config
  (defalias 'emacs-lisp-repl 'ielm))
#+END_SRC

So you've just added an incorrect entry to =auto-mode-alist= and want to fix it
quickly. `M-x edit-list RET auto-mode-alist RET' to the rescue. Make your
changes and hit either `C-x C-s' or `C-c C-c' when done. Or just kill the
buffer if you change your mind.

#+BEGIN_SRC emacs-lisp
(use-package edit-list :if (skj/current-feature-required-p))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'elisp)
#+END_SRC

*** Common Lisp

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'common-lisp)
#+END_SRC

Get an implementation:

- SBCL – [[SBCL – Steel Bank Common Lisp (SBCL) is a high performance Common Lisp compiler. It is open source / free software, with a permissive license. In addition to the compiler and runtime system for ANSI Common Lisp, it provides an interactive environment including a debugger, a statistical profiler, a code coverage tool, and many other extensions. (http://www.sbcl.org/)][Steel Bank Common Lisp (SBCL)]] is a high performance Common Lisp
  compiler. It is open source / free software, with a permissive license. In
  addition to the compiler and runtime system for ANSI Common Lisp, it
  provides an interactive environment including a debugger, a statistical
  profiler, a code coverage tool, and many other extensions.
- [[https://clisp.sourceforge.io/][GNU Common Lisp]] (CLISP)
- Allegro CL ® is the most powerful dynamic object-oriented development system
  available today, and is especially suited to enterprise-wide, complex
  application development. Complex applications with billions of objects are
  now made easy with [[https://franz.com/products/allegro-common-lisp/][Allegro CL 10]].
  - The command-line tool is =alisp=.

Quicklisp – [[https://www.quicklisp.org/beta/][Quicklisp]] is a library manager for Common Lisp. It works with your
existing Common Lisp implementation to download, install, and load any of over
1,200 libraries with a few simple commands.

#+BEGIN_EXAMPLE bash
curl -O https://beta.quicklisp.org/quicklisp.lisp
curl -O https://beta.quicklisp.org/quicklisp.lisp.asc
gpg --verify quicklisp.lisp.asc quicklisp.lisp
echo "Type this into CLisp (quicklisp-quickstart:install)"
sbcl --load quicklisp.lisp
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defvar quicklisp-directory
    (expand-file-name "~/quicklisp")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package slime
    :ensure-system-package (clisp sbcl)
    :config
    (setq inferior-lisp-program (executable-find "sbcl")
          slime-complete-symbol*-fancy t
          slime-complete-symbol-function 'slime-fuzzy-complete-symbol
          slime-contribs '(slime-fancy))
    (load (expand-file-name (concat-path "slime-helper.el"))))

  (use-package slime-company
    :after (slime company)
    :init
    (slime-setup '(slime-fancy slime-asdf slime-company)))

  (use-package slime-repl-ansi-color
    :after slime
    :config
    (slime-setup '(slime-fancy slime-repl-ansi-color)))

  (use-package elisp-slime-nav
    :after slime
    :hook ((emacs-lisp-mode ielm-mode) . elisp-slime-nav-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'common-lisp)
#+END_SRC

*** Scheme

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'scheme)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package scheme
    :ensure nil)

  (use-package quack
    :after scheme)

  (use-package scheme-complete
    :after scheme)

  (use-package lsp-scheme
    :hook (scheme-mode . lsp-gambit-scheme)))
#+END_SRC

Geiser ([[https://www.nongnu.org/geiser/][home]]) is a generic Emacs/Scheme interaction mode, featuring an
enhanced REPL and a set of minor modes improving Emacs' basic scheme
major mode.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package geiser
    :hook (geiser-mode . smartparens-strict))

  (use-package geiser-chez :after geiser)

  (use-package geiser-gauche :after geiser)

  (use-package geiser-racket :after geiser)

  (use-package macrostep-geiser
    :after geiser
    :hook ((geiser-mode . macrostep-geiser-setup)
           (geiser-repl-mode . macrostep-geiser-setup))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'scheme)
#+END_SRC

*** Racket

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'racket)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package dr-racket-like-unicode)

  (use-package racket-mode)

  (use-package scribble-mode :after racket-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'racket)
#+END_SRC

*** Ada

Not currently using this, but have used the following:

- =eglot= as an LSP client to the AdaCore (GNAT) [[https://github.com/AdaCore/ada_language_server][ALS]].
- =ada-mode=
- =ada-ref-man=

It is important to note that you not only need a compiler (again, AdaCore) but
also the [[https://alire.ada.dev/][Alire]] package manager. Download =alr= and run =alr toolchain --select= to
get an Ada environment installed.

*** Rust Language

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'rust)
#+END_SRC

The key to Rust development in Emacs is the [[https://github.com/brotzeit/rustic][Rustic]] package. This
wraps and extends the older [[https://github.com/rust-lang/rust-mode][rust-mode]] and other tools.

- 
- https://robert.kra.hn/posts/rust-emacs-setup/

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (defun rustic-mode-auto-save-hook ()
    "Enable auto-saving in rustic-mode buffers."
    (when buffer-file-name
      (setq-local compilation-ask-about-save nil)))

  (use-package rustic
    :after (lsp lsp-lens-mode)
    :hook ((rustic-mode . rustic-mode-auto-save-hook)
           (rustic-mode . lsp-lens-mode)
           (rustic-mode . (lambda () (set-fill-column 100)))
           (rustic-mode . subword-mode))
    :config
    (setq rustic-babel-format-src-block t
          rustic-babel-auto-wrap-main t
          rustic-format-on-save t
          rustic-lsp-server 'rust-analyzer
          lsp-rust-analyzer-cargo-load-out-dirs-from-check t
          lsp-rust-analyzer-cargo-watch-enable t
          lsp-rust-analyzer-cargo-watch-command "clippy"
          lsp-rust-analyzer-display-chaining-hints t
          lsp-rust-analyzer-display-closure-return-type-hints t
          lsp-rust-analyzer-display-lifetime-elision-hints-use-parameter-names nil
          lsp-rust-analyzer-display-parameter-hints t
          lsp-rust-analyzer-display-reborrow-hints t
          lsp-rust-analyzer-inlay-hints-mode t
          lsp-rust-analyzer-proc-macro-enable t
          lsp-rust-analyzer-server-display-inlay-hints t))

  (use-package cargo-mode
    :if (skj/current-feature-required-p)
    :after rustic
    :hook (rustic-mode . cargo-minor-mode))

  (use-package rust-auto-use
    :if (skj/current-feature-required-p)
    :after rustic)

  (use-package rust-playground
    :if (skj/current-feature-required-p)
    :after rustic))
#+END_SRC

Flycheck for Rust.

#+BEGIN_SRC emacs-lisp
(use-package flycheck-rust
  :if (skj/current-feature-required-p)
  :ensure-system-package (cargo-clippy . "cargo install cargo-clippy")
  :after (rustic cargo-mode)
  :hook (flycheck-mode . flycheck-rust-setup)
  :config
  (setq flycheck-rustic-clippy-executable "cargo-clippy")
  (add-to-liat 'flycheck-checkers 'rustic-clippy))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defun skj/rust-setup-toggle-test ()
    "Set the `toggle-test' configuration for the current Rust project."
    (interactive)
    (let ((root (projectile-project-root)))
      (if root
          (if (file-exists-p (concat-path root "Cargo.toml"))
              (progn
                (add-to-list 'tgt-projects
                             (cons
                              (list :root-dir root)
                              '((:src-dirs "src") 
                                (:test-dirs "tests")
                                (:test-prefixes "test_"))))
                (message "Added toggle-test for %s" root))
            (message "Project root is not a Rust project"))
        (message "No project root"))))
  
  (add-hook 'rustic-mode 'skj/rust-setup-toggle-test))
#+END_SRC
 
DAP debugger profile for Rust.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (add-hook 'rustic-mode-hook
            (lambda () (require 'dap-mode)
              (dap-register-debug-template
               "Rust::GDB Run Configuration"
               (list :type "gdb"
                     :request "launch"
                     :name "GDB::Run"
                     :gdbpath "rust-gdb"
                     :target nil
                     :cwd nil)))))
#+END_SRC
 
Access Rust documentation from within emacs. You can now convert
package-specific documentation with
`rustic-doc-convert-current-package'.
Search the org files with `rustic-doc-search' (bound to =C-#= by
default) if you are in Rust mode, Rustic mode or Org mode. If you
hover over a symbol when you invoke the command, `rustic-doc-search'
will insert a default value.

#+BEGIN_SRC emacs-lisp
(use-package rustic-doc
    :ensure nil
    ;;:if (skj/current-feature-required-p)
    :after (org rustic)
    :ensure-system-package
    (fd
     pandoc
     (cargo-makedocs . "cargo install cargo-makedocs"))
    :config
    (rustic-doc-setup))
#+END_SRC

Org-Babel Integration

#+BEGIN_SRC emacs-lisp
(use-package ob-rust
  :if (skj/current-feature-required-p)
  :after (ob rust)
  :config (skj/org-babel-load-languages 'rust))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'rust)
#+END_SRC

*** PEST Mode

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'pest "PEST")
#+END_SRC

#+BEGIN_SRC emacs-lisp
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package pest-mode
  :if (skj/current-feature-required-p)
  :ensure-system-package (pesta . "cargo install pesta")
  :mode "\\.pest\\'")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  (use-package flymake-pest
    :after (pest-mode)
    :hook ((pest-mode . flymake-pest-setup)
           (pest-input-mode . flymake-pest-input-setup)))

  (use-package flycheck-pest
    :if (skj/current-feature-required-p)
    :after (flycheck pest-mode)
    :config (flycheck-pest-setup)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'pest)
#+END_SRC

*** Ocaml

- =dune-format=
- =flycheck-ocaml=
- =learn-ocaml=
- =merlin=
- =ocamlformat=
- =opam-switch-mode=
- =tuareg=
- =utop=

*** Smithy

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'smithy "Smithy (AWS)")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package smithy-mode
  :if (skj/current-feature-required-p))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'smithy)
#+END_SRC

*** SQL Stuff

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'sql "SQL")
#+END_SRC

The builtin =sql= package provides a sql-mode and a sql-interactive-mode. The
original goals were two simple modes providing syntactic highlighting. The
interactive mode had to provide a command-line history; the other mode had to
provide "send region/buffer to SQL interpreter" functions.

#+BEGIN_SRC emacs-lisp
(use-package sql :ensure nil)
#+END_SRC

Support formatting SQL buffers.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package sqlformat
    :after sql
    :ensure-system-package (sqlfluff . "pip3 install sqlfluff")
    :config (setq sqlformat-command "sqlfluff"))

  (add-hook 'sql-mode-hook 'sqlformat-on-save-mode)

  (use-package flymake-sqlfluff
    :after (flymake sqlformat)
    :hook (sql-mode . flymake-sqlfluff-load)))
#+END_SRC

Use the builtin =sql-mode= in Org blocks.

#+BEGIN_SRC emacs-lisp
(use-package ob-sql-mode
  :if (skj/current-feature-required-p)
  :after sql)
#+END_SRC

Emacs own interface for SQL databases.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package emacsql)

  (use-package emacsql-sqlite-module
    :after emacsql))
#+END_SRC

Using =abbrev-mode= SQL keywords are all capitalized, but readable within
comments.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (defun sql-in-code-context-p ()
    (if (fboundp 'buffer-syntactic-context) ; XEmacs function.
        (null (buffer-syntactic-context))
      ;; Attempt to simulate buffer-syntactic-context
      ;; I don't know how reliable this is.
      (let* ((beg (save-excursion
 		            (beginning-of-line)
 		            (point)))
 	         (list
 	          (parse-partial-sexp beg (point))))
        (and (null (nth 3 list))		; inside string.
 	         (null (nth 4 list))))))	; inside cocmment

  (defun sql-pre-abbrev-expand-hook ()
    ;; Allow our abbrevs only in a code context.
    (setq local-abbrev-table
	      (if (sql-in-code-context-p)
	          sql-mode-abbrev-table)))

  (add-hook 'sql-mode-hook
            (lambda ()
              (add-hook 'pre-abbrev-expand-hook #'sql-pre-abbrev-expand-hook nil t)
              (abbrev-mode 1))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'sql)
#+END_SRC

*** Web Development

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'web "Web Development")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :if (skj/current-feature-required-p)
  :hook (web-mode . (lambda ()
                      (set (make-local-variable 'company-backends)
                           '(company-web-html))
                      (company-mode t)))
  :mode "\\(\\.html?\\|\\.njk\\)\\'"
  :config
  (setq web-mode-markup-indent-offset 2
        web-mode-code-indent-offset 2
        web-mode-enable-current-element-highlight t
        web-mode-ac-sources-alist
        '(("css" . (ac-source-css-property))
          ("html" . (ac-source-words-in-buffer ac-source-abbrev)))))
#+END_SRC

Support for editing common template pages, specifically Jinja mode.

#+BEGIN_SRC emacs-lisp
(use-package jinja2-mode :if (skj/current-feature-required-p))
#+END_SRC

Extensions to the standard =html-mode=.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package auto-rename-tag :hook html-mode)

  (use-package cakecrumbs
    :config
    (setq cakecrumbs-html-major-modes '(html-mode web-mode nxml-mode sgml-mode)
          cakecrumbs-scss-major-modes '(scss-mode less-css-mode css-mode))
    (cakecrumbs-auto-setup))

  (defun skj/toggle-showcss()
    "Toggle showcss-mode"
    (interactive)
    (if (derived-mode-p
         'html-mode
         'nxml-mode
         'nxhtml-mode
         'web-mode
         'handlebars-mode)
        (showcss-mode 'toggle)
      (message "Not in an html mode")))

  (use-package show-css
    :bind ("C-c C-k" . skj/toggle-showcss)))
#+END_SRC

Completion

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package ac-html-bootstrap)

  (use-package ac-html-csswatcher)

  (use-package company-web
    :after company
    :hook (web-mode . company-mode)
    :config
    (add-to-list 'company-backends 'company-css)
    (add-to-list 'company-backends 'company-web-html))

  (use-package counsel-css))
#+END_SRC


Some support for React development.

#+BEGIN_SRC emacs-lisp
(use-package react-snippets
  :if (skj/current-feature-required-p))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'web)
#+END_SRC

*** JavaScript

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'javascript "JavaScript")
#+END_SRC

Note that =js2-refactor= is a dependency for the general =emr= above.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package js2-mode
    :mode (("\\.js\\'" . js2-mode)
           ("\\.mjs\\'" . js2-mode)))

  (use-package js2-highlight-vars)

  (use-package js2-refactor
    :hook (js2-mode)
    :config (js2r-add-keybindings-with-prefix "C-c C-r"))

  (use-package js2hl)

  (use-package xref-js2))
#+END_SRC

Integration of [[https://beautifier.io/][beautifier.io]].

#+BEGIN_SRC emacs-lisp
(use-package web-beautify
  :if (skj/current-feature-required-p))
#+END_SRC

The underlying command-line tool is  installed by typing: =npm -g install js-beautify=.

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'javascript)
#+END_SRC

*** Typescript

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'typescript)
#+END_SRC

See:

- https://github.com/ananthakumaran/tide
- https://github.com/emacs-typescript/ts-comint
- https://github.com/emacs-typescript/typescript.el

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package typescript-mode)

  (use-package tide)

  (use-package ts-comint))
#+END_SRC

To run a TypeScript interpreter (REPL) in an inferior process window =M-x
run-ts=. For the external interpreter you'll need to run =npm install -g tsun=.

Use =typescript-mode= in Org blocks.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package ob-typescript
    :after typescript-mode
    :config (skj/org-babel-load-languages 'typescript)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'typescript)
#+END_SRC

*** Dart and Flutter

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'dart "Dart and Flutter")
#+END_SRC

[[https://github.com/bradyt/dart-mode/wiki][Major mode for editing Dart files]]

For this install, assuming that the Flutter SDK, not simply Dart.

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p)
           (not (executable-find "flutter")))
    (homebrew-package-install 'flutter))
#+END_SRC

Now, using the =flutter= command we can get versions for the SDK tools.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (let ((versions (shell-command-to-string "flutter --version")))
    (when (match-data) (set-match-data nil))
    (while (string-match "\\(\\([A-Z][a-z]+\\) \\([0-9]+\\.[0-9]+\\.[0-9]+\\)\\)"
                         versions
                         (or (match-end 0) 0))
      (set (intern (format "dart--%s--version"
                           (downcase (substring versions (match-beginning 2) (match-end 2)))))
           (substring versions (match-beginning 3) (match-end 3))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package dart-mode
    :after projectile
    :hook lsp
    :config
    (reformatter-define dart-format
      :program "dart"
      :args '("format"))
    (add-to-list 'projectile-project-root-files-bottom-up "pubspec.yaml")
    (add-to-list 'projectile-project-root-files-bottom-up "BUILD"))

  (use-package lsp-dart :after (dart-mode lsp-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package flutter
    :after dart-mode
    :hook (dart-mode . flutter-test-mode)
    :bind (:map dart-mode-map
                ("C-M-x" . #'flutter-run-or-hot-reload))
    :config
    (flutter-sdk-path "/Applications/flutter/"))

  (use-package flutter-l10n-flycheck :after (flutter flycheck)))
#+END_SRC

Emacs tool for running flutter mobile apps on desktop using [[https://github.com/ericdallo/hover.el][hover]].

#+BEGIN_SRC emacs-lisp
(use-package hover
  :if (skj/current-feature-required-p)
  :after dart-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ob-dart
  :if (skj/current-feature-required-p)
  :after dart-mode
  :config (skj/org-babel-load-languages 'dart))
#+END_SRC

Add Org Babel support.

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'dart)
#+END_SRC

*** Semantic Web

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'rdf "Semantic Web")
#+END_SRC

The [[https://github.com/nxg/ttl-mode][ttl-mode]] package provides RDF Turtle, and Notation 3, mode.

#+BEGIN_SRC emacs-lisp
(use-package ttl-mode
   :if (skj/current-feature-required-p)
   :hook (ttl-mode . turn-on-font-lock)
   :mode ("\\.n3" "\\.ttl"))
#+END_SRC

Lookup RDF prefixes

#+BEGIN_SRC emacs-lisp
(use-package rdf-prefix :if (skj/current-feature-required-p))
#+END_SRC

SPARQL mode, including =org-mode= blocks.

#+BEGIN_SRC emacs-lisp
(use-package sparql-mode
  :if (skj/current-feature-required-p)
  :mode (("\\.sparql\\'" . sparql-mode)
         ("\\.rq\\'" . sparql-mode))
  :config (skj/org-babel-load-languages '(sparql)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'rdf)
#+END_SRC

*** Proof Assistants

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'provers "Proof Assistants")
#+END_SRC

[[https://proofgeneral.github.io/][Proof General]] is a generic Emacs interface for proof assistants (also known as
interactive theorem provers). It is supplied ready to use for the proof
assistants [[https://coq.inria.fr/][Coq]], EasyCrypt, qrhl, and PhoX. This package provides =coq-mode=
referenced in the sections following.

#+BEGIN_SRC emacs-lisp
(use-package proof-general
  :if (skj/current-feature-required-p))
#+END_SRC

Emacs commenting support tools for Coq proof assistance

#+BEGIN_SRC emacs-lisp
(use-package coq-commenter
  :if (skj/current-feature-required-p)
  :hook (coq-mode)
  :bind (:map coq-commenter-mode-map
              ("C-;" . coq-commenter-comment-proof-in-region)
              ("C-x C-;" . coq-commenter-comment-proof-to-cursor)
              ("C-'" . coq-commenter-uncomment-proof-in-region)
              ("C-x C-'" . coq-commenter-uncomment-proof-in-buffer)))
#+END_SRC

This package includes a collection of =company-mode= back-ends for
=proof-general='s Coq mode, and other useful extensions to Proof-General.

#+BEGIN_SRC emacs-lisp
(use-package company-coq
  :if (skj/current-feature-required-p)
  :hook (coq-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package org-contrib
    :ensure nil
    :after org)

  (use-package ob-coq
    :ensure nil
    :after org-contrib
    :config
    (skj/org-babel-load-languages 'coq)))
#+END_SRC

The =boogie-friends= package is an experimental collection of Emacs modes for
writing verified programs in z3 and languages of the Boogie family (including
Dafny).

#+BEGIN_SRC emacs-lisp
(use-package boogie-friends
  :if (skj/current-feature-required-p)
  :mode
  ("\\.smt2\\'" . z3-smt2-mode)
  ("\\.dfy\\'" . dafny-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'provers)
(skj/feature-end 'lang)
#+END_SRC

** AWS Integration

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'aws "AWS Integrations")
#+END_SRC

[[https://github.com/sebasmonia/awscli-capf][awscli-capf]] provides support for AWS CLI completion, with quick access to the
vast documentation. When you type =aws= in your shell buffer, completion at
point would suggest valid commands. And by leveraging some company-mode
extensions, the docs are one =C-h= away!

#+BEGIN_SRC emacs-lisp
(use-package awscli-capf
  :if (skj/current-feature-required-p)
  :config (add-hook 'shell-mode-hook
                    (lambda ()
                      (add-to-list 'completion-at-point-functions 'awscli-capf))))
#+END_SRC

[[https://github.com/baron42bba/aws-snippets][aws-snippets]] adds =yasnippet= snippets for AWS CLI and CloudFormation templates.

#+BEGIN_SRC emacs-lisp
(use-package aws-snippets :if (skj/current-feature-required-p))
#+END_SRC

[[https://github.com/cniles/axe][axe]] lets you use Emacs as a frontend for interacting with AWS resources. It
makes available a number of tasks, such as listing buckets, invoking lambdas
and tailing logs, ergonomically available through emacs.

#+BEGIN_SRC emacs-lisp
(use-package axe
  :if (skj/current-feature-required-p)
  :config (setq axe-region 'us-west-2))
#+END_SRC

Editing and Flycheck modes for Cloud Formation Templates.

#+BEGIN_SRC emacs-lisp
(use-package cfn-mode
  :if (skj/current-feature-required-p))

(use-package flycheck-cfn
  :if (skj/current-feature-required-p)
  :after cfn-mode
  :config (flycheck-cfn-setup))
#+END_SRC

Also consider =aws-ec2=.

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'aws)
#+END_SRC

** Developer Services

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'services "Developer Services")
#+END_SRC

*** Wakatime

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'wakatime)
#+END_SRC

[[https://wakatime.com/emacs][Wakatime]] service customization. This service tries to keep track of what
projects and what tools you use as an engineer. Set the API key in =~/.wakatime.cfg=.

#+BEGIN_SRC emacs-lisp
(use-package wakatime-mode
  :if (skj/current-feature-required-p)
  :config
  (setq wakatime-cli-path (locate-file "wakatime-cli" exec-path))
  (global-wakatime-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'wakatime)
(skj/feature-end 'services)
(skj/feature-end 'dev)
#+END_SRC


* Social

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'social)
#+END_SRC

Basic [[https://www.gnu.org/software/emacs/manual/html_node/gnus/][Gnus Newsreader]] configuration. Enter Gnus with /=M-x gnus=/
.
#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package gnus
    :ensure nil
    :config
    (setq gnus-select-method '(nntp "news.gnus.org")))

  (use-package nnhackernews
    :after gnus
    :config
    (add-to-list 'gnus-secondary-select-methods '(nnhackernews ""))))
#+END_SRC

Enter the =nnhackernews:news= newsgroup with /=RET=/.

And of course, more icons!

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-gnus
  :if (and window-system (skj/current-feature-required-p))
  :after gnus
  :config (all-the-icons-gnus-setup))
#+END_SRC

=mastodon.el= ([[https://codeberg.org/martianh/mastodon.el][here]]) is an Emacs client for the AcitivityPub social networks that
implement the Mastodon API. For info see https://joinmastodon.org/.

#+BEGIN_SRC emacs-lisp
(use-package mastodon
  :if (skj/current-feature-required-p)
  :config
  (setq mastodon-instance-url "https://hachyderm.io"
        mastodon-active-user skj/default-user-name))
#+END_SRC

=M-x mastadon= Opens a =*mastodon-home*= buffer in the major mode and displays toots. If your
credentials are not yet saved, you will be prompted for email and password.
The app registration process will take place if your =mastodon-token-file= does
not contain =:client=_id and =:client_secret=.

=M-x mastodon-toot= (or =t= from a mastodon.el buffer) Pops a new buffer/window in
text-mode and mastodon-toot minor mode. Enter the contents of your toot here.
=C-c C-c= sends the toot. =C-c C-k= cancels. Both actions kill the buffer and
window.

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'social)
#+END_SRC


* For Fun

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'fun)
#+END_SRC

Don't forget to =M-x asm-blox=!

#+BEGIN_SRC emacs-lisp
(use-package asm-blox :if (skj/current-feature-required-p))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'fun)
#+END_SRC


* Work Configuration

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'work "Work Configuration")
#+END_SRC

Only basic information should exist in here, put the rest in external
resources referenced in [[*Work Packages]].

** Paths

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'paths)
#+END_SRC

These are either common on development boxes or laptop environments.

#+BEGIN_SRC emacs-lisp :exports none
(when (skj/current-feature-required-p)
  
  (dolist (path '("~/bin" "~/.toolbox/bin"))
    (exec-path-prepend path)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'paths)
#+END_SRC

** Customization

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'customization)
#+END_SRC

These variables parallel their non-work values.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (defcustom
    skj/work-email
    "simonjo@amazon.com"
    "Primary email address for work."
    :tag "Work email address"
    :group 'skj
    :type 'string)
  
  (defcustom
    skj/work-organization
    "Amazon Advertising"
    "Display name for employing organization."
    :tag "Work Organization"
    :group 'skj
    :type 'string)

  (defcustom
    skj/work-project-root-dir
    (expand-file-name (concat-path skj/project-root-dir "Amazon"))
    "Root directory for work development projects."
    :tag "Work projects' root directory"
    :group 'skj
    :type 'directory))
#+END_SRC

Add work packages that include LaTeX here.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (setq skj/latex-shared-paths
        (add-to-list 'skj/latex-shared-paths
                     (concat-path skj/work-project-root-dir
                                  "FreshDocumentationTemplates/configuration"))))
#+END_SRC

Add any work BibTeX files here.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (setq skj/bibtex-files
        (add-to-list 'skj/bibtex-files
                     (concat-path skj/work-project-root-dir
                                  "SimonjoDocuments/tex-shared/amazon.bib"))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'customization)
#+END_SRC

** Work Packages

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'packages)
#+END_SRC

The =work= directory should be a symlink to a Git repository containing any
work-specific packages.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  (add-to-list 'load-path (concat-path user-emacs-directory "lib/work")))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'packages)
#+END_SRC

** Org Mode

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'org "Org Mode")
#+END_SRC

Load initial work Org files, there may be more, but this is a start.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (setq org-agenda-files
        (append org-agenda-files
                (list (org-file-name "work-todo.org")
                      (org-file-name "work-people.org.gpg")
                      (org-file-name "work-travel.org")))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'org)
(skj/feature-end 'work)
#+END_SRC


* Finishing Up

#+BEGIN_SRC emacs-lisp :exports none
(init-message "Finishing Up")
#+END_SRC

These things need to be last, some match actions taken at the start of the
file. First, turn advice redefinition warnings back on.

#+BEGIN_SRC emacs-lisp
(setq ad-redefinition-action 'warn)
#+END_SRC

** Reset the GC Threshold

#+BEGIN_SRC emacs-lisp :exports none
(init-message "Reset the GC Threshold")
#+END_SRC

Set garbage collection back to reasonable values now that startup is complete.

#+BEGIN_SRC emacs-lisp
(setq gc-cons-percentage 0.1
      gc-cons-threshold (* 2 1024 1024))
#+END_SRC

** Run Emacs as a Server?

#+BEGIN_SRC emacs-lisp :exports none
(init-message "Run Emacs as a Server?")
#+END_SRC

Pretty self-explanatory, if we aren’t already running as a client, start the
server process.

#+BEGIN_SRC emacs-lisp
(use-package server
  :ensure nil
  :defer nil
  :config
  (unless (and (fboundp 'server-running-p) (server-running-p))
    (init-message "Starting Emacs server")
    (server-start)))
#+END_SRC


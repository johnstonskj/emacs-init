#+TITLE: Emacs Initialization
#+OPTIONS: toc:2

This is the org-mode version of my Emacs configuration. It is pretty long, but
after having a modular version I've actually found having a hyperlinked output
is super useful. Also, I do like literate programming in general although it's
hard to find a good implementation.

Set the garbage collection threshold to a high value during initialization to
speed things along.

#+BEGIN_SRC emacs-lisp
(setq gc-cons-percentage 0.3
      gc-cons-threshold (* 50 1024 1024))
#+END_SRC

We'll also set up a hook to see how long startup took, and with how many GC
cycles.

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "Emacs ready in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time before-init-time)))
                     gcs-done)))
#+END_SRC


#+BEGIN_SRC emacs-lisp :lexical t :exports none
  (defun progress (head &rest tail)
    (let ((str (format "%s%s" head (if tail (concat " ▶ " (string-join tail " ▶ ")) ""))))
	  (message "INIT: %s" str)
	  str))
#+END_SRC

* Utility Functions

#+BEGIN_SRC emacs-lisp :exports none
(setq l1-msg (progress "Utility Functions"))
#+END_SRC

The functions manipulate the path for executable commands outside of Emacs.
They affect both Emacs =exec-path= variable and the
=PATH= environment variable.

#+BEGIN_SRC emacs-lisp
(defun exec-path-prepend (path)
  "Add PATH to the beginning of the current `exec-path` variable,
and the shell's `$PATH` variable."
  (unless (member path exec-path)
    (setq exec-path (cons path exec-path))
    (setenv "PATH" (concat path ":" (getenv "PATH")))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun exec-path-append (path)
  "Add PATH to the end of the current `exec-path` variable, and
the shell's `$PATH` variable."
  (unless (member path exec-path)
    (setq exec-path (append exec-path (list path)))
    (setenv "PATH" (concat (getenv "PATH") ":" path))))
#+END_SRC

The following is a simple predicate that allows for us to add others and be
more descriptive than dealing with the =system-type=
(and other) variables directly.

#+BEGIN_SRC emacs-lisp
(defun system-mac-p ()
  "Return `t` if this is Darwin, else nil."
  (eq system-type 'darwin))
#+END_SRC


* Initial Customization
#+BEGIN_SRC emacs-lisp :exports none
(setq l1-msg (progress "Initial Customization"))
#+END_SRC

** Startup Settings

#+BEGIN_SRC emacs-lisp
(setq echo-keystrokes 0.5
      inhibit-startup-screen t
      inhibit-startup-echo-area-message t
      ring-bell-function 'ignore
      scroll-bar-mode nil
      scroll-margin 1
      scroll-step 1)
#+END_SRC

** Load Path

These paths get added to the module search path, the =lib= directory should be a
symlink to my local Git repository.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (concat-path user-emacs-directory "lib"))
(add-to-list 'load-path (concat-path user-emacs-directory "lib/skj"))
#+END_SRC

** Personal Customization Group

For those things I want to ensure I can find and tweak at runtime I use the
following customization group. This allows you to /=M-x customize-group=/ and
select =skj=.

#+BEGIN_SRC emacs-lisp
(defgroup skj nil
  "Simon's personal environment settings."
  :tag "skj"
  :prefix "skj/")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defcustom
  skj/trace-init
  (if (and (boundp debug-on-error) debug-on-error)
      debug-on-error
    t)
  "Emit tracing messages during initialization, useful with --debug-init."
  :tag "Trace initialization process"
  :group 'skj
  :type 'boolean)
#+END_SRC

** Load Customized Values

It is a good idea to use a separate file for customized settings. Some users
actually create a temporary file so that changes are session-only. However,
I prefer to keep the customization and if they prove useful move them to the
main initialization files.

#+BEGIN_SRC emacs-lisp
(setq custom-file (concat-path user-emacs-directory "custom.el"))
#+END_SRC

Assuming that the code in =custom-file= is execute before the code ahead of this
line is not a safe assumption. So load this file proactively.

#+BEGIN_SRC emacs-lisp
(load-file custom-file)
#+END_SRC

** User Information

Basic identity values, these are my common non-work values.

#+BEGIN_SRC emacs-lisp
(defcustom
  skj/primary-email
  "johnstonskj@gmail.com"
  "Primary, non-work, email address."
  :tag "Primary email address"
  :group 'skj
  :type 'string)

(defcustom
  skj/full-name
  "Simon Johnston"
  "Name to go with email-address."
  :tag "Primary email address"
  :group 'skj
  :type 'string)
#+END_SRC

The following are used by Emacs.

#+BEGIN_SRC emacs-lisp
(setq user-login-name "johnstonskj"
      user-full-name skj/full-name
      user-mail-address skj/primary-email)
#+END_SRC

This is just useful to have.

#+BEGIN_SRC emacs-lisp
(defvar user-home-directory (expand-file-name "~"))
#+END_SRC

This sets my most common location, and while mostly used by calendaring and
[[*Agenda]], I keep it here. Note the three required packages are all Emacs
builtins.

#+BEGIN_SRC emacs-lisp
(require 'calendar)
(require 'cal-dst)
(require 'solar)

(setq calendar-latitude 47.6062
      calendar-longitude -122.3321
      calendar-location-name "Seattle, WA")

(setq calendar-time-zone -480
      calendar-standard-time-zone-name "PST"
      calendar-daylight-time-zone-name "PDT")
#+END_SRC

This isn't absolutely necessary, but keeping a use-case neutral form seems
like a good idea. See also [[*Google Calendar]].

#+BEGIN_SRC emacs-lisp
(setq calendar-time-zone-name "America/Los_Angeles")
#+END_SRC

** Package Management Setup

*** Add Package Repositories

Add the most common package archives and set priorities.

#+BEGIN_SRC emacs-lisp
(require 'package) ;; builtin

(add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/"))
(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
(add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/"))
(package-initialize)

(setq package-archive-priorities '(("gnu" . 30)
                                   ("nongnu" . 25)
                                   ("melpa-stable" . 20)
                                   ("melpa" . 15)
                                   ("marmalade" . 10)))
#+END_SRC

Ensure =use-package= is installed first.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
#+END_SRC

Setting =use-package-always-ensure= to =t= saves us the trouble
of having to specify =:ensure t= in any future packages we’d like to declare and
install. The =:ensure= macro basically makes sure that the packages are
correctly installed at every startup, and automatically installs the missing
ones for you. This is extremely useful when you frequently move between
different machines and need to port your entire Emacs config over to a new
setup.

#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (setq use-package-always-ensure t
        use-package-expand-minimally nil))
#+END_SRC

*** Auto-Update Packages

[[https://github.com/rranelli/auto-package-update.el][This package]] provides functionality for automatically updating your Emacs
packages periodically. It is specially useful for people that work in multiple
machines and tend to forget to manually update packages from time to time.

Configure the update to happen every 7 days, at 3:00am, deleting any
old/obsolete packages after updating.

#+BEGIN_SRC emacs-lisp
(use-package auto-package-update
             :custom
             (auto-package-update-interval 7)
             (auto-package-update-delete-old-versions t)
             (auto-package-update-hide-results t)
             :config
             (auto-package-update-at-time "03:00")
             (auto-package-update-maybe))
#+END_SRC
  
=auto-package-update-maybe= will update your installed packages, if there is an
update pending.

** More Paths
*** Command Execution Paths

[[https://brew.sh/][Homebrew]] is great, but just in case it isn't on the path, this helps a lot.

#+BEGIN_SRC emacs-lisp
(let ((brew (executable-find "brew")))
(when brew
(let ((prefix (string-trim (shell-command-to-string (concat brew " --prefix")))))
  (when prefix
    (setq homebrew-prefix prefix)
    (exec-path-prepend (concat-path homebrew-prefix "bin"))))))
#+END_SRC

This is a weird one, can't remember why ...

#+BEGIN_SRC emacs-lisp
(when (and (system-mac-p) (display-graphic-p))
  (exec-path-prepend "usr/local/bin"))
#+END_SRC

*** Common Project Directory

#+BEGIN_SRC emacs-lisp
(require 'xdg)
#+END_SRC

Set the root for all my projects, home and work.

#+BEGIN_SRC emacs-lisp
(defcustom
  skj/project-root-dir
  (expand-file-name "~/Projects")
  "Root directory for development projects."
  :tag "Project root directory"
  :group 'skj
  :type 'directory)
#+END_SRC


* Generic Configuration

#+BEGIN_SRC emacs-lisp :exports none
  (setq l1-msg (progress "Generic Configuration"))
#+END_SRC

** Core UI Settings

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Core UI Settings"))
#+END_SRC

*** Input Encoding

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Input Encoding")
#+END_SRC

We really like UTF-8!

#+BEGIN_SRC emacs-lisp
(set-locale-environment "en_US.UTF-8")
(set-language-environment "UTF-8")
(setq-default buffer-file-coding-system 'utf-8
              coding-system-for-read 'utf-8
              coding-system-for-write 'utf-8
              file-name-coding-system 'utf-8
              keyboard-coding-system 'utf-8
              locale-coding-system 'utf-8
              prefer-coding-system 'utf-8
              require-final-newline t
              terminal-coding-system 'utf-8)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package iso-transl)
#+END_SRC

*** Basic Editing Customization

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg  "Basic Editing Customization")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
(setq-default fill-column 78
              indent-tabs-mode nil
              indicate-empty-lines t
              tab-always-indent 'complete
              tab-width 4)
#+END_SRC

Don't use it, and it takes up space

#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
#+END_SRC

Save place in files between Sessions

#+BEGIN_SRC emacs-lisp
(save-place-mode 1)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (>= emacs-major-version 26)
  (pixel-scroll-mode))
(when (>= emacs-major-version 29)
  (setq pixel-scroll-precision-mode 1))
#+END_SRC

*** Default Face

This isn't so useful on macOS as it doesn't seem to decode weight and width
correctly so I can't use Fira Code Light.

#+BEGIN_SRC emacs-lisp
(set-face-attribute
'default
nil
:inherit nil
:extend nil
:stipple nil
:background "#fdf6e3"
:foreground "#657b83"
:inverse-video nil
:box nil
:strike-through nil
:overline nil
:underline nil
:slant 'normal
:weight 'light
:height 130
:width 'normal
:foundry "nil"
:family "Fira Code Light")
#+END_SRC

*** Theme Support

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Theme Support")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package color-theme-sanityinc-solarized
    :init
    (setq custom-enabled-themes '(sanityinc-solarized-light)
               custom-safe-themes
               '("4cf3221feff536e2b3385209e9b9dc4c2e0818a69a1cdb4b522756bcdf4e00a4" default))
               :custom
               (color-theme-is-global t)

               :config
               (color-theme-sanityinc-solarized-light))
#+END_SRC

*** Mode Line

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Mode Line")
#+END_SRC

I like to keep this pretty simple, certainly no powerline!.

#+BEGIN_SRC emacs-lisp
(setq display-time-string-forms
  '((propertize (concat " " 24-hours ":" minutes " "))))

(display-time-mode t)
(line-number-mode t)
(column-number-mode t)
#+END_SRC

For battery mode, simplify the usual and use icons, it makes it easier to
find.

#+BEGIN_SRC emacs-lisp
(require 'battery) ;; builtin

(when (functionp battery-status-function)
(cond ((string= "AC" (battery-format "%L" (funcall battery-status-function)))
     (setq battery-mode-line-format ""))
    ((string-match-p "N/A" (battery-format "%B" (battery-status-function)))
     (setq battery-mode-line-format ""))
    (t
     (setq battery-mode-line-format ":%p%%"))))

(display-battery-mode 1)
#+END_SRC

*** Notifications
:PROPERTIES:
:CUSTOM_ID: core-ui-notifications
:END:

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Notifications")
#+END_SRC

[[https://github.com/jwiegley/alert][Alert]] is a Growl-workalike for Emacs
which uses a common notification interface and multiple, selectable "styles",
whose use is fully customizable by the user.

#+BEGIN_SRC emacs-lisp
(use-package alert
             :custom
             (alert-fade-time 10)) ;; seconds
#+END_SRC

Set the alert style: /Native OSX notifier using AppleScript/.

#+BEGIN_SRC emacs-lisp
(if (system-mac-p)
    (setq alert-default-style 'osx-notifier)
  (setq alert-default-style 'notifications))
#+END_SRC

*** Icons

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Icons")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
             :if window-system
             :hook ((dired-mode . all-the-icons-dired-mode)
                    (ibuffer-mode . all-the-icons-ibuffer-mode))
             :config
             (all-the-icons-completion-mode))

(use-package all-the-icons-completion :if window-system)

(use-package all-the-icons-dired :if window-system)

(use-package all-the-icons-ibuffer :if window-system)
#+END_SRC

To ensure fonts are installed on your system, execute:
=/M-x all-the-icons-install-fonts<RET>/=

#+BEGIN_SRC emacs-lisp
(use-package mode-icons
             :if window-system
             :config
             (mode-icons-mode))

(use-package major-mode-icons
             :if window-system
             :config
             (major-mode-icons-mode 1))
#+END_SRC

*** Mouse

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Mouse")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'mouse) ;; builtin
(setq mouse-wheel-follow-mouse 't
      mouse-wheel-scroll-amount '(1 ((shift) . 1)))

(xterm-mouse-mode t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(global-set-key [mouse-4] (lambda ()
                            (interactive)
                            (scroll-down 1)))
(global-set-key [mouse-5] (lambda ()
                            (interactive)
                            (scroll-up 1)))
#+END_SRC

*** Windows

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Windows")
#+END_SRC

Using multiple side-by-side windows is a great way to utilize the
large high-resolution displays that exists today. This [[https://github.com/Lindydancer/multicolumn][package]]
provides the "missing features" of Emacs to create a side-by-side
layout, to navigate efficiently, and to manage the windows.

#+BEGIN_SRC emacs-lisp
(use-package multicolumn)
#+END_SRC

In OS X 10.9, each monitor is a separate space. If you want to stretch an
Emacs frame across multiple monitors, you can change this in "System
Preferences -> Mission Control -> Displays have separate Spaces".

*** Buffers

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Buffers")
#+END_SRC

[[https://www.emacswiki.org/emacs/RecentFiles][Recentf]] is a minor mode that builds a list of recently opened files. This list
is automatically saved across sessions on exiting Emacs - you can then access
this list through a command or the menu.

#+BEGIN_SRC emacs-lisp
(use-package recentf
             :bind ("C-x C-r" . recentf-open-files)
             :custom
             (setq recentf-max-menu-items 100)
             (recentf-max-saved-items 100)
             :config
             (recentf-mode))
#+END_SRC

[[https://www.emacswiki.org/emacs/IbufferMode][Ibuffer]] is an advanced replacement for BufferMenu, which lets you operate on
buffers much in the same manner as Dired. The most important Ibuffer features
are highlighting and various alternate layouts. Ibuffer is part of Emacs since
version 22.

#+BEGIN_SRC emacs-lisp
(use-package ibuffer)

(use-package ibuffer-sidebar
             :bind ("C-x C-b" . ibuffer-sidebar-toggle-sidebar))
#+END_SRC

This [[https://github.com/lukhas/buffer-move][package]] is for lazy people wanting to swap buffers without
typing =/C-x b/= on each window.

#+BEGIN_SRC emacs-lisp
(use-package buffer-move)

(when (fboundp 'windmove-default-keybindings)
  (windmove-default-keybindings))
#+END_SRC

This [[https://github.com/beacoder/everlasting-scratch][package]] provides a global minor mode =everlasting-scratch-mode=
that causes the scratch buffer to respawn after it's killed and with
its content restored.

#+BEGIN_SRC emacs-lisp
(use-package everlasting-scratch
             :hook (after-init))
#+END_SRC

Finally, set the default buffer mode.

#+BEGIN_SRC emacs-lisp
(setq-default major-mode 'text-mode)

(add-hook 'text-mode-hook 'auto-fill-mode)
#+END_SRC

*** Multiple Cursors

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Multiple Cursors")
#+END_SRC

[[https://github.com/magnars/multiple-cursors.el][Multiple cursors]] for Emacs.

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors)
#+END_SRC

When you have an active region that spans multiple lines, the following will add a cursor to each line:

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
#+END_SRC

When you want to add multiple cursors not based on continuous lines, but based on keywords in the buffer, use:

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c m c") 'mc/edit-lines)
(global-set-key (kbd "C-c m >") 'mc/mark-next-like-this)
(global-set-key (kbd "C-c m <") 'mc/mark-previous-like-this)
(global-set-key (kbd "C-c m *") 'mc/mark-more-like-this)
(global-set-key (kbd "C-c m !") 'mc/mark-all-like-this)
#+END_SRC

This package contains [[https://github.com/knu/mc-extras.el][extra functions]] for multiple-cursors mode.

#+BEGIN_SRC emacs-lisp
(use-package mc-extras)
#+END_SRC

*** Undo Tree

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Undo Tree")
#+END_SRC

How does anyone work without an [[https://gitlab.com/tsc25/undo-tree][Undo Tree]]!

#+BEGIN_SRC emacs-lisp
(use-package undo-tree :config (global-undo-tree-mode))
#+END_SRC

** Completion UI Settings

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Completion UI Settings"))
#+END_SRC

*** Company

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Company")
#+END_SRC

[[https://company-mode.github.io/][Company]] is a text completion framework for Emacs. The name stands for
"complete anything". It uses pluggable back-ends and front-ends to
retrieve and display completion candidate.

#+BEGIN_SRC emacs-lisp
(use-package company
             :hook (after-init . global-company-mode)
             :custom
             (company-files-exclusions '(".DS_Store"))
             (company-tooltip-align-annotations t))

(use-package company-emojify)

(use-package company-prescient)

(use-package company-quickhelp)
#+END_SRC

*** Ivy

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Ivy")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ivy
             :custom
             (ivy-use-virtual-buffers t)
             (enable-recursive-minibuffers t)
             (ivy-count-format "(%d/%d) ")
             :config
             (ivy-mode 1))

(use-package ivy-explorer
             :config (ivy-explorer-mode 1))

(use-package ivy-file-preview)

(use-package ivy-historian)

(use-package ivy-prescient)

(use-package ivy-rich)
#+END_SRC

*** Counsel

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Counsel")
#+END_SRC

[[https://github.com/abo-abo/swiper][Counsel]].

#+BEGIN_SRC emacs-lisp
(use-package counsel
             :custom
             (counsel-find-file-ignore-regexp "\\(?:\\`\\|[/\\]\\)\\(?:[#.]\\)")
             :config
             (counsel-mode 1))

(use-package counsel-fd)

(use-package counsel-osx-app)

(use-package counsel-tramp)

(use-package counsel-web)
#+END_SRC

*** Key Bindings

Ivy-based interface to standard commands

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-s") 'swiper-isearch)
(global-set-key (kbd "M-x") 'counsel-M-x)
(global-set-key (kbd "C-x C-f") 'counsel-find-file)
(global-set-key (kbd "M-y") 'counsel-yank-pop)
(global-set-key (kbd "<f1> f") 'counsel-describe-function)
(global-set-key (kbd "<f1> v") 'counsel-describe-variable)
(global-set-key (kbd "<f1> l") 'counsel-find-library)
(global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
(global-set-key (kbd "<f2> u") 'counsel-unicode-char)
(global-set-key (kbd "<f2> j") 'counsel-set-variable)
(global-set-key (kbd "C-x b") 'ivy-switch-buffer)
(global-set-key (kbd "C-c v") 'ivy-push-view)
(global-set-key (kbd "C-c V") 'ivy-pop-view)
#+END_SRC

Ivy-based interface to shell and system tools

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c c") 'counsel-compile)
(global-set-key (kbd "C-c g") 'counsel-git)
(global-set-key (kbd "C-c j") 'counsel-git-grep)
(global-set-key (kbd "C-c L") 'counsel-git-log)
(global-set-key (kbd "C-c k") 'counsel-rg)
(global-set-key (kbd "C-c m") 'counsel-linux-app)
(global-set-key (kbd "C-c n") 'counsel-fzf)
(global-set-key (kbd "C-x l") 'counsel-locate)
(global-set-key (kbd "C-c J") 'counsel-file-jump)
(global-set-key (kbd "C-S-o") 'counsel-rhythmbox)
(global-set-key (kbd "C-c w") 'counsel-wmctrl)
#+END_SRC

Ivy-resume (resumes the last Ivy-based completion) and other commands

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c C-r") 'ivy-resume)
(global-set-key (kbd "C-c b") 'counsel-bookmark)
(global-set-key (kbd "C-c d") 'counsel-descbinds)
(global-set-key (kbd "C-c g") 'counsel-git)
(global-set-key (kbd "C-c o") 'counsel-outline)
(global-set-key (kbd "C-c t") 'counsel-load-theme)
(global-set-key (kbd "C-c F") 'counsel-org-file)
#+END_SRC

** O/S Specific UI Settings

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "O/S Specific UI Settings"))
#+END_SRC

*** macOS System Integration

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "macOS System Integration")
#+END_SRC

- =osx-lib=: An Emacs package with functions and commands for interacting with
macOS.
- =osx-plist=: This is a simple parser for macOS plist files. The main entry
points are =osx-plist-parse-file= and =osx-plist-parse-buffer=.
- =osx-trash=: Make =delete-by-moving-to-trash= do what you expect it to do on macOS.
- =reveal-in-osx-finder=: Provides the function =reveal-in-osx-finder= for file
and dired buffers.

#+BEGIN_SRC emacs-lisp
(use-package osx-lib
             :if (system-mac-p))

(use-package osx-plist
             :if (system-mac-p))

(use-package osx-trash
             :if (system-mac-p)
             :config
             (osx-trash-setup))

(use-package reveal-in-osx-finder
             :if (system-mac-p))

#+END_SRC

*** macOS Keyboard Settings

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "macOS Keyboard Settings")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (system-mac-p)
  (setq mac-command-modifier 'super
        mac-control-modifier 'control
        mac-option-modifier 'meta
        mac-right-command-modifier 'super
        mac-right-option-modifier 'meta
        ns-alternate-modifier mac-option-modifier
        ns-command-modifier mac-command-modifier
        ns-function-modifier 'hyper
        ns-right-command-modifier mac-right-command-modifier))
#+END_SRC

** Initial Flycheck Settings

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Initial Flycheck Settings"))
#+END_SRC

[[https://www.flycheck.org/en/latest/][Flycheck]].

#+BEGIN_SRC emacs-lisp
(use-package flycheck
             :hook ('after-init . global-flycheck-mode))
#+END_SRC

** Shell & Terminal Settings

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Shell & Terminal Settings"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *")

(add-to-list 'auto-mode-alist '("\\.zsh\\'" . sh-mode))

(add-hook 'sh-mode-hook
          (lambda ()
            (if (string-match "\\.zsh$" buffer-file-name)
                (sh-set-shell "zsh"))))
#+END_SRC

Emacs-libvterm (=/vterm/=) is fully-fledged terminal emulator inside GNU Emacs
based on libvterm, a C library. As a result of using compiled code (instead of
elisp), emacs-libvterm is fully capable, fast, and it can seamlessly handle
large outputs.

#+BEGIN_SRC emacs-lisp
(use-package vterm
             :custom
             (vterm-shell "zsh")
             (vterm-max-scrollback 10000))
#+END_SRC

** Gnus

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Gnus"))
#+END_SRC

Basic [[https://www.gnu.org/software/emacs/manual/html_node/gnus/][Gnus Newsreader]] configuration. Enter Gnus with =/M-x gnus/=.

#+BEGIN_SRC emacs-lisp
(require 'gnus) ;; builtin

(setq gnus-select-method '(nntp "news.gnus.org"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package nnhackernews
             :config
             (add-to-list 'gnus-secondary-select-methods '(nnhackernews "")))
#+END_SRC

Enter the =nnhackernews:news= newsgroup with =/RET/=.

And of course, more icons!

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-gnus
             :if window-system
             :config (all-the-icons-gnus-setup))
#+END_SRC

** Remote (TRAMP) Editing

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Remote (TRAMP) Editing"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'tramp) ;; builtin

(setq tramp-default-method "ssh")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package counsel-tramp)

(use-package docker-tramp)
#+END_SRC

** Version Control

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Version Control"))
#+END_SRC

*** Core Git

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Core Git")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package git-attr)

(use-package git-blamed)

(use-package git-link)

(use-package git-timemachine)

(use-package git-modes)
#+END_SRC

*** Git and iBuffer

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Git and iBuffer")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ibuffer-git)
#+END_SRC

*** Git Issues

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Git Issues")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package git-commit-insert-issue
             :hook (git-commit-mode))
#+END_SRC

*** Magit

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Magit")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package magit
             :custom
             (magit-completing-read-function 'ivy-completing-read))

(use-package magit-diff-flycheck)

(use-package magit-lfs)

(use-package magit-filenotify)
#+END_SRC

This package displays keyword entries from source code comments and Org files
in the Magit status buffer.  Activating an item jumps to it in its file.  By
default, it uses keywords from `hl-todo', minus a few (like "NOTE").

#+BEGIN_SRC emacs-lisp
(use-package magit-todos
             :config
             (magit-todos-mode))
#+END_SRC

*** Diff Highlighting

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Diff Highlighting")
#+END_SRC

`diff-hl-mode' highlights uncommitted changes on the side of the
window (using the /fringe/, by default), allows you to jump between
the hunks and revert them selectively.

#+BEGIN_SRC emacs-lisp
(use-package diff-hl
             :hook ((magit-pre-refresh . diff-hl-magit-pre-refresh)
                    (magit-post-refresh . diff-hl-magit-post-refresh))
             :config
             (global-diff-hl-mode))
#+END_SRC

*** Github Integration

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Github Integration")
#+END_SRC

Example =/M-x github-explorer/= "txgvnn/github-explorer"

#+BEGIN_SRC emacs-lisp
(use-package github-browse-file)

(use-package github-explorer)

(use-package github-pullrequest)

(use-package github-review)
#+END_SRC

*** Github Bug References

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Github Bug References")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package bug-reference-github
             :hook (prog-mode . bug-reference-github-set-url-format))
#+END_SRC

*** Github Notifications

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Github Notifications")
#+END_SRC

This gets to be a pain if it is disconnected. Consider trying =gh-notify=.

#+BEGIN_SRC emacs-lisp
;; (use-package skj-secrets :hook (prog-mode))
;; 
;; (use-package github-notifier
;;              :custom
;;              (github-notifier-token (skj/secrets-value 'github-token)))
#+END_SRC

*** iBuffer Integration

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "iBuffer Integration")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ibuffer-vc
             :config
             (add-hook 'ibuffer-hook
                       (lambda ()
                         (ibuffer-vc-set-filter-groups-by-vc-root)
                         (unless (eq ibuffer-sorting-mode 'alphabetic)
                           (ibuffer-do-sort-by-alphabetic)))))
#+END_SRC

*** Code Reviews

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Code Reviews")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package code-review)
#+END_SRC


* Snippet Support

#+BEGIN_SRC emacs-lisp :exports none
(setq l1-msg (progress "Snippet Support"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defcustom
skj/snippet-repo-dir
(concat-path skj/project-root-dir "emacs-snippets")
"Snippet repository local path."
:tag "Snippet repository local path"
:group 'skj
:type 'directory)
#+END_SRC

** Core Snippet Support

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Core Snippet Support"))
#+END_SRC

First of all, the primary snippet tool is =yasnippet=.

#+BEGIN_SRC emacs-lisp
(use-package
 yasnippet
 :hook
 (prog-mode . yas-minor-mode)
 :config
 (dolist (path (list
                (concat-path user-emacs-directory "snippets")
                skj/snippet-repo-dir))
   (unless (member path yas-snippet-dirs)
     (setq yas-snippet-dirs
           (cons path yas-snippet-dirs))))
 (yas-global-mode 1))
#+END_SRC

Remember to execute =/M-x yas-reload-all/= when any snippets change.

** Snippet Collections

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Snippet Collections"))
#+END_SRC

Basic snippets, pretty useful.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet-snippets)
#+END_SRC

These are super useful, create a new =.gitignore= file and type =emacs<RET>=
followed by language such as =rust<RET>= and maybe =macos<RET>= for good measure.

#+BEGIN_SRC emacs-lisp
(use-package
 gitignore-snippets
 :config
 (gitignore-snippets-init))
#+END_SRC

These are common license files, easy to add to a new project.

#+BEGIN_SRC emacs-lisp
(use-package license-snippets)
#+END_SRC

** Snippet Completion

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Snippet Completion"))
#+END_SRC

This is all, for now.

#+BEGIN_SRC emacs-lisp
(use-package ivy-yasnippet)
#+END_SRC


* Org-Mode

#+BEGIN_SRC emacs-lisp :exports none
(setq l1-msg (progress "Org-Mode"))
#+END_SRC

The almighty [[https://orgmode.org/][Emacs Org Mode]]!

#+BEGIN_SRC emacs-lisp
(let ((org-dir (concat-path skj/project-root-dir "emacs-org")))
(if (boundp 'org-directory)
  (setq org-directory org-dir)
(defvar org-directory org-dir)))
#+END_SRC

The following are worth reading for more details and future ideas:

- http://doc.norang.ca/org-mode.html
- https://github.com/zzamboni/dot-emacs/blob/master/init.org
- https://orgmode.org/worg/org-tutorials/encrypting-files.html
- https://github.com/daviwil/emacs-from-scratch/blob/master/show-notes/Emacs-06.org
(Agendas and Templates)
- https://orgmode.org/manual/Custom-Agenda-Views.html#Custom-Agenda-Views

** Initial Configuration

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Initial Configuration"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'org)

(setq org-confirm-babel-evaluate nil
      org-cycle-separator-lines 2
      org-default-notes-file (concat-path org-directory "inbox.org")
      org-edit-src-content-indentation 2
      org-ellipsis " ▾"
      org-enforce-todo-dependencies t
      org-fontify-quote-and-verse-blocks t
      org-hide-emphasis-markers t
      org-image-actual-width '(550)
      org-log-done 'time
      org-log-into-drawer t
      org-src-fontify-natively t
      org-src-preserve-indentation t
      org-src-tab-acts-natively t
      org-startup-folded 'content
      org-startup-indented t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))
#+END_SRC

*** Org Query Language (ql)

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Org Query Language")
#+END_SRC

A powerful [[https://github.com/alphapapa/org-ql][query language] for org
files.

#+BEGIN_SRC emacs-lisp
(use-package org-ql)
#+END_SRC

*** Priorities

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Priorities")
#+END_SRC

I like using the letters for display, it's a shame that the different Org
interfaces use integers, chars, /and/ strings.

#+BEGIN_SRC emacs-lisp
(setq org-priority-highest ?A
      org-priority-lowest ?E
      org-priority-default ?C)

(setq org-highest-priority ?A
      org-lowest-priority ?E
      org-default-priority ?C)
#+END_SRC

Use fancy icons for different priority levels.

#+BEGIN_SRC emacs-lisp
(use-package
 org-fancy-priorities
 :hook
 (org-agenda)
 :config
 (setq org-fancy-priorities-list
      '((?A . "⚡") (?B . "⬆") (?C . " ") (?D . "⬇") (?E . "☕"))
      org-priority-faces
      '((?A :foreground "red" :weight bold)
        (?B :foreground "orange" :weight semi-bold)
        (?C :foreground "green" :weight normal)
        (?B :foreground "blue" :weight semi-light)
        (?C :foreground "grey" :weight light))))
#+END_SRC

*** Tags

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Tags")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq org-tag-alist
        '((:startgroup)
          ("@home" . ?H) ("@travel" . ?V) ("@work" . ?W) ("@doctor" . ?D)
          (:endgroup)
        
          (:startgrouptag)
          ("generic")
          (:grouptags)
          ("idea" . ?i) ("call" . ?c) ("errand" . ?e) ("remind" . ?r)
          (:endgrouptag)
        
          (:startgrouptag)
          ("home")
          (:grouptags)
          ("fix") ("clean") ("garage") ("yard") ("family") ("friends")
          ("finance") ("estate") ("pets")
          (:endgrouptag)
        
          (:startgrouptag)
          ("home-fun")
          (:grouptags)
          ("diving" . ?d) ("hacking" . ?h) ("music" . ?m) ("synth" . ?s)
          (:endgrouptag)
        
          (:startgrouptag)
          ("work")
          (:grouptags)
          ("coding" . ?o) ("meeting" . ?m) ("planning" . ?p) ("writing" . ?w)
          ("business" . ?B) ("technical" . ?T) ("hr" . ?H)
          ("l6" . ?6) ("l7" . ?7) ("l8" . ?8) ("l10" . ?0) ("l11" . ?1)
          (:endgrouptag)))
#+END_SRC

Currently this fails!

#+BEGIN_SRC emacs-lisp
;; (use-package org-tag-beautify :config (org-tag-beautify-mode 1))
#+END_SRC

#+BEGIN_EXAMPLE
all-the-icons-fileicon: Unable to find icon with name ‘svelte’ in icon set
‘fileicon’
#+END_EXAMPLE

*** Task Types (Keywords)

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Task Types (Keywords)")
#+END_SRC

Specify (<char>Before/After) where either Before/After may be @ for
record time AND comment, ! for just time

#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
        '(;; Simple reminders
          (sequence "NUDGE(g)" "|" "DONE(d!)")
          ;; General to-do items
          (sequence "TODO(t)" "NEXT(n!)" "INPROGRESS(p!)" "WAIT(w@/!)" "|" "DONE(d!)" "CANCELED(c@)")
          ;; Work-like task items
          (sequence "BACKLOG(b)" "PLAN(p!)" "READY(r!)" "ACTIVE(a@/!)" "REVIEW(v)" "WAIT(w@/!)" "HOLD(h)" "|" "DONE(d!)" "CANCELED(c@)")
          ;; Appointment and Meeting tracking
          (sequence "SCHEDULE(s/!)" "REQUESTED(r)" "BOOKED(b@/!)" "DEFERRED(f@/!)" "RESCHEDULE(e@/!)" "|" "DONE(d!)" "CANCELED(c@)")))

  (setq-default org-enforce-todo-dependencies t)
#+END_SRC

Edna provides an extensible means of specifying conditions which must be fulfilled before a task can be completed and actions to take once it is.

Org Edna runs when either the BLOCKER or TRIGGER properties are set on a heading, and when it is changing from a TODO state to a DONE state.

#+BEGIN_SRC emacs-lisp
(use-package org-edna
  :config
               (org-edna-mode))
#+END_SRC

*** Capture Templates

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Capture Templates")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
      '(("t" "Todo" entry (file+headline org-default-notes-file "Inbox")
         "* TODO %?\n%u\n%a\n" :clock-in t :clock-resume t)
        ("m" "Meeting" entry (file+headline org-default-notes-file "Inbox")
         "* MEETING with %? :MEETING:\n%t" :clock-in t :clock-resume t)
        ("i" "Idea" entry (file+headline org-default-notes-file "Inbox")
         "* %? :IDEA: \n%t" :clock-in t :clock-resume t)
        ("n" "Next Task" entry (file+headline org-default-notes-file "Inbox")
         "** NEXT %? \nDEADLINE: %t")
        ("d" "Distraction" entry (file+headline
                                  (concat org-directory "/distractions.org")
                                  "Distractions")
         "* %?\n%T")))
#+END_SRC

*** Faces

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Faces")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-todo-keyword-faces
      '(("NEXT" . (:foreground "green" :weight bold))
        ("PLAN" . (:foreground "green" :weight bold))
        ("INPROGRESS" . (:foreground "blue" :weight bold))
        ("ACTIVE" . (:foreground "blue" :weight bold))))

(add-hook 'org-mode-hook #'turn-on-font-lock)
#+END_SRC

*** Project File Integration

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Project File Integration")
#+END_SRC

Adds all TODO items from a =todo.org= file in the magit project's root
to the magit status buffer.

#+BEGIN_SRC emacs-lisp
(use-package magit-org-todos
             :config
             (magit-org-todos-autoinsert))
#+END_SRC

** Core UI Additions

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Core UI Additions"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-beautify-theme :if window-system)

(use-package org-modern)

(use-package org-sidebar)

(use-package org-superstar)
#+END_SRC

Use /=C-c C-s=/ to use a relative time for schedule.

#+BEGIN_SRC emacs-lisp :exports none
;; (use-package orgbox)
#+END_SRC

*** Notifications

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Notifications")
#+END_SRC

Provides notifications for scheduled or deadlined agenda entries. This uses
the =alert= package configured in [[#core-ui-notifications]] above.

#+BEGIN_SRC emacs-lisp
(use-package org-alert
             :config
             (setq org-alert-interval 300
                   org-alert-notify-cutoff 10
                   org-alert-notify-after-event-cutoff 10
                   org-alert-notification-title "Org Agenda"))
#+END_SRC

*** Prettier Bullets

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Prettier Bullets")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
             :config
             (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC

** Agenda

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Agenda"))
#+END_SRC

Set basic things for Agenda management.

#+BEGIN_SRC emacs-lisp
(require 'org-agenda) ;; builtin

(setq org-agenda-files
      (list (concat org-directory "/inbox.org")
            (concat org-directory "/notes.org")
            (concat org-directory "/gcal.org")
            (concat org-directory "/birthdays.org")
            (concat org-directory "/holidays.org"))
      org-agenda-hide-tags-regexp "."
      org-agenda-log-mode-items '(closed clock state))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-agenda-property)

(use-package org-super-agenda)
#+END_SRC

*** Custom Views

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Custom Views")
#+END_SRC

This is useful for filtering by priority, when not using tag queries.

#+BEGIN_SRC emacs-lisp
(defun skj/org-skip-subtree-if-priority (priority)
  "Skip an agenda subtree if it has a priority of PRIORITY.
  
  PRIORITY must be string between =\"A\"= and =\"E\"=."
  (let ((subtree-end (save-excursion (org-end-of-subtree t)))
        (pri-current (org-element-property :priority (org-element-at-point))))
    (if (equal priority pri-current)
        subtree-end
      nil)))
#+END_SRC

Set up some useful Agenda views.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-custom-commands
      '(("m"
         "ALL Meetings"
         ((tags
           "CATEGORY=\"Meetings\""
           ((org-agenda-overriding-header "Meetings:")
            (org-tags-match-list-sublevels t)))))
        ("d"
         "Daily agenda review"
         ((tags
           "PRIORITY=\"A\"-TODO=\"DONE\""
           ((org-agenda-overriding-header "High-priority unfinished tasks:")
            (org-agenda-sorting-strategy '(todo-state-down effort-up))))
          (agenda "")
          (alltodo
           ""
           ((org-agenda-skip-function
             '(or (skj/org-skip-subtree-if-priority ?A)
                  (org-agenda-skip-if nil '(scheduled deadline))))
            (org-agenda-sorting-strategy '(priority-down todo-state-down effort-up)))))
         nil
         ("~/daily-agenda.html"))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-columns-default-format-for-agenda
      (string-join '("%45ITEM(Task)"
                     "%10TODO(State)"
                     "%1PRIORITY(!)"
                     "%1BLOCKED()"
                     "%30ALLTAGS(All Tags)"
                     "%23SCHEDULED(Scheduled to Start)"
                     "%22DEADLINE(Deadline)"
                     "%10EFFORT(Effort){:}"
                     "%10CLOCKSUM(Actual){:}"
                     "%10CLOCKSUM(Actual/T){:}")
                   " "))
#+END_SRC

*** Run on Idle

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Run on Idle")
#+END_SRC

Basically, if you don't touch Emacs =idle-org-agenda= will display your
org-agenda after certain time. That can be useful to remember tasks after come
back to work.

#+BEGIN_SRC emacs-lisp
(use-package idle-org-agenda
             :config
             (idle-org-agenda-mode))
#+END_SRC

*** Clock Tracking

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Clock Tracking")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'org-clock) ;; builtin

(setq org-clock-persist 'history
      org-remember-clock-out-on-exit t)
#+END_SRC

Active notifications are shown every 3 minute, inactive every 3

#+BEGIN_SRC emacs-lisp
(use-package org-clock-reminder
             :config
             (org-clock-reminder-mode)
             (setq org-clock-reminder-interval (cons 3 10)))
#+END_SRC

*** Habit Tracking

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Habit Tracking")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-habit-stats
             :config
             (add-to-list 'org-modules 'org-habit t)
             (setq org-habit-following-days 7
                   org-habit-graph-column 60
                   org-habit-preceding-days 28
                   org-habit-show-all-today t
                   org-habit-show-done-always-green t
                   org-habit-show-habits-only-for-today t))
#+END_SRC

*** Standard Calendars

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Standard Calendars")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(customize-set-variable 'holiday-bahai-holidays nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package mexican-holidays
             :config
             (setq calendar-holidays
                   (append calendar-holidays holiday-mexican-holidays)))
#+END_SRC

*** Google Calendar

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Google Calendar")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package skj-secrets
             :config
             (setq org-gcal-client-id (skj/secrets-value 'gcal-id)
                   org-gcal-client-secret (skj/secrets-value 'gcal-secret)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defcustom skj/org-gcal-file
  (concat org-directory "/gcal.org")
  "Location of `org-mode' file to sync with Google Calendar."
  :tag "Org file for Google Calendar"
  :group 'skj
  :type 'file)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-gcal
             :config
             (setq org-gcal-fetch-file-alist
	               (list (cons skj/primary-email skj/org-gcal-file))
                   org-gcal-local-timezone calendar-time-zone-name))
#+END_SRC

Execute /=M-x org-gcal-fetch=/ to fetch new calendar updates

Execute /=M-x org-gcal-post-at-point=/ to turn a TODO into a calendar entry

*** Appointment Integration

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Appointment Integration")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'appt) ;; builtin

(setq appt-audible t
	  appt-display-duration 30
	  appt-display-format 'window
	  appt-display-mode-line t)
#+END_SRC

Activate appointments so we get notifications.

#+BEGIN_SRC emacs-lisp
(appt-activate t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun skj/org-agenda-to-appt ()
  "Erase all reminders and rebuilt reminders for today from the agenda."
  (interactive)
  (setq appt-time-msg-list nil)
  (org-agenda-to-appt))
#+END_SRC

Rebuild the reminders every time the agenda is displayed
 
#+BEGIN_SRC emacs-lisp
(add-hook 'org-agenda-finalize-hook 'skj/org-agenda-to-appt 'append)
#+END_SRC

If we leave Emacs running overnight - reset the appointments one minute after midnight

#+BEGIN_SRC emacs-lisp
(run-at-time "24:01" nil 'skj/org-agenda-to-appt)
#+END_SRC

Run now so appointments are set up when Emacs starts
 
#+BEGIN_SRC emacs-lisp
(skj/org-agenda-to-appt)
#+END_SRC

** Babel

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Babel"))
#+END_SRC

Always redisplay images after =C-c C-c=

#+BEGIN_SRC emacs-lisp
(use-package ob-latex-as-png
             :hook (org-babel-after-execute org-redisplay-inline-images))
#+END_SRC

*** GraphViz

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "GraphViz")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package graphviz-dot-mode
             :hook (org-babel-after-execute . org-display-inline-images)
             :config
             (unless (version<= emacs-version "26")
               (setq graphviz-dot-indent-width tab-width))
             (org-babel-do-load-languages
              'org-babel-load-languages
              '((dot . t))))
#+END_SRC

*** PlantUML

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "PlantUML")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package plantuml-mode
             :config
             (setq plantuml-default-exec-mode 'executable)           
             (org-babel-do-load-languages
              'org-babel-load-languages
              '((plantuml . t))))

(use-package flycheck-plantuml
             :config
             (flycheck-plantuml-setup))
#+END_SRC

I am assuming that Homebrew has installed the PlantUML jar; however, you can
also download the latest version of PlantUML straight into plantuml-jar-path:
=/M-x plantuml-download-jar<RET>/=

** Other Stuff

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Other Stuff"))
#+END_SRC

*** References

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "References")
#+END_SRC

This adds [[https://github.com/jkitchin/org-ref][org-ref]] for citations and references, along with the very nice
[[https://github.com/alezost/org-ref-prettify.el][org-ref-prettify]].

#+BEGIN_SRC emacs-lisp
(use-package org-ref)

(use-package org-ref-prettify
             :hook (org-mode . org-ref-prettify))
#+END_SRC

*** Exporting

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Exporting")
#+END_SRC

Add Org exporter backends for Markdown and [[https://github.com/larstvei/ox-gfm][Github-Flavored Markdown]].

#+BEGIN_SRC emacs-lisp
(use-package ox-md)
(use-package ox-gfm )
#+END_SRC

*** Refile and Archive

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Refile and Archive")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-refile-targets
      (quote ((nil :maxlevel . 9)
              (org-agenda-files :maxlevel . 9)
              ("archive.org" :maxlevel . 1))))
#+END_SRC

Save Org buffers after refiling.

#+BEGIN_SRC emacs-lisp
(advice-add 'org-refile :after 'org-save-all-org-buffers)
#+END_SRC

*** Completion Integration

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Completion Integration")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package company-org-block
             :config
             (setq company-org-block-edit-style 'auto) ;; 'auto, 'prompt, or 'inline
             (add-hook 'org-mode-hook
                       (lambda ()
                         (add-to-list (make-local-variable 'company-backends)
                                      'company-org-block))))

(use-package org-ivy-search
             :bind ("C-c o" . org-ivy-search-view))

(use-package ivy-todo
             :bind ("C-c t" . ivy-todo)
             :commands ivy-todo
             :config
             (setq ivy-todo-default-tags '("PROJECT")))
#+END_SRC

** Key Bindings

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Key Bindings"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c l") #'org-store-link)
(global-set-key (kbd "C-c a") #'org-agenda)
(global-set-key (kbd "C-c c") #'org-capture)

(global-set-key (kbd "<f5>") 'org-agenda)
(global-set-key (kbd "C-<f5>") 'org-store-agenda-views)

(global-set-key (kbd "<f6> i") 'org-clock-in)
(global-set-key (kbd "<f6> o") 'org-clock-out)
(global-set-key (kbd "<f6> g") 'org-clock-goto)
(global-set-key (kbd "<f6> <f6>") 'org-clock-menu)
#+END_SRC


* Other Writing Modes

#+BEGIN_SRC emacs-lisp :exports none
(setq l1-msg "Other Writing Modes")
#+END_SRC

** Focus Mode

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Focus Mode"))
#+END_SRC

For distraction-free editing, use the command /=M-x focus-mode=/ which will dim
all but the block of text/code you are currently within.

#+BEGIN_SRC emacs-lisp
(use-package focus)
#+END_SRC

** Emoji Support

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Emoji Support"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package company-emoji)

(when (display-graphic-p)
  (add-to-list 'company-backends 'company-emoji)
  
  (defun --set-emoji-font (frame)
    "Adjust the font settings of FRAME so Emacs can display emoji properly."
    (if (system-mac-p)
        ;; For NS/Cocoa
        (set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji") frame 'prepend)
      ;; For Linux
      (set-fontset-font t 'symbol (font-spec :family "Symbola") frame 'prepend)))
  
  ;; For when Emacs is started in GUI mode:
  (--set-emoji-font nil)
  ;; Hook for when a frame is created with emacsclient
  ;; see https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Frames.html
  (add-hook 'after-make-frame-functions '--set-emoji-font))
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Markdown"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode)

(use-package polymode)

(use-package poly-markdown :after (polymode markdown))

(use-package markdown-soma)

(autoload 'markdown-mode "markdown-mode"
  "Major mode for editing Markdown files" t)
(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))

(autoload 'gfm-mode "markdown-mode"
  "Major mode for editing GitHub Flavored Markdown files" t)
(add-to-list 'auto-mode-alist '("README\\.md\\'" . gfm-mode))
#+END_SRC

** Blogging

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Blogging"))
#+END_SRC

Editing jekyll files, using =polymode= for the mix of YAML and Markdown.

#+BEGIN_SRC emacs-lisp
(use-package jekyll-modes :after (poly-markdown))

;;(require 'jekyll-markdown-mode)
;;(add-to-list 'auto-mode-alist '("\\.md$" . jekyll-markdown-mode))
#+END_SRC

Emacs major mode for managing [[https://jekyllrb.com/][jekyll]] blogs ([[https://github.com/masasam/emacs-easy-jekyll][repo]]).

#+BEGIN_SRC emacs-lisp
(use-package easy-jekyll)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; thanks to https://cute-jumper.github.io/emacs/2013/10/06/orgmode-to-github-pages-with-jekyll
(defun org-jekyll-post-link-follow (path)
  (org-open-file-with-emacs path))

(defun org-jekyll-post-link-export (path desc format)
  (cond
   ((eq format 'html)
    (format "<a href=\"{%% post_url %s %%}\">%s</a>" (file-name-sans-extension path) desc))))

(org-add-link-type "jekyll-post" 'org-jekyll-post-link-follow 'org-jekyll-post-link-export)
#+END_SRC

** LaTeX

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "LaTeX"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package tex
  :ensure auctex)

(use-package auctex-latexmk)

(use-package latex-pretty-symbols)

(use-package latex-extra
  :after auctex
  :hook (LaTeX-mode . latex-extra-mode))

(use-package biblio)

(use-package bibretrieve)

(use-package bibtex-utils)

(setq latex-run-command "xelatex"
      TeX-auto-save t
      TeX-parse-self t)
#+END_SRC

Back-ends for =company-mode= providing auto-completion for [[https://www.gnu.org/software/auctex/][AUCTeX]].

#+BEGIN_SRC emacs-lisp
(use-package company-auctex
             :config
             (company-auctex-init))
#+END_SRC

Use /=M-x latex-math-preview-expression=/

#+BEGIN_SRC emacs-lisp
(use-package latex-math-preview)

(use-package latex-preview-pane
             :config
             (latex-preview-pane-enable))
#+END_SRC

** Spell and Style Checking

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Spell and Style Checking"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package auto-dictionary
             :config
             (add-hook 'flyspell-mode-hook (lambda () (auto-dictionary-mode 1))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package flyspell-correct-ivy
             :hook ((text-mode . flyspell-mode)
                    (prog-mode . flyspell-prog-mode))
             :custom
             (flyspell-issue-message-flag nil)
	         (ispell-program-name "aspell"))

(let* ((env-language (getenv "LANG"))
	   (dictionary (first (split-string env-language "\\."))))
  (setq ispell-extra-args (list (concat "--lang=" dictionary))))
#+END_SRC

To check writing style, execute: =/M-x smog-check-buffer<RET>/=.

#+BEGIN_SRC emacs-lisp
(use-package smog
             :custom
             (smog-command "style -L en"))
#+END_SRC

** LaTeX Completion

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "LaTeX Completion"))
#+END_SRC

This is a group of backends for =company-mode= providing auto-completion for
AUCTeX.

#+BEGIN_SRC emacs-lisp
(use-package company-auctex
             :config
             (company-auctex-init))
#+END_SRC

This add-on defines three =company-mode= backends.

#+BEGIN_SRC emacs-lisp
(use-package company-math
             :custom
             (company-tooltip-align-annotations t)
             :config
             ;; global activation of the unicode symbol completion
             (add-to-list 'company-backends 'company-math-symbols-unicode))
#+END_SRC

** Bibliography Completion

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Bibliography"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package company-bibtex
             :config
             (add-to-list 'company-backends 'company-bibtex))

(use-package ivy-bibtex)
#+END_SRC


* Developer Configuration

#+BEGIN_SRC emacs-lisp :exports none
(setq l1-msg (progress "Developer Configuration"))
#+END_SRC

** UI Settings

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "UI Settings"))
#+END_SRC

*** Prettify Things

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Prettify Things")
#+END_SRC

Emacs 24.4 comes with a builtin =prettify-symbols-mode=. It can be customized by
changing =prettify-symbols-alist=.

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook #'prettify-symbols-mode)
#+END_SRC

The packages =prettify-math= and =prettify-greek= extend the configuration above.
The math package requires we set the delimiters before the module loaded.

#+BEGIN_SRC emacs-lisp
(use-package prettify-math
             :config (setq prettify-math-delimiters-alist
                           '(("$" tex)
                             ("$$" tex block)
                             (("\\(" . "\\)") tex block)
                             ("`" asciimath)
                             ("``" asciimath block))))
(use-package prettify-greek
             :config (setq prettify-symbols-alist
                           (append prettify-symbols-alist prettify-greek-lower)))
#+END_SRC

=fira-code-mode= is a simple minor mode for [[https://github.com/tonsky/FiraCode][Fira Code]] ligatures. You can
pre-install the fonts with the command =/M-x fira-code-mode-install-fonts<RET>/=.

#+BEGIN_SRC emacs-lisp
(use-package fira-code-mode
    :if window-system
               :hook (prog-mode . fire-code)
               :config
               (fira-code-mode-set-font))
#+END_SRC

*** Delimiters/Parenthesis

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Delimiters/Parenthesis")
#+END_SRC

Add [[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] for easy parenthesis matching, and [[https://github.com/Fuco1/smartparens][smartparens]] to
manage pairs.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
             :hook (emacs-lisp . smartparens-strict))

(use-package rainbow-delimiters
             :hook (prog-mode . 'rainbow-delimiters))
#+END_SRC

*** Indentation

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Indentation")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
             :hook (emacs-lisp-mode css-mode))

(use-package highlight-indent-guides
             :hook (prog-mode)
             :config
             (setq highlight-indent-guides-method 'character
                   highlight-indent-guides-responsive 'stack)
             (set-face-foreground 'highlight-indent-guides-character-face "brightmagenta"))
#+END_SRC

*** Completion

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Completion")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package company
             :config
             (setq company-files-exclusions '(".git/" ".DS_Store")
                   company-tooltip-align-annotations t)
             (add-hook 'web-mode-hook
                       (lambda ()
                         (set (make-local-variable 'company-backends) '(company-web-html))
                         (company-mode t))))
#+END_SRC

*** Odds & Ends

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Odds & Ends")
#+END_SRC

[[https://github.com/tarsius/hl-todo][Highlight TODO]]-like tags in buffers.

#+BEGIN_SRC emacs-lisp
(use-package hl-todo)
#+END_SRC

Turns on /sub-word/ [[https://www.gnu.org/software/emacs/manual/html_node/ccmode/Subword-Movement.html][movement and editing]].

#+BEGIN_SRC emacs-lisp
(use-package subword)
#+END_SRC

A very simple but effective thing, eldoc-mode is a MinorMode which [[https://www.emacswiki.org/emacs/ElDoc][shows you]],
in the echo area, the argument list of the function call you are currently
writing.

#+BEGIN_SRC emacs-lisp
(use-package eldoc
             :hook (prog-mode . turn-on-eldoc))
#+END_SRC

** Project Support

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Project Support"))
#+END_SRC

*** Projectile

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Projectile")
#+END_SRC

Projectile is a project interaction library for Emacs. Its goal is to provide
a nice set of features operating on a project level without introducing
external dependencies (when feasible).

=projectile-git-autofetch= is a minor mode for Emacs to automatically fetch
repositories you are currently working on (by default, all open repositories
known to projectile).

=project-explorer= provides a tree-based project explorer sidebar.

#+BEGIN_SRC emacs-lisp
(use-package projectile
             :custom
             (projectile-completion-system 'ivy)
             (projectile-require-project-root t)
             (projectile-project-search-path
              (mapcar (lambda (p)
                        (concat (file-name-as-directory skj/project-root-dir) p))
                      '("emacs-little-packages" "racket" "rust" "Amazon"))))

(use-package projectile-git-autofetch
             :config (projectile-git-autofetch-mode 1))

(use-package projectile-ripgrep)

(use-package counsel-projectile)

(use-package flycheck-projectile)
#+END_SRC

Recommended keymap prefix on macOS

#+BEGIN_SRC emacs-lisp
(when (system-mac-p)
  (define-key projectile-mode-map (kbd "s-p") 'projectile-command-map))
#+END_SRC

Turn stuff on.

#+BEGIN_SRC emacs-lisp
(counsel-projectile-mode 1)

(projectile-mode +1)
#+END_SRC

*** iBuffer Integration

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "iBuffer Integration")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ibuffer-projectile
             :config (add-hook 'ibuffer-hook
                               (lambda ()
                                 (ibuffer-projectile-set-filter-groups)
                                 (unless (eq ibuffer-sorting-mode 'alphabetic)
                                   (ibuffer-do-sort-by-alphabetic)))))
#+END_SRC

*** Project Explorer

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Project Explorer")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package project-explorer
             :bind ("<f8>" . project-explorer-toggle)
             :custom
             (pe/filenotify-enabled t)
             (pe/inline-folders t)
             (pe/omit-gitignore t)
             (pe/side 'left)
             (pe/width 40))
#+END_SRC

*** Find Files

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Find Files")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package find-file-in-project
             :config (ivy-mode 1))
#+END_SRC

** Language Server (Generic)

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Language Server (Generic)"))
#+END_SRC

- Documentation: https://emacs-lsp.github.io/lsp-mode/
- Supported language servers: https://emacs-lsp.github.io/lsp-mode/page/languages/

#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
             :commands lsp
             :custom
             (lsp-eldoc-render-all t)
             (lsp-idle-delay 0.6))
#+END_SRC

This package contains all the higher level UI modules of =lsp-mode=, like
flycheck support and code lenses.
 
#+BEGIN_SRC emacs-lisp
(use-package lsp-ui
             :hook (lsp-mode)
             :custom
             (lsp-ui-doc-enable nil)
             (lsp-ui-doc-position 'bottom)
             (lsp-ui-peek-always-show t)
             (lsp-ui-sideline-enable nil)
             (lsp-ui-sideline-show-hover t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;;;###autoload
(defun skj/imenu-toggle-maybe-lsp ()
  "Toggle an imenu list popup; it will use lsp-ui if it is enabled."
  (interactive)
  (if (bound-and-true-p lsp-mode)
	  (lsp-ui-imenu)
    (imenu-list-smart-toggle)))
#+END_SRC

This package provides an interactive =ivy= interface to the workspace symbol
functionality offered by =lsp-mode=.

#+BEGIN_SRC emacs-lisp :exports none
(use-package lsp-ivy)
#+END_SRC

*Key Bindings/Commands*

- =completion-at-point= for completions
- Signatures when writing methods (=/C-n/=, ==/C-p/== to cycle signatures)
- =lsp-find-definition=: =/C-c l g r/=
- =lsp-find-references=: =/C-c l g g/=
- =lsp-rename=: =/C-c l r r/=
- =lsp-format-buffer=: =/C-c l = ==/=
- =lsp-ui-peek-find-references= to show references inline (=/M-n/=, =/M-p/= to cycle)

** Test and Debug

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Test and Debug"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package dap-mode)
#+END_SRC

*** DAP Settings

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "DAP Settings")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package dap-mode
             :custom
             (dap-auto-configure-features
              '(sessions locals controls tooltip))
             :config
             (require 'dap-ui)
             (dap-ui-mode 1)
             (dap-ui-controls-mode 1)
             ;; Enables mouse hover support
             (dap-tooltip-mode 1)
             ;; Use tooltips for mouse hover,
             ;; if it is not enabled `dap-mode' will use the minibuffer.
             (tooltip-mode 1)
             ;; Displays floating panel with debug buttons
             (dap-ui-controls-mode 1))
#+END_SRC

*** Additional Test Tools

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "UI Settings")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package counsel-test)

(use-package coverlay)
#+END_SRC

** Data Formats

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Data Formats"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package pcsv)

(use-package csv-mode)

(use-package json-mode)

(use-package toml)
(use-package toml-mode)

(use-package yaml-mode)
(use-package flycheck-yamllint)
#+END_SRC

** Language Environments

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Language Environments"))
#+END_SRC

*** Emacs Lisp

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Emacs Lisp")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package package-lint)

(use-package flycheck-package)

(require 'checkdoc) ;; builtin

(add-hook 'emacs-lisp-mode-hook 'checkdoc-minor-mode)
#+END_SRC

*** Common Lisp

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Common Lisp")
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; (use-package slime)
;; 
;; (use-package slime-company)
;; 
;; (use-package slime-repl-ansi-color)
;; 
;; (use-package elisp-slime-nav)
;; 
;; (setq inferior-lisp-program (locate-file "sbcl" exec-path))
#+END_SRC

*** Scheme

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Scheme")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package geiser-chez)

(use-package geiser-gauche)

(use-package geiser-racket)

(use-package macrostep-geiser
             :hook ((geiser-mode . macrostep-geiser-setup)
                    (geiser-repl-mode . macrostep-geiser-setup)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package lsp-scheme
             :hook (scheme-mode . lsp-gambit-scheme))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package quack)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package scheme-complete)
#+END_SRC

*** Racket

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Racket")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package dr-racket-like-unicode)

(use-package racket-mode)

(use-package scribble-mode :after (racket-mode))
#+END_SRC

*** Rust Language

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Rust Language")
#+END_SRC

For more information/inspiration:

- https://github.com/rust-lang/rust-mode
- https://robert.kra.hn/posts/rust-emacs-setup/

#+BEGIN_SRC emacs-lisp
(defun rustic-mode-auto-save-hook ()
  "Enable auto-saving in rustic-mode buffers."
  (when buffer-file-name
    (setq-local compilation-ask-about-save nil)))

(use-package rustic
             :after (lsp lsp-lens-mode)
             :hook ((rustic-mode . rustic-mode-auto-save-hook)
                    (rustic-mode . lsp-lens-mode))
             :config (setq rustic-babel-format-src-block t
                           rustic-babel-auto-wrap-main t
                           rustic-format-on-save t
                           rustic-lsp-server 'rust-analyzer
                           lsp-rust-analyzer-cargo-load-out-dirs-from-check t
                           lsp-rust-analyzer-cargo-watch-enable t
                           lsp-rust-analyzer-cargo-watch-command "clippy"
                           lsp-rust-analyzer-display-chaining-hints t
                           lsp-rust-analyzer-display-closure-return-type-hints t
                           lsp-rust-analyzer-display-lifetime-elision-hints-use-parameter-names nil
                           lsp-rust-analyzer-display-parameter-hints t
                           lsp-rust-analyzer-display-reborrow-hints t
                           lsp-rust-analyzer-inlay-hints-mode t
                           lsp-rust-analyzer-proc-macro-enable t
                           lsp-rust-analyzer-server-display-inlay-hints t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package cargo-mode
             :after (rustic)
             :hook (rust-mode . cargo-minor))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package rust-auto-use :after (rust))

(use-package rust-playground :after (rust))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'rust-mode-hook 'subword-mode)
#+END_SRC

Flycheck

#+BEGIN_SRC emacs-lisp
(use-package flycheck-rust
              :after (rustic cargo-mode)
              :config (setq flycheck-rustic-clippy-executable "cargo-clippy")
              (unless (member 'rustic-clippy flycheck-checkers)
                (setq flycheck-checkers (cons 'rustic-clippy flycheck-checkers))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(dap-register-debug-template
 "Rust::GDB Run Configuration"
 (list :type "gdb"
       :request "launch"
       :name "GDB::Run"
       :gdbpath "rust-gdb"
       :target nil
       :cwd nil))
#+END_SRC

Org-Babel Integration

#+BEGIN_SRC emacs-lisp
(use-package ob-rust :after (rust))
#+END_SRC

*** PEST Mode

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "PEST Mode")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package pest-mode
             :mode "\\.pest\\'")
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports non
(unless (executable-find "pesta")
  (message "WARN: No `pesta' executable found, go =cargo install pesta="))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package flymake-pest
             :after (pest-mode)
             :hook ((pest-mode . flymake-pest-setup)
                    (pest-input-mode . flymake-pest-input-setup)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package flycheck-pest
             :after (flycheck pest-mode)
             :config (flycheck-pest-setup))
#+END_SRC

*** SQL Stuff

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "SQL")
#+END_SRC

Support formatting SQL buffers.

#+BEGIN_SRC emacs-lisp
(use-package sqlformat
             :custom
             (sqlformat-command "sqlfluff"))

(add-hook 'sql-mode-hook 'sqlformat-on-save-mode)

(use-package flymake-sqlfluff
             :after (flymake)
             :hook (sql-mode . flymake-sqlfluff-load))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports non
(unless (executable-find "sqlfluff")
  (message "WARN: No `sqlfluff' executable found, go =pip3 install sqlfluff="))
#+END_SRC

Use the builtin =sql-mode= in Org blocks.

#+BEGIN_SRC emacs-lisp
(use-package ob-sql-mode)
#+END_SRC

Emacs own interface for SQL databases.

#+BEGIN_SRC emacs-lisp
(use-package emacsql)

(use-package emacsql-sqlite-module)
#+END_SRC

*** Web Development

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Web Development")
#+END_SRC

Extensions to the standard =html-mode=.

#+BEGIN_SRC emacs-lisp
(use-package auto-rename-tag
             :hook (html-mode))

(use-package cakecrumbs
             :custom
             (cakecrumbs-html-major-modes '(html-mode web-mode nxml-mode sgml-mode))
             (cakecrumbs-scss-major-modes '(scss-mode less-css-mode css-mode))
             :config
             (cakecrumbs-auto-setup))

(defun skj/toggle-showcss()
  "Toggle showcss-mode"
  (interactive)
  (if (derived-mode-p
       'html-mode
       'nxml-mode
       'nxhtml-mode
       'web-mode
       'handlebars-mode)
      (showcss-mode 'toggle)
    (message "Not in an html mode")))

(use-package show-css
             :bind ("C-c C-k" . skj/toggle-showcss))
#+END_SRC

Completion

#+BEGIN_SRC emacs-lisp
(use-package ac-html-bootstrap)

(use-package ac-html-csswatcher)

(use-package company-web)

(use-package counsel-css)
#+END_SRC

Template page support.

#+BEGIN_SRC emacs-lisp
(use-package jinja2-mode)

(use-package web-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package react-snippets)
#+END_SRC

*** JavaScript

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "JavaScript")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package js2-mode
             :mode (("\\.js\\'" . js2-mode)
                    ("\\.mjs\\'" . js2-mode)))

(use-package js2-highlight-vars)

(use-package js2-refactor
             :hook (js2-mode)
             :config (js2r-add-keybindings-with-prefix "C-c C-r"))

(use-package js2hl)

(use-package xref-js2)
#+END_SRC

Integration of [[https://beautifier.io/][beautifier.io]].

#+BEGIN_SRC emacs-lisp
(use-package web-beautify)
#+END_SRC

The underlying command-line tool is  installed by typing: =npm -g install js-beautify=.

*** Typescript

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Typescript")
#+END_SRC

See:

- https://github.com/ananthakumaran/tide
- https://github.com/emacs-typescript/ts-comint
- https://github.com/emacs-typescript/typescript.el

#+BEGIN_SRC emacs-lisp
(use-package typescript-mode)

(use-package tide)

(use-package ts-comint)
#+END_SRC

To run a TypeScript interpreter (REPL) in an inferior process window =M-x
run-ts=. For the external interpreter you'll need to run =npm install -g tsun=.

Use =typescript-mode= in Org blocks.

#+BEGIN_SRC emacs-lisp
(use-package ob-typescript)
#+END_SRC

*** Semantic Web

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Semantic Web")
#+END_SRC

Lookup RDF prefixes

#+BEGIN_SRC emacs-lisp
(use-package rdf-prefix)
#+END_SRC

SPARQL mode

#+BEGIN_SRC emacs-lisp
(use-package sparql-mode
             :mode (("\\.sparql$" . sparql-mode)
                    ("\\.rq$" . sparql-mode)))
#+END_SRC

Use =sparql-mode= in Org blocks.

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((sparql . t)))
#+END_SRC

*** Proof Assistants
   
#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Proof Assistants")
#+END_SRC

Proof General is a generic Emacs interface for proof assistants
(also known as interactive theorem provers).

It is supplied ready to use for the proof assistants Coq,
EasyCrypt, qrhl, and PhoX.

#+BEGIN_SRC emacs-lisp
(use-package proof-general)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package coq-commenter
  :hook (coq-mode)
  :bind (:map coq-commenter-mode-map
              ("C-;" . coq-commenter-comment-proof-in-region)
              ("C-x C-;" . coq-commenter-comment-proof-to-cursor)
              ("C-'" . coq-commenter-uncomment-proof-in-region)
              ("C-x C-'" . coq-commenter-uncomment-proof-in-buffer)))
#+END_SRC

This package includes a collection of company-mode back-ends for
Proof-General's Coq mode, and many useful extensions to Proof-General.

#+BEGIN_SRC emacs-lisp
(use-package company-coq
             :hook (coq-mode))
#+END_SRC

** AWS Integration

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "AWS Integrations"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package awscli-capf
             :config
             (add-hook 'shell-mode-hook
                       (lambda ()
                         (add-to-list 'completion-at-point-functions 'awscli-capf))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package cfn-mode)

(use-package flycheck-cfn :config (flycheck-cfn-setup))
#+END_SRC

Also consider =aws-ec2=.

** Developer Services

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Developer Services"))
#+END_SRC

*** Wakatime
   
#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Wakatime")
#+END_SRC

[[https://wakatime.com/emacs][Wakatime]] service customization. This service tries to keep track of what
projects and what tools you use as an engineer. Set the API key in =~/.wakatime.cfg=.

#+BEGIN_SRC emacs-lisp
(use-package wakatime-mode
             :custom
             (wakatime-cli-path (locate-file "wakatime-cli" exec-path))
             :config
             (global-wakatime-mode))
#+END_SRC

** For Fun

Don't forget to =M-x asm-blox=!

#+BEGIN_SRC emacs-lisp
(use-package asm-blox)
#+END_SRC


* Work Configuration

#+BEGIN_SRC emacs-lisp :exports none
(setq l1-msg (progress "Work Configuration"))
#+END_SRC

Only basic information should exist in here, put the rest in external
resources referenced in [[*Work Packages]].

** Paths

#+BEGIN_SRC emacs-lisp :exports none
(setq l1-msg (progress "Paths"))
#+END_SRC

These are either common on dev boxes or laptop environments.

#+BEGIN_SRC emacs-lisp :exports none
(dolist (path '("~/bin" "~/.toolbox/bin"))
  (exec-path-prepend path))
#+END_SRC

** Customization

#+BEGIN_SRC emacs-lisp :exports none
(setq l1-msg (progress "Customization"))
#+END_SRC

These parallel their non-work values.

#+BEGIN_SRC emacs-lisp
(defcustom
  skj/work-email
  "simonjo@amazon.com"
  "Primary email address for work."
  :tag "Work email address"
  :group 'skj
  :type 'string)

(defcustom
  skj/work-project-root-dir
  (expand-file-name (concat-path skj/project-root-dir "Amazon"))
  "Root directory for work development projects."
  :tag "Work projects' root directory"
  :group 'skj
  :type 'directory)
#+END_SRC

** Work Packages

#+BEGIN_SRC emacs-lisp :exports none
(setq l1-msg (progress "Work Packages"))
#+END_SRC

The =work= directory should be a symlink to a Git repository containing any
work-specific packages.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (concat-path user-emacs-directory "lib/work"))
#+END_SRC

** Org Mode

#+BEGIN_SRC emacs-lisp :exports none
(setq l1-msg (progress "Org Mode"))
#+END_SRC

Load initial work org files, there may be more, but this is a start.

#+BEGIN_SRC emacs-lisp
(setq work-org-directory
      (concat-path skj/work-project-root-dir "/SimonjoDocuments/emacs-org"))

(setq org-agenda-files
      (append org-agenda-files
              (list (concat work-org-directory "/work.org")
                    (concat work-org-directory "/people.org"))))
#+END_SRC


* Finishing Up

#+BEGIN_SRC emacs-lisp :exports none
(setq l1-msg (progress "Finishing Up"))
#+END_SRC

These things need to be last!

** Reset the GC Threshold

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Reset the GC Threshold"))
#+END_SRC

Set this back to a reasonable value now that startup is complete.

#+BEGIN_SRC emacs-lisp
(setq gc-cons-percentage 0.1
      gc-cons-threshold (* 2 1024 1024))
#+END_SRC

** Run Emacs as a Server

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Run Emacs as a Server?"))
#+END_SRC

Pretty self-explanatory, if we aren't already running as a client, start the
server process.

#+BEGIN_SRC emacs-lisp
(require 'server) ;; builtin

(unless (and (fboundp 'server-running-p) (server-running-p))
  (progress l2-msg "Starting Emacs server")
  (server-start))
#+END_SRC

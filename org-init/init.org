#+TITLE: Emacs Initialization
#+SUBTITLE: Org-Mode Init.el
#+AUTHOR: Simon Johnston
#+EMAIL: johnstonskj@gmail.com
#+LANGUAGE: en
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+OPTIONS: toc:3

This is the org-mode version of my Emacs configuration. It is pretty long, but after having a modular version I've
actually found having a hyperlinked output is super useful. Also, I do like literate programming in general although
it's hard to find a good implementation.

The following function gates logging in the rest of the file. It's first so I can wrap it around /anything/ in the rest of
this file. Note that this depends on the value of =debug-on-error= but can easily be overridden and set/unset explicitly.

#+BEGIN_SRC emacs-lisp
(defvar skj/debug-init (and (boundp debug-on-error) debug-on-error)
  "Do I want to debug the init process?")

(defun init-message (message &rest args)
  (when skj/debug-init
    (message (concat "INIT: " message) args)))

(init-message "init file: " user-init-file)
#+END_SRC

Set the garbage collection threshold to a high value during initialization to speed things along.

#+BEGIN_SRC emacs-lisp
(setq gc-cons-percentage 0.6
      gc-cons-threshold most-positive-fixnum)
#+END_SRC

We'll also set up a hook to see how long startup took, and with the number of garbage collection cycles. It's not a
perfect metric, but good to know if it changes without corresponding change to this file.

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "Emacs ready in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time
                                             before-init-time)))
                     gcs-done)))
#+END_SRC

If this all goes horribly wrong, the following installs the [[https://github.com/jschaf/esup][Emacs Startup Profiler]] -- /Benchmark Emacs Startup time
without ever leaving your Emacs./

To start Esup, run =M-x esup=, and watch the magic happen. By default, Esup will profile =user-init-file=. To profile a
custom file, call esup with a prefix argument. That is, =C-u M-x esup=.

#+BEGIN_EXAMPLE emacs-lisp
(use-package esup)
(init-message "Type `M-x esup' to execute the Emacs Startup Profiler")
#+END_EXAMPLE

* Utility Functions

These are all useful things to have around. Note that the function ~concat-path~ is defined in the bootstrap =init.el= and
the /initial/ version of the function ~init-message~ is defined at the top of this file.

** Feature Management

The expands a list of features that should not be installed. it adds names from the environment variable
=EMACS_LOCAL_FEATURES_OFF= which may contain a colon separated list of feature paths.

#+BEGIN_SRC emacs-lisp :lexical t
(require 'subr-x) ;; builtin convenience functions.

(init-message "processing not-required features")

(defconst skj/feature--not-required
  '("dev/aws"
    "dev/lang/ada"
    "dev/lang/dart"
    "dev/lang/lua"
    "dev/lang/ocaml"
    "dev/lang/provers"
    "dev/lang/python"
    "dev/lang/smithy"
    "dev/lang/sql"
    "dev/lang/swift"
    "dev/lang/typescript"
    "fun"
    "org/babel/ditaa"
    "org/babel/gnuplot"
    "org/babel/mermaid"
    "social"
    "writing/rfc"))

(dolist (p (split-string (or (getenv "EMACS_LOCAL_FEATURES_OFF") "") ":"))
  (when (and (stringp p) (> (length p) 0))
    (add-to-list 'skj/feature--not-required p)))

(init-message "not-required = %s" skj/feature--not-required)
#+END_SRC

First, define a variable that will track the nested feature names as they are entered and left.

#+BEGIN_SRC emacs-lisp :lexical t
(defvar skj/feature--stack '())
#+END_SRC

Now we can redefine ~init-message~ which will include the current feature stack.

#+BEGIN_SRC emacs-lisp :lexical t
(defun init-message (&optional msg &rest args)
  (when skj/debug-init
	(let* ((init-prefix "INIT: ")
	       (feature-prefix (string-join (reverse (mapcar 'cadr skj/feature--stack)) " > "))
	       (has-feature-prefix (> (length feature-prefix) 0))
	       (msg (concat init-prefix
			            feature-prefix
			            (cond
			             ((and has-feature-prefix msg) (concat " :: " msg))
			             ((and (not has-feature-prefix) msg) msg)
			             ((and has-feature-prefix (not msg)) "...")))))
	  (apply 'message msg args))))
#+END_SRC

Now we get to the main functions, which are:

- ~skj/feature-start~ :: Starting a feature pushes it's symbol argument onto the feature stack.
- ~skj/feature-end~ :: Ending a feature will pop the stack.
- ~skj/current-feature-required-p~ :: This returns `t` if the top item on the stack matches the argument.

#+BEGIN_SRC emacs-lisp :lexical t
(defun skj/feature--required (name)
  (let* ((path-parts (reverse (cons name (mapcar (lambda (elt) (car elt)) skj/feature--stack))))
	     (path (string-join path-parts "/")))
	(not (seq-some (lambda (p) (or (string= path p)
				                   (string-prefix-p (concat p "/") path)))
		           skj/feature--not-required))))

(defun skj/feature-start (name &optional message)
  "Start a new feature named NAME, with the display MESSAGE.
    If MESSAGE is not specified it will be a capitalized form of the NAME."
  (let* ((name (format "%s" name))
	     (message (if message
		              message
	                (capitalize (string-replace "-" " " name))))
	     (required (skj/feature--required name)))
    (setq skj/feature--stack
	      (cons (list name message required) skj/feature--stack))
    (when skj/debug-init
      (if (skj/current-feature-required-p)
          (init-message)
        (init-message "disabled")))
    (skj/current-feature-required-p)))

(defun skj/feature-end (&optional name)
  "End the current feature."
  (when (null skj/feature--stack)
    (error "Cannot end feature %s, stack is empty" name))
  (when (and name (not (string= name (caar skj/feature--stack))))
    (error "Trying to end feature named %s, current is %s"
	       name (car skj/feature--stack)))
  (setq skj/feature--stack (cdr skj/feature--stack)))

(defsubst skj/current-feature-required-p ()
  "Is the current feature required.
Note that this returns t if the stack is empty which usually means
it's been called by `eval-buffer' or `eval-region'."
  (or (null skj/feature--stack)
      (caddr (car skj/feature--stack))))
#+END_SRC

** Utilities

These are simple utilities, all of which /should/ include documentation strings.

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'utilities "Utility Functions")
#+END_SRC

This function manipulates the path for executable commands outside of Emacs. It affects both Emacs =exec-path= variable
and the =PATH= environment variable.

#+BEGIN_SRC emacs-lisp
(defun exec-path-prepend (path)
  "Add PATH to the beginning of the current `exec-path` variable,
and the shell's `$PATH` variable."
  (unless (member path exec-path)
    (setq exec-path (cons path exec-path))
    (setenv "PATH" (concat path ":" (getenv "PATH")))))
#+END_SRC

The following is a simple predicate that allows for us to gate actions to only occur on macos.

#+BEGIN_SRC emacs-lisp
(defun system-mac-p ()
  "Return `t` if this is Darwin, else nil."
  (eq system-type 'darwin))
#+END_SRC

This is useful for version checks, so they don't use string comparisons.

#+BEGIN_SRC emacs-lisp
(defconst emacs-version-number
  (string-to-number
   (string-join
    (seq-take (split-string emacs-version "\\.") 2)
    ".")))
#+END_SRC

Italics usually don't show up well on terminals, so pick a common color and set it for all /italic-like/ text.

#+BEGIN_SRC emacs-lisp
(defun set-italic-face-attributes (face)
  "Set the preferred FACE styling for italic text."
  (set-face-attribute face nil
                      :foreground "mediumseagreen"
                      :slant 'italic))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'utilities)
#+END_SRC


* Initial Environment

This sets up an initial environment such that low-level customization and key components like the package manager are
setup. At the end of this we should have a working, but uninteresting state.

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'initial "Initial Customization")
#+END_SRC

** Startup Settings

These are key settings that we want to ensure early in the process, they affect core Emacs behavior.

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'startup "Startup Settings")
#+END_SRC

The following are either console settings or affect both console and graphical clients.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (setq warning-suppress-log-types '((package reinitialization)))

  ;; no startup  screen
  (setq inhibit-startup-screen t)

  ;; no startup message
  (setq inhibit-startup-message t)
  (setq inhibit-startup-echo-area-message t)

  ;; initial buffer
  (setq initial-buffer-choice nil)

  ;; no frame title
  (setq frame-title-format nil)

  ;; no file dialog
  (setq use-file-dialog nil)

  ;; no dialog box
  (setq use-dialog-box nil)

  ;; no empty line indicators
  (setq indicate-empty-lines nil)

  ;; no cursor in inactive windows
  (setq cursor-in-non-selected-windows nil)

  (setq initial-scratch-message nil)
  (setq inhibit-default-init t)

  (setq echo-keystrokes 0.5)

  ;; no beeping and no blinking please
  (setq ring-bell-function #'ignore)
  (setq visible-bell nil)

  ;; start easy with little dependencies to load
  (setq initial-major-mode 'fundamental-mode))
#+END_SRC

The following are for graphical clients only.

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p) window-system)

  ;; don't resize emacs in steps, it looks weird and plays bad with
  ;; window manager.
  (setq window-resize-pixelwise t)
  (setq frame-resize-pixelwise t)

  ;; disable bidirectional text for tiny performance boost
  (setq bidi-display-reordering nil)

  ;; Size of temporary buffers
  (temp-buffer-resize-mode)
  (setq temp-buffer-max-height 8)

  ;; Minimum window height
  (setq window-min-height 1)

  ;; Turn off scrollbars, who needs them!
  (scroll-bar-mode -1)

  ;; Restricts how close point can come to the top or bottom of a window, its
  ;; value is a number of screen lines.
  (setq scroll-margin 1)

  ;; Determines the number of lines by which to automatically scroll, when point
  ;; moves off the screen
  (setq scroll-step 1)

  ;; They take up space for no good reason.
  (tool-bar-mode -1)

  (when (and (>= emacs-major-version 26) (< emacs-major-version 29))
    (pixel-scroll-mode))

  (when (>= emacs-major-version 29)
    (setq pixel-scroll-precision-mode 1)))
    #+END_SRC

We do the following to suppress warnings from third-party packages during startup. These are warnings generated when
functions are redefined with =defadvice=. Note that the package =advice= is builtin.

#+BEGIN_SRC emacs-lisp
  (require 'advice) ;; builtin and pre use-package
  (setq ad-redefinition-action 'accept)
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'startup)
#+END_SRC

** Load Path

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'load-path)
#+END_SRC

These paths get added to the module search path, the =lib= directory should be a symlink to my local Git repository.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (add-to-list 'load-path (concat-path user-emacs-directory "lib"))
  (add-to-list 'load-path (concat-path user-emacs-directory "lib/skj")))
#+END_SRC

This is a directory that contains links to packages outside the standard load path. For example packages still in
development.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  (add-to-list 'load-path (concat-path user-emacs-directory "llib")))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'load-path)
#+END_SRC

** Package Management Setup

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'package-manager "Package Management Setup")
#+END_SRC

This section sets up the package management used in the rest of the file. I prefer =use-package= over calling
=install-package= as it groups a lot of configuration in a sane and readable manner.

Before we download anything, we will disable TLS v1.2, v1.1, and v1.0. Note, this is done regardless of feature flags.

#+BEGIN_SRC emacs-lisp
(setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.2:-VERS-TLS1.1:-VERS-TLS1.0")
#+END_SRC

Also, note that errors may pop-up when GNU elpa changes their signing key. There is a description of this on
[[https://emacs.stackexchange.com/questions/233/how-to-proceed-on-package-el-signature-check-failure][emacs.stackexchange]], however the following worked:

1. Set ~package-check-signature~ to ~nil~, e.g., ~M-: (setq package-check-signature nil) RET~.
2. Go to [[https://elpa.gnu.org/packages/gnu-elpa-keyring-update.html]] and download the latest archive.
3. Install with ~M-x package-install-file RET~ and enter the file name you downloaded.
4. Reset ~package-check-signature~ to the default value ~allow-unsigned~, e.g., ~M-: (setq package-check-signature 'allow-unsigned) RET~.
5. Restart Emacs, this allows you to check the message log for any remaining errors.

*** Add Package Repositories

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'repositories "Package Repositories")
#+END_SRC

Add the most common package archives and set priorities. Note that this feature cannot be disabled.

#+BEGIN_SRC emacs-lisp
(require 'package) ;; builtin and pre use-package

(add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/"))
(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
(add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/"))

(setq package-archive-priorities '(("gnu" . 30)
                                   ("melpa-stable" . 20)
                                   ("melpa" . 10)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'repositories)
#+END_SRC

*** Package Manager Configuration

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'config "Package Manager Configuration")
#+END_SRC

Ensure =use-package= is always installed/available first. Note that this feature cannot be disabled.

#+BEGIN_SRC emacs-lisp
(when (not (package-installed-p 'use-package))

  (package-refresh-contents)

  (package-install 'use-package))
#+END_SRC

The use-package-always-ensure variable indicates that use-package should always try to install missing packages. For
some libraries this is not appropriate, and in those cases you see the :ensure nil declaration as part of the
use-package statement. This applies mainly to libraries which are installed as part of some other package (happens
mostly with some libraries that come with org-mode).

#+BEGIN_SRC emacs-lisp
(setq use-package-always-ensure t)
#+END_SRC

The ~use-package-always-defer~ sets =:defer= true as the default for all package declarations. This makes Emacs startup much
faster by preventing packages from being loaded when Emacs starts, and only doing so when they are needed. Some packages
don’t work well with this, so you’ll see some declarations when I explicitly set =:defer nil= to force the package to be
loaded at startup, or =:defer n= to load the package, but only =n= seconds after startup.

#+BEGIN_SRC emacs-lisp
(setq use-package-always-defer t)
#+END_SRC

The main advantage to the `use-package-expand-minimally' variable is that, if you know your configuration works, it will
make the byte-compiled file as minimal as possible. It can also help with reading macro-expanded definitions, to
understand the main intent of what’s happening.

#+BEGIN_SRC emacs-lisp
(setq use-package-expand-minimally nil)
#+END_SRC

Minor modes each put a word on the mode line to signify that they're active. This can cause other displays, such as % of
file that point is at, to run off the right side of the screen. For some minor modes, such as mouse-avoidance-mode, the
display is a waste of space, since users typically set the mode in their .emacs & never change it. For other modes, such
as my jiggle-mode, it's a waste because there's already a visual indication of whether the mode is in effect.

A diminished mode is a minor mode that has had its mode line display diminished, usually to nothing, although
diminishing to a shorter word or a single letter is also supported. This package implements diminished modes -- it will
be removed in favor of =use-package=.

#+BEGIN_SRC emacs-lisp
(use-package diminish)
#+END_SRC

The ~use-package-verbose~ variable enables verbose loading of packages, useful for debugging. I set/unset this according
to need.

#+BEGIN_SRC emacs-lisp
(setq use-package-verbose (if skj/debug-init 'debug 'nil))
#+END_SRC

If we are debugging, let's go ahead and get a =use-package= statistics report at the end of the startup process.

#+BEGIN_SRC emacs-lisp
(when skj/debug-init
  (setq use-package-compute-statistics t)
  (add-hook 'emacs-startup-hook (lambda () (use-package-report))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'config)
#+END_SRC

*** System Package Manager

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'system "System Package Manager")
#+END_SRC

The [[https://gitlab.com/jabranham/system-packages][system-packages]] package is a collection of functions to make handling installed system packages more convenient
through Emacs. Specifically this is set up to use the Homebrew package manager for installing commands that may then be
called by Emacs code.

#+BEGIN_SRC emacs-lisp
(use-package system-packages
  :if (skj/current-feature-required-p)
  :custom
  (system-packages-package-manager 'brew)
  (system-packages-use-sudo nil))
#+END_SRC

This extension adds a ~:ensure-system-package~ keyword to the ~use-package~ function which allows you to ensure system
binaries exist alongside your package declarations.

#+BEGIN_SRC emacs-lisp
(use-package use-package-ensure-system-package
  :ensure t
  :if (skj/current-feature-required-p)
  :after (use-package system-packages))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'system)
#+END_SRC

*** Auto-Compile

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'auto-compile "Auto-Compile Packages")
#+END_SRC

Always compile packages, and use the newest version available, this speeds up startup considerably.

#+BEGIN_SRC emacs-lisp
(use-package auto-compile
  :if (skj/current-feature-required-p)
  :defer nil
  :custom
  (auto-compile-display-buffer nil)
  (auto-compile-mode-line-counter t)
  (load-prefer-newer t)
  :config
  (auto-compile-on-load-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'auto-compile)
#+END_SRC

*** Auto-Update Packages

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'auto-update "Auto-Update Packages")
#+END_SRC

[[https://github.com/rranelli/auto-package-update.el][This package]] provides functionality for automatically updating your Emacs packages periodically. It is specially useful
for people that work in multiple machines and tend to forget to manually update packages from time to time.

Configure the update to happen every 7 days, at 3:00am, deleting any old/obsolete packages after updating.

#+BEGIN_SRC emacs-lisp
(use-package auto-package-update
  :if (skj/current-feature-required-p)
  :defer 1
  :custom
  (auto-package-update-interval 7)
  (auto-package-update-delete-old-versions t)
  (auto-package-update-hide-results t)
  :config 
  (auto-package-update-at-time "03:00")
  (auto-package-update-maybe))
#+END_SRC

=auto-package-update-maybe= will update your installed packages, if there is an update pending.

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'auto-update)
(skj/feature-end 'package-manager)
#+END_SRC

** Personal Customization Group

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'group "Personal Customization Group")
#+END_SRC

For those things I want to ensure I can find and tweak at runtime I use the following customization group. This allows
you to /=M-x customize-group=/ and select =skj=.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defgroup skj nil
    "Simon's personal environment settings."
    :tag "skj"
    :prefix "skj/"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'group)
#+END_SRC

** Load Customized Values

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'custom "Load Customized Values")
#+END_SRC

It is a good idea to use a separate file for customized settings. Some users actually create a temporary file so that
changes are session-only. However, I prefer to keep the customization and if they prove useful move them to the main
initialization files.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (setq custom-file (concat-path user-emacs-directory "custom.el")))
#+END_SRC

Assuming that the code in =custom-file= is execute before the code ahead of this line is not a safe assumption. So load
this file proactively.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  (init-message "loading customize settings from %s" custom-file)
  (load-file custom-file))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'custom)
#+END_SRC

** User Information

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'user-information)
#+END_SRC

Basic identity values, these are my common non-work values.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defcustom skj/default-user-name "johnstonskj"
    "A default user name, or user name prefix."
    :tag "Default user name"
    :group 'skj
    :type 'string)

  (defcustom skj/primary-email (concat skj/default-user-name "@gmail.com")
    "Primary, non-work, email address."
    :tag "Primary email address"
    :group 'skj
    :type 'string)

  (defcustom skj/full-name "Simon Johnston"
    "Full name to go with email-address."
    :tag "Full name"
    :group 'skj
    :type 'string))
#+END_SRC

The following are used by Emacs.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (setq user-login-name skj/default-user-name
        user-full-name skj/full-name
        user-mail-address skj/primary-email))
#+END_SRC

This is just useful to have, the expanded version ensures that anywhere I use it I don't have to worry about a function
ignoring the tilde.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defvar user-home-directory (expand-file-name "~")))
#+END_SRC

This sets my most common location, and while mostly used by calendaring and [[*Agenda]], I keep it here. Note the three
required packages are all Emacs builtins.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  ;; All of thee three are builtins
  (use-package calendar :ensure nil :defer nil)

  (use-package cal-dst
    :ensure nil
    :defer 2
    :after calendar
    :custom
    (calendar-time-zone -480)
    (calendar-standard-time-zone-name "PST")
    (calendar-daylight-time-zone-name "PDT"))

  (use-package solar
    :ensure nil
    :defer 2
    :after calendar
    :custom
    (calendar-latitude 47.6062)
    (calendar-longitude -122.3321)
    (calendar-location-name "Seattle, WA")))

#+END_SRC

This isn't absolutely necessary, but keeping a use-case neutral form seems like a good idea. See also [[*Google
Calendar]].

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defvar calendar-time-zone-name "America/Los_Angeles"
    "The name of the timezone set in `cal-dst'."))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'user-information)
#+END_SRC

** More Paths

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'paths)
#+END_SRC

Additional paths and locations that are really not feature-specific.

*** Command Execution Paths

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'execution "Command Execution Paths")
#+END_SRC

[[https://brew.sh/][Homebrew]] is great, but just in case it isn't on the path, this helps a lot.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (require 'homebrew) ;; local file

  (exec-path-prepend (homebrew-prefix/bin)))
#+END_SRC

I should move all these into =~/.local/bin=

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defconst skj/local-bin-dir (expand-file-name "~/bin")
    "Path to local (small) binaries and scripts directory.")

  (exec-path-prepend skj/local-bin-dir))
#+END_SRC

This is the XDG local binary path.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (exec-path-prepend (expand-file-name "~/.local/bin")))
#+END_SRC

This is a weird one, can't remember why ...

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p) (system-mac-p) window-system)

  (exec-path-prepend "usr/local/bin"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'execution)
#+END_SRC

*** Common Project Directory

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'projects "Common Project Directory")
#+END_SRC

Set the root for all my projects, home and work.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defcustom skj/project-root-dir (expand-file-name "~/Projects")
    "Root directory for development projects."
    :tag "Project root directory"
    :group 'skj
    :type 'directory))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'projects)
(skj/feature-end 'paths)
(skj/feature-end 'initial)
#+END_SRC


* Generic Configuration

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'generic "Generic Configuration")
#+END_SRC

By generic I mean not /specifically/ for the major uses in [[*Org-Mode]], [[*Other Writing Modes]], or [[*Developer Configuration]].
Some of these are not necessarily "generic" unless you do all your work on Git for example.

** Authentication/Authorization Stores

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'auth "Authentication/Authorization Stores")
#+END_SRC

Support for the command-line [[https://www.passwordstore.org/][pass]] tool, bound to the key =M-p p=. The [[https://github.com/ecraven/ivy-pass/][ivy-pass]] package provides a simple front-end to =pass=
(=M-p i=) with a default action is to copy the password to the kill ring although =M-o= brings up other options.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package password-store
    :ensure-system-package pass)

  ;; password-store-otp ?

  (use-package pass
    :after password-store
    :bind ("M-p p" . pass)))
#+END_SRC

First, load the built-in EasyPG support. By calling (~epa-file-enable~), Emacs automatically encrypts/decrypts files with
a =.gpg= extension. By default it asks about the key to use, but I configure it to always use my own GPG key.

#+BEGIN_SRC emacs-lisp
(use-package epa-file
  :if (skj/current-feature-required-p)
  :ensure nil ;; included with Emacs
  :custom
  (epa-file-select-keys 'silent)
  (epa-file-encrypt-to (list skj/primary-email))
  :config
  (epa-file-enable))
#+END_SRC

And configure a simple /authinfo/ source in Emacs as well as using the local password store.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package auth-source)
  (use-package auth-source-pass)

  (use-package password-menu
    :after auth-source)

  (auth-source-pass-enable)
  
  (setq auth-sources
        (cons (concat-path user-emacs-directory "authinfo.gpg")
              auth-sources)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'auth)
#+END_SRC

** Core UI Settings

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'core-ui "Core UI Settings")
#+END_SRC

These are customizations of the basic UI beyond those needed for startup in [[*Startup Settings]].

Packages I tried, but ultimately decided against:

- ~expand-region~ :: A pretty simple package, takes your cursor and semantically expands the region, so words, sentences,
  maybe the contents of some parentheses, it’s awesome, try it out.

The following is not feature gated, it is a builtin package used by a bunch of others, worth adding for ~use-package~'s
~:after~ keyword.

#+BEGIN_SRC emacs-lisp
(use-package ansi-color
  :ensure nil)
#+END_SRC

*** Theme Support

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'themes "Theme Support")
#+END_SRC

Theming is a core Emacs feature but we need to actually install a theme and how anyone uses anything other than
[[https://ethanschoonover.com/solarized/][solarized]] is beyond me.

#+BEGIN_SRC emacs-lisp
(use-package color-theme-sanityinc-solarized
  :if (skj/current-feature-required-p)
  :init
  (setq custom-enabled-themes '(sanityinc-solarized-light)
        custom-safe-themes
        '("4cf3221feff536e2b3385209e9b9dc4c2e0818a69a1cdb4b522756bcdf4e00a4" default))
  :config (setq color-theme-is-global t)
  (color-theme-sanityinc-solarized-light))
#+END_SRC

It's useful to have a way to refer to the colors used in a theme and the following allows a simple lookup by name for
the color's RGB value.

#+BEGIN_SRC emacs-lisp
(defconst skj/theme-core-color-alist
  '((base03  . "#002b36")
    (base02  . "#073642")
    (base01  . "#586e75")
    (base00  . "#657b83")
    (base0   . "#839496")
    (base1   . "#93a1a1")
    (base2   . "#93a1a1")
    (base3   . "#fdf6e3")
    (yellow  . "#b58900")
    (orange  . "#cb4b16")
    (red     . "#dc322f")
    (magenta . "#d33682")
    (violet  . "#6c71c4")
    (blue    . "#268bd2")
    (cyan    . "#2aa198")
    (green   . "#859900")))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'themes)
#+END_SRC

*** Input Encoding

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'encoding "Input Encoding")
#+END_SRC

We really like UTF-8; seriously, on a modern system there isn't a good excuse to not use it for everything. Some modern
programming languages and other tools also require UTF-8 input, so it's the most useful default.

Note that in setting the locale language and encoding we ignore the process environment variables such as =LC_ALL= to
ensure we don't hork Emacs if the shell environment is incorrect/mangled.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (init-message "System locale (LC_ALL): %s" (getenv "LC_ALL"))
  (defconst locale-language "en" "My preferred locale language.")
  (defconst locale-country "US" "My preferred locale country")
  (defconst locale-encoding 'utf-8 "My preferred locale encoding/codeset.")

  (let ((language-string (concat locale-language "_" locale-country))
        (encoding-string  (upcase (symbol-name locale-encoding))))
    (init-message "Setting locale to %s.%s" language-string encoding-string)
    (set-locale-environment (concat language-string "." encoding-string))
    (set-language-environment encoding-string))

  (setq-default buffer-file-coding-system locale-encoding
                coding-system-for-read locale-encoding
                coding-system-for-write locale-encoding
                file-name-coding-system locale-encoding
                keyboard-coding-system locale-encoding
                locale-coding-system locale-encoding
                prefer-coding-system locale-encoding
                terminal-coding-system locale-encoding))
#+END_SRC

Loading the following package defines three ways of entering the non-ASCII printable characters with codes above 127:
the prefix =C-x 8=, or the Alt key, or a dead accent key.For example, you can enter uppercase =A-umlaut= as =C-x 8 " A= *or*
=Alt-" A= (if you have an Alt key) *or* =umlaut A= (if you have an umlaut/diaeresis key).

#+BEGIN_SRC emacs-lisp
(use-package iso-transl
  :if (skj/current-feature-required-p)
  :ensure nil)
#+END_SRC

It is worth mentioning the ~set-input-method~ (=C-x RET=) function that allows for a number of input methods other than the
usual keyboard changes. One useful tool is to set the input method to =TeX= which allows the use of character entities to
be add by their TeX command names. Also, choose =sgml= for entering HTML entities. See [[org-entities]] later for an
alternative tool

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'encoding)
#+END_SRC

*** Basic Editing Customization

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'editing "Basic Editing Customization")
#+END_SRC

Because this *is not* the 1950's! These settings are actually in a core file named ~paragraphs~, however we can't access
that directly as a package so we have to rely on the ~emacs~ package.

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :ensure nil
  :if (skj/current-feature-required-p)
  :custom
  (sentence-end-double-space nil)
  (colon-double-space nil))
#+END_SRC

The whole tabs vs. spaces thing may be funny, but only because it's sad that people still think tabs are cool. Set up
the *correct* =TAB= and =SPC= handling.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (setq require-final-newline t)

  (setq-default
   indent-tabs-mode nil
   indicate-empty-lines t
   show-trailing-whitespace nil
   tab-always-indent 'complete
   tab-width 4)

  (add-hook 'prog-mode-hook (lambda () (setq show-trailing-whitespace t))))
#+END_SRC

Set the fill column value and turn on visual indicator. This block also enables /visual line mode/ which wraps long lines,
and /visual fill column mode/ which wraps lines at ~fill-column~.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (setq-default fill-column 120)

  (use-package display-fill-column-indicator
    :ensure nil
    :defer 1
    :hook
    ((markdown-mode
      org-mode
      prog-mode) . display-fill-column-indicator-mode))

  (use-package visual-line-mode
    :ensure nil
    :defer 2
    :after display-fill-column-indicator)

  (use-package visual-fill-column
    :defer 2
    :after visual-line-mode
    :hook (visual-line-mode . visual-fill-column-mode))

  (use-package adaptive-wrap
    :defer 3
    :after visual-fill-column))
#+END_SRC

This is super useful, especially in writing and modes where you want to wrap text in parenthesis or quotes. Note that
the customization group for this is ~electricity~.

#+BEGIN_SRC emacs-lisp
(use-package elec-pair
  :if (skj/current-feature-required-p)
  :ensure nil
  :defer 1
  :diminish electric-pair-mode)
#+END_SRC

OMG!! Enable the overwriting of selected text when you type... like every sane editor and O/S!

#+BEGIN_SRC emacs-lisp
(use-package delsel
  :ensure nil
  :defer 1
  :if (skj/current-feature-required-p)
  :config (delete-selection-mode t))
#+END_SRC

Save your location within files between sessions.

#+BEGIN_SRC emacs-lisp
(use-package saveplace
  :ensure nil
  :defer 1
  :if (skj/current-feature-required-p)
  :config (save-place-mode 1))
#+END_SRC

How does anyone work without an [[https://gitlab.com/tsc25/undo-tree][Undo Tree]]! Note that there is a nice feature to show the timestamps along with the diff
for each change by setting ~undo-tree-visualizer-timestamps~ to ~t~; however, this seems to make the whole experience
unstable.

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :if (skj/current-feature-required-p)
  :defer 1
  :diminish undo-tree-mode
  :config
  (setq-default undo-tree-visualizer-diff t)
  (global-undo-tree-mode))
#+END_SRC

While changing buffers or workspaces, the first thing you do is look for your cursor. Unless you know its position, you
can not move it efficiently. Every time you change buffers, the current position of your cursor will be briefly
highlighted now.

#+BEGIN_SRC emacs-lisp
(use-package beacon
  :if (skj/current-feature-required-p)
  :defer 1
  :diminish beacon-mode
  :config (beacon-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'editing)
#+END_SRC

*** Default Faces

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'faces "Default Faces")
#+END_SRC

These are useful things to have around, specifically it's valuable to track the base font details. For development I
always use [[https://fonts.google.com/specimen/Fira+Code][Fira Code]].

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defcustom skj/default-font-family "Fira Code"
    "Default code/monospace font family."
    :tag "Default font family"
    :type 'string
    :group 'skj)

  (defcustom skj/default-font-weight 'light
    "Default code/monospace font weight."
    :type '(radio (const :tag "Light" light)
                  (const :tag "Semi-Light" semi-light)
                  (const :tag "Normal" normal)
                  (const :tag "Semi-Bold" semi-bold)
                  (const :tag "Bold" bold))
    :tag "Default font weight"
    :group 'skj)

  (defcustom skj/default-font-size 130
    "Default code/monospace font size; in Emacs units."
    :tag "Default font size"
    :type 'integer
    :group 'skj))
#+END_SRC

Ensure the base font has relevant styling. This face is used directly in org-mode and as the parent of others.

#+BEGIN_SRC emacs-lisp
(set-italic-face-attributes 'italic)
#+END_SRC

This isn't so useful on macOS as it doesn't seem to decode weight and width correctly so I can't use Fira Code Light.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defconst default-background-color (alist-get 'base3 skj/theme-core-color-alist))
  (defconst default-foreground-color (alist-get 'base00 skj/theme-core-color-alist))

  (set-face-attribute
   'default
   nil
   :inherit nil
   :extend nil
   :stipple nil
   :background default-background-color
   :foreground default-foreground-color
   :inverse-video nil
   :box nil
   :strike-through nil
   :overline nil
   :underline nil
   :slant 'normal
   :weight skj/default-font-weight
   :height skj/default-font-size
   :width 'normal
   :foundry "nil"
   :family skj/default-font-family))
#+END_SRC

Make the menu system readable using theme colors -- the default colors after theming are kind of heinous.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (let* ((disabled-background default-foreground-color)
         (disabled-foreground (alist-get 'base1 skj/theme-core-color-alist))
         (enabled-background disabled-background)
         (enabled-foreground default-background-color)
         (selected-background (alist-get 'base02 skj/theme-core-color-alist)))
    (set-face-attribute 'tty-menu-disabled-face nil
                        :background disabled-background
                        :foreground disabled-foreground)
    (set-face-attribute 'tty-menu-enabled-face nil
                        :background enabled-background
                        :foreground enabled-foreground
                        :weight 'bold)
    (set-face-attribute 'tty-menu-selected-face nil
                        :background selected-background)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'faces)
#+END_SRC

*** Icons

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'icons)
#+END_SRC

Good to know...

#+BEGIN_SRC emacs-lisp
(if (image-type-available-p 'imagemagick)
    (message "Emacs has imagemagick support :)")
  (message "Emacs does not have imagemagick support :("))
#+END_SRC

Note that these should *all* be guarded to install *only* for windowed systems.

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p) window-system)

  (use-package all-the-icons
    :demand t
    :config (all-the-icons-completion-mode))

  (use-package all-the-icons-completion :after all-the-icons)

  (use-package all-the-icons-dired :after all-the-icons)

  (use-package all-the-icons-gnus :after all-the-icons)

  (use-package all-the-icons-ibuffer :after all-the-icons)

  (use-package all-the-icons-ivy :after all-the-icons)

  (use-package all-the-icons-ivy-rich :after all-the-icons)

  (use-package all-the-icons-nerd-fonts :after all-the-icons))
#+END_SRC

To ensure supporting fonts are installed on your system, execute: /=M-x all-the-icons-install-fonts<RET>=/

The VSCode common icons.

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p) window-system)

  (use-package vscode-icon
    :commands (vscode-icon-for-file)))
#+END_SRC

Now enable modes using the icons above.

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p) window-system)

  (use-package mode-icons
    :config (mode-icons-mode))

  (use-package major-mode-icons
    :config (major-mode-icons-mode 1)))
#+END_SRC

Nerd Icons -- An alternative to /all-the-icons/.

Requires the following fonts from [[https://www.nerdfonts.com/font-downloads][Nerd Font Downloads]]:

- =FiraCode= - family: "FiraCode Nerd Font Mono"
- =NerdFontsSymbolsOnly= - family: "Symbols Nerd Font Mono"

#+BEGIN_SRC emacs-lisp :noeval
(when (and (skj/current-feature-required-p) window-system)

  (use-package nerd-icons
    :custom
    ;; This should be a safe back-up font
    ;; (nerd-icons-font-family "Symbols Nerd Font Mono")
    (nerd-icons-font-family "FiraCode Nerd Font Mono"))

  (use-package nerd-icons-completion :after nerd-icons)

  (use-package nerd-icons-dired :after nerd-icons)

  (use-package nerd-icons-ibuffer :after nerd-icons)

  (use-package nerd-icons-ivy-rich :after nerd-icons)

  (use-package all-the-icons-nerd-fonts
    :after (all-the-icons nerd-icons)))
#+END_SRC

Return code point of =glyph-name=. This function is interactive function, so you can call it by =M-x fontawesome=. However,
=M-x counsel-fontawesome= inserts fontawesome glyph with ivy interface. The issue is that the two front-end read
frameworks supported, helm and ivy, are mixed in the same file and I don't want to install helm just for this.

#+BEGIN_SRC emacs-lisp
(when nil ;(skj/current-feature-required-p)
  (use-package fontawesome)

  (require 'cl-lib)
  (require 'fontawesome-data)

  (defsubst fontawesome--font-names ()
    (cl-loop for (name . _code) in fontawesome-alist
             collect name))

  (defun fontawesome--completing-read ()
    (let ((comp-func (if ido-mode 'ido-completing-read 'completing-read)))
      (funcall comp-func "Font name: " (fontawesome--font-names) nil t)))

  (defun fontawesome (font-name)
    "Return fontawesome code point"
    (interactive
     (list (fontawesome--completing-read)))
    (assoc-default font-name fontawesome-alist))

  (defun fontawesome--propertize (glyph)
    (propertize glyph
                'face '(:family "FontAwesome" :height 1.5)))

  (defun fontawesome--construct-candidates ()
    (mapcar (lambda (fontawesome)
              (cons (concat (car fontawesome)
                            " -> "
                            (fontawesome--propertize
                             (cdr fontawesome)))
                    (cdr fontawesome)))
            fontawesome-alist))

  (defun fontawesome---source (fontawesome-alist)
    (helm-build-sync-source "Select FontAwesome Icon: "
                            :candidates (fontawesome--construct-candidates)
                            :action (lambda (candidate)
                                      (insert (fontawesome--propertize candidate)))
                            :candidate-number-limit 9999))

  (defun counsel-fontawesome ()
    (interactive)
    (require 'ivy)
    (ivy-read "Font awesome> " (fontawesome--construct-candidates)
              :action (lambda (font)
                        (insert (cdr font))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'icons)
#+END_SRC

*** Mode Line

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'mode-line)
#+END_SRC

I like to keep this pretty simple, certainly no powerline!. Both of these packages are builtin.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package time
    :ensure nil
    :defer 1
    :custom
    (display-time-string-forms
     '((propertize (concat " " 24-hours ":" minutes " "))))
    (display-time-default-load-average nil)
    (world-clock-list '(("Etc/UTC" "UTC")
                               ("America/Los_Angeles" "Seattle")
                               ("America/New_York" "New York")
                               ("Europe/Athens" "Athens")
                               ("Pacific/Auckland" "Auckland")
                               ("Asia/Shanghai" "Shanghai")))
    (world-clock-time-format "%a, %d %b %I:%M %p %Z")
    :config
    (display-time-mode t))

  (use-package simple
    :ensure nil
    :defer 1
    :config
    (line-number-mode t)
    (column-number-mode t)))
    #+END_SRC

For battery mode, simplify the usual and use Unicode characters as icons, it makes it easier to find.

#+BEGIN_SRC emacs-lisp
(use-package battery
  :ensure nil
  :defer 2
  :if (skj/current-feature-required-p)
  :custom
  (when (functionp 'battery-status-function)
    (cond ((string= "AC" (battery-format "%L" (funcall battery-status-function)))
           (setq battery-mode-line-format " "))
          ((string-match-p "N/A" (battery-format "%B" (battery-status-function)))
           (setq battery-mode-line-format " "))
          (t
           (setq battery-mode-line-format ":%p%% "))))
  :config
  (display-battery-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'mode-line)
#+END_SRC

*** Hydra

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'hydra)
#+END_SRC

Just started with [[https://github.com/abo-abo/hydra][Hydra]], so there are hydra defined in sections below.

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :if (skj/current-feature-required-p)
  :defer 3)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package pretty-hydra
    :after hydra
    :defer 3)

  (use-package major-mode-hydra
    :after pretty-hydra
    :defer 3
    :bind
    ("M-SPC" . major-mode-hydra)))
#+END_SRC

While the idea of =use-package-hydra= is nice, defining a Hydra as a part of the =use-package= is very clunky.

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'hydra)
#+END_SRC

*** Files and Buffers

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'buffers "Files and Buffers")
#+END_SRC

[[https://www.emacswiki.org/emacs/RecentFiles][Recentf]] is a minor mode that builds a list of recently opened files. This list is automatically saved across sessions on
exiting Emacs - you can then access this list through a command or the menu.

#+BEGIN_SRC emacs-lisp
(use-package recentf
  :if (skj/current-feature-required-p)
  :defer 1
  :bind ("C-x C-r" . recentf-open-files)
  :custom
  (recentf-max-menu-items 100)
  (recentf-max-saved-items 100)
  :init
  (recentf-mode))
#+END_SRC

[[https://www.emacswiki.org/emacs/IbufferMode][Ibuffer]] is an advanced replacement for BufferMenu, which lets you operate on buffers much in the same manner as Dired.
The most important Ibuffer features are highlighting and various alternate layouts. Ibuffer is part of Emacs since
version 22.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package ibuffer)

  (use-package ibuffer-sidebar
    :after ibuffer
    :bind ("C-x C-b" . ibuffer-sidebar-toggle-sidebar))

  (use-package all-the-icons-ibuffer
    :if window-system
    :after ibuffer
    :hook
    (ibuffer-mode . all-the-icons-ibuffer-mode)))
#+END_SRC

This [[https://github.com/lukhas/buffer-move][package]] is for lazy people wanting to swap buffers without typing /=C-x b=/ on each window. Wind-move allows for
navigating with shift arrow keys.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package buffer-move)

  (use-package windmove
    :ensure nil
    :defer nil
    :config
    (windmove-default-keybindings)))
#+END_SRC

This [[https://github.com/beacoder/everlasting-scratch][package]] provides a global minor mode =everlasting-scratch-mode= that causes the scratch buffer to respawn after it's
killed and with its content restored.

#+BEGIN_SRC emacs-lisp
(use-package everlasting-scratch
  :if (skj/current-feature-required-p)
  :hook (after-init))
#+END_SRC

Finally, set the default buffer mode to ~text-mode~.

#+BEGIN_SRC emacs-lisp
(use-package text-mode
  :ensure nil
  :if (skj/current-feature-required-p)
  :defer nil
  :after simple
  :hook
  (text-mode . auto-fill-mode)
  :config
  (setq-default major-mode 'text-mode))
#+END_SRC

This enables left-hand line numbers, the types are ~'relative~, ~'visual~, and ~t~ for absolute.

#+BEGIN_SRC emacs-lisp
(use-package simple
  :ensure nil
  :if (skj/current-feature-required-p)
  :defer nil
  :config
  (setq display-line-numbers-type 'visual)
  (display-line-numbers-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'buffers)
#+END_SRC

*** Multiple Cursors

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'multiple-cursors)
#+END_SRC

[[https://github.com/magnars/multiple-cursors.el][Multiple cursors]] for Emacs.

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors :if (skj/current-feature-required-p))
#+END_SRC

When you have an active region that spans multiple lines, the following will add a cursor to each line:

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (global-set-key (kbd "M-n e l") 'mc/edit-lines)
  (global-set-key (kbd "M-n e a") 'mc/edit-beginnings-of-lines)
  (global-set-key (kbd "M-n e e") 'mc/edit-ends-of-lines))
#+END_SRC

When you want to add multiple cursors not based on continuous lines, but based on keywords in the buffer, use:

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (global-set-key (kbd "C-M-<mouse-1>") 'mc/toggle-cursor-on-click)

  (global-set-key (kbd "M-n SPC") 'set-rectangular-region-anchor)
  (global-set-key (kbd "M-n m n") 'mc/mark-next-like-this)
  (global-set-key (kbd "M-n m p") 'mc/mark-previous-like-this)
  (global-set-key (kbd "M-n m m") 'mc/mark-more-like-this)
  (global-set-key (kbd "M-n m a") 'mc/mark-all-like-this))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (pretty-hydra-define hydra-mc
    (:color blue :quit-key "q" :title " Multiple Cursors")
    ("Edit"
     (("e"   mc/edit-lines                 "Edit Lines")
      ("a"   mc/edit-beginnings-of-lines   "Edit at Start of Lines")
      ("e"   mc/edit-ends-of-lines         "Edit at End of Lines"))
     "Mark"
     (("n"   mc/mark-next-like-this        "Next Like This")
      ("p"   mc/mark-previous-like-this    "Previous Like This")
      ("m"   mc/mark-more-like-this        "More Like This")
      ("a"   mc/mark-all-like-this         "All like this"))
     "Special"
     (("SPC" set-rectangular-region-anchor "Set Rectangular Anchor")
      ("s"   mc/sort-regions               "Sort Regions")
      ("r"   mc/reverse-regions            "Reverse Regions")
      ("v"   mc/vertical-align             "Vertical Align"))))

  (bind-key "M-n m h" 'hydra-mc/body))
#+END_SRC

This package contains [[https://github.com/knu/mc-extras.el][extra functions]] for multiple-cursors mode.

#+BEGIN_SRC emacs-lisp
(use-package mc-extras
  :if (skj/current-feature-required-p)
  :after multiple-cursors)
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'multiple-cursors)
#+END_SRC

*** Notifications
:PROPERTIES:
:CUSTOM_ID: core-ui-notifications
:END:

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'notifications)
#+END_SRC

[[https://github.com/jwiegley/alert][Alert]] is a Growl-workalike for Emacs which uses a common notification interface and multiple, selectable "styles", whose
use is fully customizable by the user.

#+BEGIN_SRC emacs-lisp
(use-package alert
  :if (skj/current-feature-required-p)
  :custom
  (alert-fade-time 10) ;; seconds
  (alert-default-style (if (system-mac-p)
                            'osx-notifier
                          'notifications)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'notifications)
#+END_SRC

*** Small Stuff

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'misc)
#+END_SRC

Set fringes to appear only on the left-hand side in graphical windows.

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p) window-system)

  (use-package fringe
    :ensure nil
    :config
    ;; set left and right to 10px width
    (fringe-mode 10)))
    #+END_SRC

Using multiple side-by-side windows is a great way to utilize the large high-resolution displays that exists today. This
[[https://github.com/Lindydancer/multicolumn][package]] provides the /missing features/ of Emacs to create a side-by-side layout, to navigate efficiently, and to manage
the windows.

#+BEGIN_SRC emacs-lisp
(use-package multicolumn
  :if (skj/current-feature-required-p))
#+END_SRC

In OS X 10.9, each monitor is a separate space. If you want to stretch an Emacs frame across multiple monitors, you can
change this in "System Preferences -> Mission Control -> Displays have separate Spaces".

#+BEGIN_SRC emacs-lisp
(use-package mouse
  :ensure nil
  :if (skj/current-feature-required-p)
  :defer nil
  :custom
  (mouse-wheel-follow-mouse 't)
  (mouse-wheel-scroll-amount '(1 ((shift) . 1)))
  :config
  (xterm-mouse-mode t)
  (global-set-key [mouse-4] (lambda ()
                              (interactive)
                              (scroll-down 1)))
  (global-set-key [mouse-5] (lambda ()
                              (interactive)
                              (scroll-up 1))))
#+END_SRC

This [[https://github.com/ruediger/qrencode-el][package]] provides two user facing interactive functions, that will encode text into a QR Code and show it in a
separate buffer.

- ~qrencode-region~ :: Shows the current selection as a QR Code.
- ~qrencode-url-at-point~ :: Encode URL at point as QR Code.

QR Codes are rendered as Unicode text, but there is an option to export them as bitmap (NetPBM format). There are also
some public elisp library functions to generate QR Codes for use in other elisp code.

#+BEGIN_SRC emacs-lisp
(use-package qrencode)
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'misc)
(skj/feature-end 'core-ui)
#+END_SRC

** Completion UI Settings

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'completion "Completion UI Settings")
#+END_SRC

*** Ivy

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'ivy)
#+END_SRC

The guidance is to do all this /before/ installing the [[https://github.com/abo-abo/swiper][ivy]] packages themselves.

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p) window-system)

  (use-package all-the-icons-ivy
    :config (all-the-icons-ivy-setup))

  (use-package all-the-icons-ivy-rich
    :init (all-the-icons-ivy-rich-mode 1)))
#+END_SRC

Historian stores the results of completing-read and similar functions persistently. This provides a way to give
completion candidates that are more frequently or more recently used a better position in the candidates list.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package historian)

  (use-package ivy-historian))
#+END_SRC

Note that ~historian~ saves files in ~historian-save-file~, be default ="~/.emacs.d/.historian"=, which if it is ever
horked (and contains only =nil=) nothing works properly. A call to ~historian-clear~ should reset.

Here's Ivy itself.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package ivy
    :diminish ivy-mode
    :custom
    (enable-recursive-minibuffers t)
    (ivy-count-format "(%d/%d) ")
    (ivy-use-virtual-buffers t)
    (ivy-wrap t)
    :init
    (ivy-mode +1)
    (historian-mode +1)
    :config
    (ivy-historian-mode +1)
    (global-set-key (kbd "C-c v") 'ivy-push-view)
    (global-set-key (kbd "C-c V") 'ivy-pop-view)
    (global-set-key (kbd "C-c C-r") 'ivy-resume)
    (global-set-key (kbd "C-x b") 'ivy-switch-buffer))

  (use-package swiper
    :ensure nil
    :after ivy
    :config
    (global-set-key (kbd "C-s") 'swiper-isearch)))
#+END_SRC

Do these *after* Ivy. Note that the Hydra can is invoked in any Ivy minibuffer with the keys =C-o=.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package ivy-hydra
    :commands (hydra-ivy/body ivy-hydra-read-action)
    :after (ivy hydra))

  (use-package ivy-rich
    :after ivy
    :pin melpa
    :init
    (ivy-rich-mode 1)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package ivy-pass
    :after (password-store ivy)
    :bind ("M-p i" . ivy-pass)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'ivy)
#+END_SRC

*** Counsel

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'counsel)
#+END_SRC

[[https://github.com/abo-abo/swiper][Counsel]] integrations; note that while ~counsel-osx-app~ looks good I didn't use
it.

#+BEGIN_SRC emacs-lisp
(use-package counsel
  :if (skj/current-feature-required-p)
  :after ivy
  :diminish counsel-mode
  :custom
  (counsel-find-file-ignore-regexp "\\(?:\\`\\|[/\\]\\)\\(?:[#.]\\)")
  :config
  ;; Ivy-based interface to standard commands
  (global-set-key (kbd "M-x") 'counsel-M-x)
  (global-set-key (kbd "C-x C-f") 'counsel-find-file)
  (global-set-key (kbd "M-y") 'counsel-yank-pop)
  (global-set-key (kbd "<f1> f") 'counsel-describe-function)
  (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
  (global-set-key (kbd "<f1> l") 'counsel-find-library)
  (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
  (global-set-key (kbd "<f2> u") 'counsel-unicode-char)
  (global-set-key (kbd "<f2> j") 'counsel-set-variable)
  ;; Ivy-based interface to shell and system tools
  (global-set-key (kbd "C-c c") 'counsel-compile)
  (global-set-key (kbd "C-c g") 'counsel-git)
  (global-set-key (kbd "C-c j") 'counsel-git-grep)
  (global-set-key (kbd "C-c L") 'counsel-git-log)
  (global-set-key (kbd "C-c k") 'counsel-rg)
  (global-set-key (kbd "C-c n") 'counsel-fzf)
  (global-set-key (kbd "C-x l") 'counsel-locate)
  (global-set-key (kbd "C-c J") 'counsel-file-jump)
  ;;
  (global-set-key (kbd "C-c b") 'counsel-bookmark)
  (global-set-key (kbd "C-c d") 'counsel-descbinds)
  (global-set-key (kbd "C-c o") 'counsel-outline)
  (global-set-key (kbd "C-c F") 'counsel-org-file)

  (counsel-mode 1))
#+END_SRC

Counsel interface for [[https://github.com/sharkdp/fd][fd]]. If you have =fd= installed you can add the following:

- =M-x counsel-fd-dired-jump= to jump to a subdirectory under current directory.
- =M-x counsel-fd-file-jump= to jump to a file under current directory.

#+BEGIN_SRC emacs-lisp
(use-package counsel-fd
  :if (skj/current-feature-required-p)
  :ensure-system-package fd
  :after counsel)
#+END_SRC

Search the web with dynamic suggestions and browse the results – all from the comfort of Emacs and ivy.

1. ~counsel-web-suggest~ prompts for a search string, displays dynamic suggestions, and passes the chosen suggestion to:
2. ~counsel-web-search~, which takes a search string and browses a search candidate.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package counsel-web
    :after counsel
    :custom
    (counsel-web-engine 'google)
    (counsel-web-search-action #'browse-url)
    (counsel-web-search-alternate-action #'w3m))

  ;; Define "C-c w" as a prefix key.
  (defvar counsel-web-map
    (let ((map (make-sparse-keymap "counsel-web")))
      (define-key map (kbd "w") #'counsel-web-suggest)
      (define-key map (kbd "s") #'counsel-web-search)
      (define-key map (kbd ".") #'counsel-web-thing-at-point)
      map))

  (global-set-key (kbd "C-c w") counsel-web-map))
  #+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'counsel)
#+END_SRC

*** Company

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'company)
#+END_SRC

[[https://company-mode.github.io/][Company]] is a text completion framework for Emacs. The name stands for /complete anything/. It uses pluggable back-ends and
front-ends to retrieve and display completion candidate.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package company
    :diminish company-mode
    :custom
    (company-files-exclusions '(".git/" ".DS_Store"))
    (company-idle-delay 0)
    (company-show-numbers t)
    (company-tooltip-align-annotations t)
    (company-tooltip-annotation-padding 1)
    (company-tooltip-flip-when-above t)
    (company-tooltip-limit 4)
    (company-tooltip-margin 2)
    :init
    (global-company-mode)
    :config
    (setq company-format-margin-function #'company-text-icons-margin))

  (use-package company-quickhelp
    :if window-system
    :after company))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'company)
#+END_SRC

*** Quick Help

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'quickhelp)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when nil ;(skj/current-feature-required-p)

  (use-package company-quickhelp
    :after company
    :config (company-quickhelp-mode))

  (use-package company-quickhelp-terminal
    :after company-quickhelp-
    :custom
    (company-quickhelp-terminal-mode 1)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'quickhelp)
#+END_SRC

*** Prescient

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'prescient)
#+END_SRC

[[https://company-mode.github.io/][prescient.el]] is a library which sorts and filters lists of candidates, such as appear when you use a package like Ivy or
Company. Extension packages such as =ivy-prescient.el= and =company-prescient.el= adapt the library for usage with various
frameworks.

For some reason the ~:config~ section of these has been a problem, not sure why but it's not triggering correctly and so
the mode functions are simply called after the ~use-package~ calls below.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package prescient
    :commands prescient-persist-mode)

  (use-package ivy-prescient)

  (use-package company-prescient)

  (ivy-prescient-mode 1)
  (prescient-persist-mode 1)
  (company-prescient-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'prescient)
(skj/feature-end 'completion)
#+END_SRC

** Visual Regex

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'visual-regex)
#+END_SRC

The two packages [[https://github.com/benma/visual-regexp.el][visual-regexp]] and [[https://github.com/benma/visual-regexp-steroids.el/][visual-regexp-steroids]] provide advanced regex query and replace functions with live
visual feedback directly in the buffer. The difference is that the former uses Emacs regexp and the latter uses more
modern (Python and [[https://github.com/joddie/pcre2el][pcre2el]]) engines -- no more escaped group parentheses, and other goodies.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package visual-regexp
    :commands (vr/replace vr/query-replace vr/mc-mark)
    :init
    (define-key global-map (kbd "C-c r") #'vr/replace)
    (define-key global-map (kbd "C-c q") #'vr/query-replace)
    ;; if you use multiple-cursors, this is for you:
    (define-key global-map (kbd "C-c m") #'vr/mc-mark))

  (use-package visual-regexp-steroids
    :after visual-regexp
    :commands (vr/isearch-backward vr/isearch-forward)
    :init
    (define-key global-map (kbd "C-c C-r") #'vr/isearch-backward)
    (define-key global-map (kbd "C-c C-s") #'vr/isearch-forward)))
#+END_SRC

Also see the following interesting regex packages:

- [[https://github.com/mkcms/interactive-align][ialign]] :: To use it, mark a region and then call =ialign. You can enter a regexp in the minibuffer that will be passed
  to =align-regexp= command.

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'visual-regex)
#+END_SRC

** O/S Specific UI Settings

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'os-ui "O/S Specific UI Settings")
#+END_SRC

*** macOS Specifics

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'macos "macOS Specifics")
#+END_SRC

- =osx-lib=: An Emacs package with functions and commands for interacting with macOS.
- =osx-plist=: This is a simple parser for macOS plist files. The main entry points are =osx-plist-parse-file= and
  =osx-plist-parse-buffer=.
- =osx-trash=: Make =delete-by-moving-to-trash= do what you expect it to do on macOS.
- =reveal-in-osx-finder=: Provides the function =reveal-in-osx-finder= for file and dired buffers.

#+BEGIN_SRC emacs-lisp
(when (and (system-mac-p) (skj/current-feature-required-p))

  (use-package osx-lib)

  (use-package osx-plist)

  (use-package osx-trash
    :config (osx-trash-setup))

  (use-package reveal-in-osx-finder))
#+END_SRC

Re-mapping the macos keyboard for super is just a nightmare.

#+BEGIN_SRC emacs-lisp
(when (and (system-mac-p) (skj/current-feature-required-p))

  (setq mac-command-modifier 'super
        mac-control-modifier 'control
        mac-option-modifier 'meta))
;; mac-right-command-modifier 'super
;; mac-right-option-modifier 'meta
;; ns-alternate-modifier mac-option-modifier
;; ns-command-modifier mac-command-modifier
;; ns-function-modifier 'hyper
;; ns-right-command-modifier mac-right-command-modifier))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'macos)
(skj/feature-end 'os-ui)
#+END_SRC

** Initial Flycheck Settings

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'flycheck "Initial Flycheck Settings")
#+END_SRC

Install the base [[https://www.flycheck.org/en/latest/][Flycheck]] package, and any generic extensions such as [[https://github.com/flycheck/flycheck-inline][flycheck-inline]].

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package flycheck
    :hook (after-init . global-flycheck-mode)
    :diminish flycheck-mode)

  (use-package flycheck-indicator
    :after flycheck
    :hook (flycheck-mode . flycheck-indicator-mode))

  (use-package flycheck-inline
    :hook (flycheck-mode . flycheck-inline-mode)
    :diminish flycheck-inline-mode
    :custom
    (flycheck-inline-display-function
      (lambda (msg pos err)
        (let* ((ov (quick-peek-overlay-ensure-at pos))
               (contents (quick-peek-overlay-contents ov)))
          (setf (quick-peek-overlay-contents ov)
                (concat contents (when contents "\n") msg))
          (quick-peek-update ov)))
      flycheck-inline-clear-function #'quick-peek-hide)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'flycheck)
#+END_SRC

** Shell & Terminal Settings

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'shell "Shell & Terminal Settings")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package sh-script
    :ensure nil
    :mode ("\\.zsh\\'" . sh-mode))

  (use-package term
    :ensure nil
    :custom
    (term-prompt-regexp "^[^#$%>\n]*[#$%>] *")))
#+END_SRC

Emacs-libvterm, =vterm=, is fully-fledged terminal emulator inside GNU Emacs based on libvterm, a C library. As a result
of using compiled code (instead of elisp), emacs-libvterm is fully capable, fast, and it can seamlessly handle large
outputs.

#+BEGIN_SRC emacs-lisp
(use-package vterm
  :if (skj/current-feature-required-p)
  :custom
  (vterm-shell "zsh")
  (vterm-max-scrollback 10000))
#+END_SRC

Company mode completion backends for your shell scripting. Package =company-shell= offers 3 backends for 3 different sources:

- =company-shell= :: providing completions for binaries that are found on your $PATH
- =company-shell-env= :: providing completions for environment variables based on the env command
- =company-fish-shell= :: providing completions for fish-shell’s functions, both builtin as well as user-defined

#+BEGIN_SRC emacs-lisp
(use-package company-shell
  :if (skj/current-feature-required-p)
  :after company
  :config
  (add-to-list 'company-shell-modes 'zsh-mode)
  (add-to-list 'company-backends '(company-shell company-shell-env) t))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'shell)
#+END_SRC

** Remote (TRAMP) Editing

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'tramp "Remote (TRAMP) Editing")
#+END_SRC

Setup the builtin [[https://www.gnu.org/software/tramp/][TRAMP]] module, not much to see here, but it enables the extended file syntax such as:

- =/ssh:user@host:/path/to/file=
- =/ssh:localhost:= opens a remote connection to yourself on the local host
- =/sudo::/path/to/file= open a file under sudo
- =/ssh:user@host|sudo::/path/to/file=

#+BEGIN_SRC emacs-lisp
(use-package tramp
  :ensure nil
  :defer 2
  :if (skj/current-feature-required-p)
  :custom
  (tramp-default-method "ssh"))
#+END_SRC

Open your =~/.ssh/config= with counsel interface and you can connect your server with tramp. If the default shell of the
server is zsh it is recommended to connect with bash.

#+BEGIN_SRC emacs-lisp
(use-package counsel-tramp
  :if (skj/current-feature-required-p)
  :after (counsel tramp)
  :bind
  ("C-c s" . counsel-tramp)
  :config
  (setenv "SHELL" (executable-find "bash")))
#+END_SRC

=docker-tramp= offers a TRAMP method for Docker containers; it adds the TRAMP method docker to access running containers.

=C-x C-f /docker:user@container:/path/to/file=

#+BEGIN_SRC emacs-lisp
(use-package docker-tramp
  :if (skj/current-feature-required-p)
  :after tramp)
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'tramp)
#+END_SRC

** Version Control

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'vcs "Version Control")
#+END_SRC

Version control is a basic human right, and hopefully this gets things pretty damn close to perfect.

*** Core Git

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'git)
#+END_SRC

Git support is built into Emacs as =vc-git=, so this section is *only* to run the =ensure-system-package=.

#+BEGIN_SRC emacs-lisp
(use-package vc-git
  :ensure nil
  :ensure-system-package git)

(use-package subr-x
  :ensure nil)

(defun skj/git-command (command &optional in-directory args)
  (if (or (not (stringp command)) (string-empty-p command))
      (init-message "Error: command not a valid string %S" command)
    (let ((git-binary (executable-find "git"))
          (default-directory (or in-directory skj/project-root-dir)))
      (call-process (string-join (append (list git-binary command) args))))))

(defun skj/git-clone (remote-url &optional directory args)
  (if (and (not (null directory)) (file-directory-p directory))
      (init-message "git-clone directory exists %S, skipping" directory)
    (skj/git-command "clone" directory args)))
#+END_SRC

Package =mo-git-blame= -- An interactive, interative /git blame/ mode for Emacs.

#+BEGIN_SRC emacs-lisp
(use-package mo-git-blame
  :if (skj/current-feature-required-p)
  :after git
  :bind
  ("C-c C-g c" . mo-git-blame-current)
  ("C-c C-g f" . mo-git-blame-file))
#+END_SRC

Package =git-link= -- Interactive Emacs functions that create URLs for files and commits in GitHub, Bitbucket, GitLab, ...
repositories.

#+BEGIN_SRC emacs-lisp
(use-package git-link
  :if (skj/current-feature-required-p)
  :bind
  ("C-c C-g l" . git-link)
  ("C-c C-g C-l" . git-link-commit)
  :after git)
#+END_SRC

Package =git-timemachine= -- Walk through git revisions of a file. Visit a git-controlled file and issue =M-x
git-timemachine= (or bind it to a keybinding of your choice). If you just need to toggle the time machine you can use =M-x
git-timemachine-toggle=.

#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
  :if (skj/current-feature-required-p)
  :after git
  :bind
  ("C-c C-g h" . git-timemachine)
  :custom
  (git-timemachine-show-minibuffer-details t))
#+END_SRC

Package =git-modes= -- Emacs major modes for various Git configuration files: =gitattributes-mode=, =gitconfig-mode=, and
=gitconfig-mode=.

#+BEGIN_SRC emacs-lisp
(use-package git-modes
  :if (skj/current-feature-required-p)
  :after git)
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'git)
#+END_SRC

*** Magit

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'magit)
#+END_SRC

Magit is a complete text-based user interface to Git. It fills the glaring gap between the Git command-line interface
and various GUIs, letting you perform trivial as well as elaborate version control tasks with just a couple of mnemonic
key presses. Magit looks like a prettified version of what you get after running a few Git commands but in Magit every
bit of visible information is also actionable to an extent that goes far beyond what any Git GUI provides and it takes
care of automatically refreshing this output when it becomes outdated.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package magit
    :after git
    :custom
    (git-commit-fill-column 72)
    (magit-completing-read-function 'ivy-completing-read)
    :init
    (setq-default magit-git-executable (executable-find "git")))

  (use-package magit-lfs
    :after magit)
  
  (use-package magit-filenotify
    :after magit
    :hook
    (after-save . magit-after-save-refresh-status)))
#+END_SRC

This package displays keyword entries from source code comments and Org files in the Magit status buffer. Activating an
item jumps to it in its file. By default, it uses keywords from =hl-todo= ([[https://github.com/tarsius/hl-todo][highlights TODO]]), minus a few (like "NOTE").

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package hl-todo
    :if (skj/current-feature-required-p)
    :diminish hl-todo-mode
    :hook (prog-mode . hl-todo-mode))

  ;; This causes an error "user-error: Flycheck mode disabled"
  ;; which then causes `set-auto-mode' and `normal-mode' to fail,
  ;; chaos then ensues.
  ;;
  ;; (use-package flycheck-hl-todo
  ;;   :after (flycheck hl-todo)
  ;;   :defer 5 ; Need to be initialized after the rest of checkers
  ;;   :config
  ;;   (flycheck-hl-todo-setup)
  ;;   (add-hook 'hl-todo-mode-hook
  ;;             (lambda ()
  ;;               (setq flycheck-hl-todo-enabled hl-todo-mode)
  ;;               ;; Force flycheck update
  ;;               (flycheck-buffer))))

  (use-package magit-todos
    :after (hl-todo magit)
    :hook (magit-mode . magit-todos-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'magit)
#+END_SRC

*** Forge Integration

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'forge "Magit Forge Integration")
#+END_SRC

To start using Forge in a certain repository visit the Magit status buffer for that repository and type =f n=
(=forge-pull=). Alternatively, you can use /=M-x forge-add-repository=/, which makes it possible to add a forge repository
without pulling all topics and even without having to clone the respective Git repository.

#+BEGIN_SRC emacs-lisp
(use-package forge
  :if (skj/current-feature-required-p)
  :after magit)
#+END_SRC

Forge uses the Ghub package to access the APIs of supported Git forges. How this works and how to create and store a
token is documented in the magit [[https://magit.vc/manual/ghub.html#Getting-Started][Getting Started]] section.

- ~gh-notify~ -- A veneer for Magit/Forge GitHub notifications

Review Github pull requests from Emacs. This package provides the following entrypoint:

- =M-x pr-review=: open a PR with given URL.
- =M-x pr-review-notification=: list github notifications in a buffer, and open PRs from it.
- =M-x pr-review-search-open=: search in github and select a PR from search result.
- =M-x pr-review-search=: like above, but list results in a buffer.

#+BEGIN_SRC emacs-lisp
(use-package pr-review
  :if (skj/current-feature-required-p)
  :after (magit ghub)
  :config
  (add-to-list 'browse-url-default-handlers
             '(pr-review-url-parse . pr-review-open-url)))
#+END_SRC

Automatically set ~bug-reference-url-format~ and enable ~bug-reference-prog-mode~ buffers from Github repositories.

#+BEGIN_SRC emacs-lisp
(use-package bug-reference-github
  :if (skj/current-feature-required-p)
  :after magit
  :hook (prog-mode . bug-reference-github-set-url-format))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'forge)
#+END_SRC

*** Diff Highlighting

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'diff "Diff Highlighting")
#+END_SRC

`diff-hl-mode' highlights uncommitted changes on the side of the window (using the /fringe/, by default), allows you to
jump between the hunks and revert them selectively.

#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :if (skj/current-feature-required-p)
  :after magit
  :hook ((magit-pre-refresh . diff-hl-magit-pre-refresh)
         (magit-post-refresh . diff-hl-magit-post-refresh))
  :config (global-diff-hl-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package magit-diff-flycheck
  :if (skj/current-feature-required-p)
  :after (flycheck magit))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'diff)
#+END_SRC

*** iBuffer Integration

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'ibuffer "iBuffer Integration")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package ibuffer-vc
    :after ibuffer
    :hook
    (ibuffer . (lambda ()
                 (ibuffer-vc-set-filter-groups-by-vc-root)
                 (unless (eq ibuffer-sorting-mode 'alphabetic)
                   (ibuffer-do-sort-by-alphabetic)))))

  (use-package ibuffer-git
    :after ibuffer))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'ibuffer)
#+END_SRC

*** Code Reviews

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'code-review)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package code-review
  :if (skj/current-feature-required-p))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'code-review)
(skj/feature-end 'vcs)
(skj/feature-end 'generic)
#+END_SRC

** Abbrev and Snippet Support

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'snippets "Snippet Support")
#+END_SRC

*** Abbrevs

#+BEGIN_SRC emacs-lisp
(use-package abbrev
  :ensure nil
  :diminish abbrev-mode
  :hook text-mode
  :bind
  (("C-x a l" . list-abbrevs)
   ("C-x a e" . edit-abbrevs)
   ("C-x a r" . expand-region-abbrevs)
   ("C-x a u" . unexpand-abbrevs)
   ("C-x a !" . abbrev-suggest-show-report))
  :custom
  (abbrev-file-name  (concat-path user-emacs-directory "abbrev_defs")
                     "tell emacs where to read abbrev definitions from")
  (save-abbrevs 'silently "save abbrevs when files are saved")
  (abbrev-suggest t "Enable abbrev suggestions")
  ;; abbrev-suggest-hint-threshold
  ;; abbrev-suggest-show-report
  :config
  (if (file-exists-p abbrev-file-name)
      (quietly-read-abbrev-file)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package dabbrev
  :ensure nil
  :custom
  ;; dabbrev-ignored-buffer-names
  ;; dabbrev-ignored-buffer-regexps
  (dabbrev-check-all-buffers t))
#+END_SRC

*** Snippet UI

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defconst skj/snippet-default-dir
    (concat-path user-emacs-directory "snippets"))
  
  (defcustom skj/snippet-repo-dir (concat-path skj/project-root-dir "emacs-snippets")
    "Snippet repository's local path."
    :tag "Snippet repository path"
    :group 'skj
    :type 'directory)

  (defun skj/snippets-initialize ()
    "Load my local snippets directories."
    ;; NOTE: we add the symbol `yasnippet-snippets-dir' rather than its
    ;; value, so that yasnippet will automatically find the directory
    ;; after this package is updated (i.e., moves directory).
    (add-to-list 'yas-snippet-dirs 'skj/snippet-default-dir t)
    (yas-load-directory skj/snippet-default-dir t)
    (add-to-list 'yas-snippet-dirs 'skj/snippet-repo-dir t)
    (yas-load-directory skj/snippet-repo-dir t)))
#+END_SRC

First of all, the primary snippet tool is =yasnippet=, there are others but this one works

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :defer 3
  :if (skj/current-feature-required-p)
  :diminish yas-minor-mode
  :custom
  (yas-snippet-dirs (list skj/snippet-repo-dir skj/snippet-default-dir))
  :hook (prog-mode . yas-minor-mode)
  :config
  (skj/snippets-initialize))
#+END_SRC

Remember to execute =M-x yas-reload-all<RET>= when /any/ snippets change.

Basic snippets, pretty useful.
up
#+BEGIN_SRC emacs-lisp
(use-package yasnippet-snippets
  :defer 4
  :if (skj/current-feature-required-p)
  :after yasnippet
  :config
  (yasnippet-snippets-initialize))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when nil; (skj/current-feature-required-p)

  (pretty-hydra-define hydra-abbrev
    (:color blue :quit-key "q" :title " Abbrevs/Snippets")
    ("Abbrev (C-x)"
     (("'"     expand-abbrev                 "Expand the abbrev before point")
      ("M-'"   abbrev-prefix-marks           "Separate a prefix from a following abbrev")
      ("a r"   expand-region-abbrevs         "Expand some or all abbrevs found in the region") 
      ("a l"   list-abbrevs                  "Edit at End of Lines")
      ("a e"   edit-abbrevs                  "Edit at End of Lines")
      ("a u"   unexpand-abbrev               "Undo the last expanded abbrev")
      ;; define-global-abbrev
      ;; add-global-abbrev
      ;; inverse-add-global-abbrev
      ;; define-mode-abbrev
      ;; add-mode-abbrev
      ;; inverse-add-mode-abbrev
      ("a !"   abbrev-suggest-show-report    "Display all suggestions in current editing session")
      ("a ?"   (customize-group 'abbrev)     "Customize")
      )
     "DAbbrev"
     (("/"     dabbrev-expand                "Expand the word before point")
      ("c /"   dabbrev-completion            "Complete the word before point")
      ("\\"   (dabbrev-expand -1)           "Expand the word looking forward")
      ("?"     (customize-group 'dabbrev)    "Customize"))
     "YASnippet"
     (("SPC" set-rectangular-region-anchor "Set Rectangular Anchor")
      ("s"   mc/sort-regions               "Sort Regions")
      ("r"   mc/reverse-regions            "Reverse Regions")
      ("v"   mc/vertical-align             "Vertical Align"))))

  (bind-key "C-x a h" 'hydra-abbrev/body))
#+END_SRC

*** Snippet Content

These are super useful, create a new =.gitignore= file and type =emacs<RET>= followed by language such as =rust<TAB>= and
maybe =macos<TAB>= for good measure.

#+BEGIN_SRC emacs-lisp
(use-package gitignore-snippets
  :defer 10
  :if (skj/current-feature-required-p)
  :after yasnippet
  :hook (gitignore-mode . yas-minor-mode)
  :config
  (gitignore-snippets-init))
#+END_SRC

These are common license files, easy to add to a new project.

#+BEGIN_SRC emacs-lisp
(use-package license-snippets
  :defer 10
  :if (skj/current-feature-required-p)
  :after yasnippet
  :hook ((prog-mode text-mode) . yas-minor-mode)
  :config
  (license-snippets-init))
#+END_SRC

*** Extensions

Package =ivy-yasnippet= lets you preview yasnippet snippets with ivy. To use it, call ~ivy-yasnippet~, or use =C-c i= in
=yas-minor-mode=.

#+BEGIN_SRC emacs-lisp
(use-package ivy-yasnippet
  :defer 10
  :if (skj/current-feature-required-p)
  :after (ivy yasnippet)
  :bind ("C-c i" . ivy-yasnippet))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'snippets)
#+END_SRC


* Org-Mode

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'org "Org-Mode")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (defgroup skj-org nil
    "Simon's org-mode settings."
    :group 'skj
    :tag "skj-org"
    :prefix "skj-org/"))
#+END_SRC

The almighty [[https://orgmode.org/][Emacs Org Mode]]!

The following are worth reading for more details and future ideas:

- http://doc.norang.ca/org-mode.html
- https://github.com/zzamboni/dot-emacs/blob/master/init.org
- https://orgmode.org/worg/org-tutorials/encrypting-files.html
- https://github.com/daviwil/emacs-from-scratch/blob/master/show-notes/Emacs-06.org
  (Agendas and Templates)
- https://orgmode.org/manual/Custom-Agenda-Views.html#Custom-Agenda-Views
- https://www.lucacambiaghi.com/vanilla-emacs/readme.html (6.4. org capture
  templates)

Flexible extensions

- [[https://github.com/gizmomogwai/org-tagged][org-tagged]]

Consider the following for writing extensions:

- [[https://hg.sr.ht/~zck/org-parser][org-parser]]
- [[http://alhassy.com/org-special-block-extras/][org-special-block-extras]]

For tables:

- ~orgtbl-aggretate~ -- Create an aggregated Org table from another one
- ~orgtbl-ascii-plot~ -- ascii-art bar plots in org-mode tables
- ~orgtbl-fit~ -- Regression-fit a column in an Org Mode table
- ~orgtbl-join~ -- Join columns from another Org Mode table
- ~orgtbl-show-header~ -- Show the header of the current column in the minibuffer
- ~chart~ builtin package -- see [[https://francismurillo.github.io/2017-04-15-Exploring-Emacs-chart-Library/][Exploring Emacs Chart Library]]

** Initial Configuration

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'config "Initial Configuration")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (setq org-directory (concat-path skj/project-root-dir "emacs-org"))

  (defun org-file-name (name &optional subdirectory)
    (concat-path
     (if subdirectory
         (concat-path org-directory (format "%s" subdirectory))
       org-directory)
     (let ((fext (file-name-extension name)))
       (if (or (string= fext "org") (string= fext "gpg"))
           name
         (concat name ".org")))))

  (use-package org
    :mode ("\\.org\\'" . org-mode)
    :custom
    (org-clone-delete-id t)
    (org-confirm-babel-evaluate nil)
    (org-cycle-include-plain-lists t)
    (org-cycle-separator-lines 2)
    (org-default-notes-file (org-file-name "inbox.org"))
    (org-edit-src-content-indentation 2)
    (org-ellipsis " ▾")
    (org-enforce-todo-checkbox-dependencies t)
    (org-enforce-todo-dependencies t)
    (org-fontify-emphasized-text t)
    (org-fontify-quote-and-verse-blocks t)
    (org-hide-emphasis-markers t)
    (org-image-actual-width '(480))
    (org-log-done 'time)
    (org-log-into-drawer t)
    (org-log-state-notes-insert-after-drawers nil)
    (org-pretty-entities t)
    (org-remove-highlights-with-change t)
    (org-src-fontify-natively t)
    (org-src-preserve-indentation t)
    (org-src-tab-acts-natively t)
    (org-startup-folded 'content)
    (org-startup-indented t)
    (org-startup-with-inline-images t)
    :hook
    (org-mode . electric-pair-local-mode)
    :config
    (require 'org-mouse)))
#+END_SRC

Put together a Hydra as there are so many Org Mode commands to try and remember!

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (pretty-hydra-define hydra-org-mode
    (:color blue :quit-key "q" :title "Org Mode")
    ("Headings"
     (("h ^" org-do-promote                    "Promote")
      ("h v" org-do-demote                     "Demote")
      ("h n" org-next-visible-heading          "Next heading")
      ("h f" org-forward-heading-same-level    "Next same-level heading")
      ("h p" org-previous-visible-heading      "Previous heading")
      ("h f" org-backward-heading-same-level   "Previous same-level heading")
      ("h u" outline-up-heading                "Up level heading")
      ("h g" org-goto                          "Goto to")
      ("h i" org-insert-heading                "Insert heading")
      ("h a" org-insert-heading-after-current  "Insert heading after")
      ("h r" org-fold-reveal                   "Reveal context"))
     "Subtrees"
     (("s ^" org-promote-subtree               "Promote")
      ("s v" org-demote-subtree                "Demote")
      ("s c" org-copy-subtree                  "Copy")
      ("s w" org-cut-subtree                   "Cut/Kill")
      ("s n" org-narrow-to-subtree             "Narrow")
      ("s r" org-refile                        "Refile")
      ("s k" org-refile-copy                   "Refile/copy")
      ("s g" org-refile-goto-last-stored       "Goto last stored")
      ("s d" org-archive-subtree-default       "Archive to default")
      ("s f" org-archive-subtree               "Archive to file")
      ("s s" org-archive-to-archive-sibling    "Archive to Sibling")
      ("s t" org-toggle-archive-tag            "Toggle archive tag")
      ("w"   widen                             "Widen buffer"))
     "Item"
     (("i c" org-capture                       "Capture New")
      ("i i" org-insert-item                   "Insert Item")
      ("i t" org-todo                          "Edit TODO")
      ("i q" org-set-tags-command              "Edit tags")
      ("i ," org-priority                      "Edit priority")
      ("i z" org-add-note                      "Add note to log")
      ("I i" org-id-get-create                 "Insert ID")
      ("I o" org-id-open                       "Open ID")
      ("I c" org-id-copy                       "Copy ID")
      ("i p" org-set-property                  "Insert property")
      ("i d" org-insert-drawer                 "Insert drawer")
      ("i #" org-update-statistics-cookies     "Update statistics")
      ("t s" org-schedule                      "Edit Scheduled")
      ("t d" org-deadline                      "Edit deadline")
      ("t q" org-time-stamp                    "Insert active")
      ("t ," org-time-stamp-inactive           "Insert inactive")
      ("t <" org-date-from-calendar            "Insert current date")
      ("c"   hydra-org-clock/body              "Clocks and timers"))
     "Agenda/column Views"
     (("v a" org-agenda                        "Agenda menu")
      ("v v" org-columns                       "Show column view")
      ("v x" org-columns-insert-dblock         "Insert view as block")
      ("v q" hydra-org-ql/body                 "Org QL"))
     "Babel"
     (("b '" org-edit-src-code                 "Edit block in own buffer")
      ("b /" org-babel-demarcate-block         "Split block at point")
      ("b e" org-babel-execute-src-block       "Execute block")
      ("b m" org-babel-execute-src-block-maybe "Execute block if in context")
      ("b s" org-babel-execute-subtree         "Execute blocks in subtree")
      ("b b" org-babel-execute-buffer          "Execute blocks in buffer")
      ("b p" org-babel-expand-src-block        "Expand block")
      ("b f" org-babel-goto-named-src-block    "Find named block")
      ("b r" org-babel-goto-named-result       "Find named result")
      ("b x" org-babel-switch-to-session       "Switch to session buffer"))))

  (defun hydra-org-mode/guard ()
    (interactive)
    (if (equal major-mode 'org-mode)
        (hydra-org-mode/body)
      (message "Hydra only relevant in org-mode")))
  
  (bind-key "<f9> o" 'hydra-org-mode/guard))
#+END_SRC

By default, =org-indent= produces an indicator =Ind= in the modeline. We use diminish to hide it. I also like to increase
the indentation a bit so that the levels are more visible.

#+BEGIN_SRC emacs-lisp
(use-package org-indent
  :if (skj/current-feature-required-p)
  :after org
  :ensure nil
  :diminish
  :custom
  (org-indent-indentation-per-level 4))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-autolist
  :if (skj/current-feature-required-p)
  :after org
  :hook (org-mode . org-autolist-mode)
  :diminish)
#+END_SRC
  
#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defconst skj/org-column-headings
    '((all-tags "%30ALLTAGS(All Tags)")
      (blocked "%1BLOCKED()")
      (category "%10CATEGORY(Category)")
      (clock-sum "%10CLOCKSUM(Actual){:}")
      (clock-sum-today "%10CLOCKSUM_T(Actual Day){:}")
      (closed "%24CLOSED(Closed on)")
      (deadline "%24DEADLINE(Deadline)")
      (effort "%10EFFORT(Effort){:}")
      (file "%15FILE")
      (item "%45ITEM(Task)")
      (name "%45ITEM(Name)")
      (priority "%1PRIORITY(!)")
      (scheduled "%24SCHEDULED(Scheduled to Start)")
      (tags "%20TAGS(Tags)")
      (todo "%10TODO(State)")))

  (defconst skj/org-column-separator " ")

  (defun skj/make-org-column-view (columns &optional column-separator)
    "Construct a column view heading string.

The argument COLUMNS is a list of symbols where each symbol is a key to
the alist in `skj/org-column-headings'. Any column symbol not
found in `skj/org-column-headings' will be discarded and the
resulting list of values combined with the value of COLUMN-SEPARATOR,
or the default value in `skj/org-column-separator'."
    (string-join
     (mapcar
      'car
      (seq-filter
       (lambda (elt) (not (null elt)))
       (mapcar
        (lambda (column) (alist-get column skj/org-column-headings))
        columns)))
     (or column-separator skj/org-column-separator))))
#+END_SRC

Add the /official/ [[https://orgmode.org/worg/org-contrib/][contributed]] packages for =org-mode=.

#+BEGIN_SRC emacs-lisp
(use-package org-contrib
  :if (skj/current-feature-required-p)
  :after org)
#+END_SRC

The only problem with hiding emphasis markers is that rich text becomes hard to edit because it is unclear whether your
cursor is on the marker or the first or last character. The =org-appear= package helps by displaying the markers while the
cursor is on a rich text word.

#+BEGIN_SRC emacs-lisp
(use-package org-appear
  :if (skj/current-feature-required-p)
  :after org
  :hook (org-mode . org-appear-mode))
#+END_SRC

Links in =org-mode= by default are displayed as /descriptive/ links, meaning they hide their target URLs (or a destination
in general). While this looks great, it makes it a bit tricky to figure out how you can edit their URL.

Set the default column view for all =org-mode= files.

#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure nil
  :defer 1
  :if (skj/current-feature-required-p)
  :after org
  :config
  (define-key org-mode-map (kbd "C-c h") 'org-toggle-link-display)
  (setq org-columns-default-format
        (skj/make-org-column-view
         '(item category todo priority blocked
                tags-all scheduled deadline effort))))
#+END_SRC

Load =org-crypt= to enable selective encryption/decryption using GPG within
=org-mode=.

#+BEGIN_SRC emacs-lisp
(use-package org-crypt
  :ensure nil
  :if (skj/current-feature-required-p)
  :after org
  :custom
  (org-crypt-key skj/primary-email)
  (org-tags-exclude-from-inheritance (quote ("crypt")))
  :config
  (org-crypt-use-before-save-magic))
#+END_SRC

*** Org Query Language

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'query)
#+END_SRC

A powerful [[https://github.com/alphapapa/org-ql][query language]] for org files. Check the package [[https://github.com/alphapapa/org-ql/tree/master/examples][examples]].

#+BEGIN_SRC emacs-lisp
(use-package org-ql
  :if (skj/current-feature-required-p)
  :after org)
#+END_SRC

Add a Hydra for useful org query things.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defun org-ql-documentation ()
    (interactive)
    (browse-url "https://github.com/alphapapa/org-ql#usage"))
  
  (pretty-hydra-define hydra-org-ql
    (:color blue :quit-key "q" :title "∀ Org Query")
    ("Search"
     (("s"   org-ql-search                 "Search")
      ("b"   org-ql-find                   "Find in Buffer")
      ("a"   org-ql-find-in-agenda         "Find in Agenda Files")
      ("o"   org-ql-find-in-org-directory  "Find in Org Directory"))
     "Views"
     (("v"   org-ql-view                   "Show Saved View")
      ("b"   org-ql-view-sidebar           "Saved Views in Sidebar")
      ("r"   org-ql-view-recent-items      "Recent Items"))
     "Other"
     (("t"   org-ql-sparse-tree            "Sparse Tree for Matches")
      ("h"   org-ql-documentation          "Online Help"))))

  (bind-key "<f9> q" 'hydra-org-ql/body))
#+END_SRC

The [[https://github.com/alphapapa/ts.el][ts]] package is a useful tool for a bunch of time related stuff in agenda
and more.

#+BEGIN_SRC emacs-lisp
(use-package ts :if (skj/current-feature-required-p))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'query)
#+END_SRC

*** Priorities

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'priorities)
#+END_SRC

I like using the letters for display, it's a shame that the different Org
interfaces use integers, chars, /and/ strings.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (setq
   org-priority-highest ?A
   org-priority-lowest ?E
   org-priority-default ?C)

  (setq
   org-highest-priority ?A
   org-lowest-priority ?E
   org-default-priority ?C))
#+END_SRC

Use fancy Unicode character icons for different priority levels, this hooks
into =org-agenda= but could be used without.

#+BEGIN_SRC emacs-lisp
(use-package org-fancy-priorities
  :if (skj/current-feature-required-p)
  :hook (org-agenda)
  :custom
  (org-fancy-priorities-list
   '((?A . "⚡") (?B . "⬆") (?C . " ") (?D . "⬇") (?E . "☕")))
  (org-priority-faces
   '((?A :foreground "red" :weight bold)
     (?B :foreground "orange" :weight semi-bold)
     (?C :foreground "green" :weight normal)
     (?B :foreground "blue" :weight semi-light)
     (?C :foreground "grey" :weight light))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'priorities)
#+END_SRC

*** Categories

Would be nice to customize ~org-agenda-category-icon-alist~ but for two
issues:

1. Column views seem to ignore category properties and just use file names.
2. The icon list expects image data, no terminal mode.

*** Tags

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'tags)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (setq org-tag-alist
        '((:startgroup)
          ("idea" . ?i) ("call" . ?c) ("errand" . ?e) ("pay" . ?p) ("remind" . ?r) ("writing" . ?w)
          (:endgroup)
          ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          (:startgrouptag)
          ("home" . ?H)
          (:grouptags)
          ("fix" . ?f) ("clean" . ?l) ("garage" . ?g) ("yard" . ?y) ("family" . ?a) ("friends" . ?r)
          ("finance" . ?$) ("estate" . ?#) ("pets" . ?t)
          (:endgrouptag)
          ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          (:startgrouptag)
          ("activities" . ?A)
          (:grouptags)
          ("diving" . ?v) ("hacking" . ?h) ("music" . ?u) ("synth" . ?s) ("blogging" . ?b)
          (:endgrouptag)
          ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          (:startgrouptag)
          ("travel" . ?T)
          (:grouptags)
          ("flight" . ?F) ("car" . ?C) ("train" . ?R) ("hotel" . ?O) ("event" . ?V)
          (:endgrouptag)
          ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          (:startgrouptag)
          ("work" . ?W)
          (:grouptags)
          ("planning" . ?%) ("design" . ?^) ("coding" . ?!) ("meeting" . ??)
          ("admin" . ?/) ("business" . ?B) ("technical" . ?T) ("hr" . ?H)
          (:endgrouptag))))
#+END_SRC

Currently this fails!

#+BEGIN_SRC emacs-lisp
;; (use-package org-tag-beautify :config (org-tag-beautify-mode 1))
#+END_SRC

It results in the following:

#+BEGIN_EXAMPLE
all-the-icons-fileicon: Unable to find icon with name ‘svelte’ in icon set ‘fileicon’
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'tags)
#+END_SRC

*** Task Types (TODO)

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'tasks "Task Types (Keywords)")
#+END_SRC

Specify (<char>Before/After) where either Before/After may be @ for
record time AND comment, ! for just time

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (setq org-todo-keywords
        '(;; Simple reminders
          (sequence "NUDGE(g)"
                    "|" "DONE(d!)")
          ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          ;; General to-do items
          (sequence "TODO(t)" "NEXT(n!)" "INPROGRESS(p!)" "WAITING(w@/!)"
                    "|" "DONE(d!)" "CANCELED(c@)")
          ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          ;; Work-like task items
          (sequence "BACKLOG(b@)" "PLANNED(p@)"
                    "WORKING(w/@)" "INREVIEW(v/@)" "INTEST(t/@)"
                    "HOLD(h@/!)"
                    "|" "DONE(d!)" "CANCELED(c@)")
          ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          ;; Appointment and Meeting tracking
          (sequence "MEETING(M)" "RESCHEDULE(E@)"
                    "|" "DONE(c!)" "CANCELED(c@)"))))
#+END_SRC

Edna provides an extensible means of specifying conditions which must be
fulfilled before a task can be completed and actions to take once it is.

Org Edna runs when either the BLOCKER or TRIGGER properties are set on a
heading, and when it is changing from a TODO state to a DONE state.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package org-id
    :ensure nil
    :after org
    :custom
    (org-id-method 'uuid)
    (org-id-prefix nil)
    (org-id-include-domain nil))

  (use-package org-edna
    :after org-id
    :config
    (org-edna-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'tasks)
#+END_SRC

*** Capture Templates

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'capture-templates)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package org-capture
    :ensure nil
    :after org
    :defer 1)
  
  (let ((deadline "DEADLINE: %^t\n")
        (prop-id ":ID: %(org-id-new)")
        (prop-created ":CREATED: %U")
        (prop-level
         ":LEVEL: %^{Level|Team|VP|SVP|STeam|Flagship}")
        (prop-effort
         ":EFFORT: %^{Effort|1h|0:15|0:30|1h|4h|1d|2d|1w|2w|1m|3m|6m|1y}")
        (props (lambda (ps)
                 (format
                  ":PROPERTIES:\n%s:END:\n"
                  (if (null ps) "" (concat (string-join ps "\n") "\n"))))))
    
    (setq org-capture-templates
          (list
           (list
            "t" "Add a TODO entry"
            'entry
            '(file+headline org-default-notes-file "Task Inbox")
            (concat "** TODO %?\n"
                    (funcall props (list prop-created prop-id prop-effort)))
            :clock-in t
            :clock-resume t
            :empty-lines-after 1)
           ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
           (list
            "n" "Add a task as NEXT"
            'entry
            '(file+headline org-default-notes-file "Task Inbox")
            (concat "** NEXT %?\n"
                    deadline
                    (funcall props (list prop-created prop-id prop-effort)))
            :empty-lines-after 1)
           ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
           (list
            "p" "Add a project"
            'entry
            '(file+headline org-default-notes-file "Task Inbox")
            (concat "** %? [%] :project: \n"
                    deadline
                    (funcall props (list prop-created prop-id)))
            :empty-lines-after 2
            :refile-targets)
           ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
           (list
            "g" "Add a goal"
            'entry
            '(file+headline org-default-notes-file "Task Inbox")
            (concat "** %? :goal: \n"
                    deadline
                    (funcall props (list prop-created prop-id prop-level)))
            :empty-lines-after 1
            :refile-targets)
           ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
           (list
            "a" "Annotate current task"
            'plain
            '(clock)
            "- Note taken on %T \\\n  %?"
            :empty-lines-after 1)
           ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
           (list
            "m" "Add a planned meeting"
            'entry
            '(file+headline org-default-notes-file "Meeting Requests")
            (concat "** MEETING with %? :meeting: \n"
                    deadline
                    (funcall props (list prop-created)))
            :empty-lines-after 1)
           ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
           (list
            "i" "A Random idea"
            'entry
            '(file+headline org-default-notes-file "Thoughts")
            (concat "* %? :idea: \n"
                    (funcall props (list prop-created)))
            :empty-lines-after 1)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'capture-templates)
#+END_SRC

*** Refile and Archive

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'refile "Refile and Archive")
#+END_SRC

To refile tasks in Org you need to tell it where you want to refile things. I
let any file in ~org-agenda-files~ and the current file contribute to the list
of valid refile targets. Also, it's worth saving all Org buffers after
refiling.

#+BEGIN_SRC emacs-lisp
(use-package org-refile
  :ensure nil
  :if (skj/current-feature-required-p)
  :after org
  :custom
  ;; Targets include this file and any file contributing to the agenda
  (org-refile-targets
   (quote ((nil :maxlevel . 9)
           (org-agenda-files :maxlevel . 9))))
  
  ;; Refile in a single go
  (org-outline-path-complete-in-steps nil)
  
  ;; Show full paths for refiling
  (org-refile-use-outline-path t)

  ;; Use full outline paths for refile targets
  (org-refile-use-outline-path t)

  ;; Targets complete directly with IDO
  (org-outline-path-complete-in-steps nil)

  ;; Allow refile to create parent tasks with confirmation
  (org-refile-allow-creating-parent-nodes (quote confirm))

  ;; Use the current window for indirect buffer display
  (org-indirect-buffer-display 'current-window)
  
  :config
  (advice-add 'org-refile :after 'org-save-all-org-buffers))
#+END_SRC

Setup the builtin archiving to use files that use the "_archive" suffix.

#+BEGIN_SRC emacs-lisp
(use-package org-archive
  :ensure nil
  :if (skj/current-feature-required-p)
  :after org
  :custom
  (org-archive-location "%s_archive::"))
#+END_SRC

This gives you a chance to get rid of old entries in your Org files by
expiring them. The package is a part of =org-contrib=.

#+BEGIN_SRC emacs-lisp
(use-package org-expiry
  :ensure nil
  :if (skj/current-feature-required-p)
  :after org-contrib
  :custom
  (org-expiry-handler-function 'org-expiry-add-keyword))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'refile)
#+END_SRC

*** Faces

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'faces)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (setq org-todo-keyword-faces
        '(("NEXT" . (:foreground "green" :weight bold))
          ("PLAN" . (:foreground "green" :weight bold))
          ("INPROGRESS" . (:foreground "blue" :weight bold))
          ("ACTIVE" . (:foreground "blue" :weight bold))))

  (add-hook 'org-mode-hook #'turn-on-font-lock))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'faces)
#+END_SRC

*** Lists, Checkboxes, and Radios

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'lists)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-list
  :if (skj/current-feature-required-p)
  :ensure nil
  :after org
  :defer 1
  :diminish org-list-checkbox-radio-mode
  :hook (org-mode . org-list-checkbox-radio-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'lists)
#+END_SRC

*** Project File Integration

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'project "Project File Integration")
#+END_SRC

Adds all TODO items from a =todo.org= file in the magit project's root
to the magit status buffer.

#+BEGIN_SRC emacs-lisp
(use-package magit-org-todos
  :if (skj/current-feature-required-p)
  :after (magit org)
  :config
  (magit-org-todos-autoinsert))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'project)
(skj/feature-end 'config)
#+END_SRC

** Core UI Additions

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'ui "Core UI Additions")
#+END_SRC

The =org-superstar= package improves the look of Org mode headings by replacing the asterisk symbols with nicer looking
circles. The package also enhances the looks of plain lists and todo items.

#+BEGIN_SRC emacs-lisp
(use-package org-superstar
  :if (skj/current-feature-required-p)
  :after org
  :hook (org-mode . org-superstar-mode))
#+END_SRC

The [[https://github.com/minad/org-modern][org-modern]] package implements a /modern/ style for your Org buffers using font locking and text properties. The
package styles headlines, keywords, tables and source blocks.

#+BEGIN_SRC emacs-lisp
(use-package org-modern
  :if (and (skj/current-feature-required-p) window-system)
  :after org)
#+END_SRC

I use the [[https://github.com/sabof/org-bullets][org-bullets]] package to display the titles with nice Unicode bullets instead of the text ones.

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :if (skj/current-feature-required-p)
  :after org
  :hook
  (org-mode .  (lambda () (org-bullets-mode 1))))
#+END_SRC

The [[https://orgmode.org/worg/org-contrib/org-collector.html][org-collector]] package collects headline properties into tables with optional pre-processing.

**Example**:

#+BEGIN_EXAMPLE org
,#+BEGIN: propview :id "december" :conds ((string= SPENDTYPE "food")) :cols (ITEM AMOUNT)
,#+END:
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp :exports none
(use-package org-collector
  :ensure nil
  :if (skj/current-feature-required-p)
  :after org-contrib)
#+END_SRC

The [[https://github.com/nobiot/org-transclusion][org-transclusion]] package lets you insert a copy of text content via a file link or ID link within an Org file. It
lets you have the same content present in different buffers at the same time without copy-and-pasting it.

**Example**: ~#+transclude: [[id:20210501T171427.051019][Bertrand Russell]]~

#+BEGIN_SRC emacs-lisp :exports none
(use-package org-transclusion
  :if (skj/current-feature-required-p)
  :after org)
#+END_SRC

The [[https://github.com/eliascotto/accent][accent]] package shows a popup with accented characters based on the current letter under the cursor. Based on the
MacOS features for adding accented letters with a long keypress.

#+BEGIN_SRC emacs-lisp :exports none
(use-package accent
  :if (skj/current-feature-required-p)
  :custom
  (accent-position 'after)
  :config
  (global-set-key (kbd "C-x C-a") 'accent-menu))
#+END_SRC

The [[https://github.com/spegoraro/org-alert][org-alert]] provides notifications for scheduled or deadlined agenda entries. This uses the =alert= package configured
in [[#core-ui-notifications]] above.

#+BEGIN_SRC emacs-lisp
(use-package org-alert
  :if (skj/current-feature-required-p)
  :after org
  :custom
  (org-alert-interval 300)
  (org-alert-notify-cutoff 10)
  (org-alert-notify-after-event-cutoff 10)
  (org-alert-notification-title "Org Agenda"))
#+END_SRC

<<org-entities>>The [[https://github.com/emacs-mirror/emacs/blob/master/lisp/org/org-entities.el][org-entities]] package included in Org Mode allows for entering character entries in TeX-like form, so
=\approx= becomes =≈=. You can toggle the display between the entered form and the display form with
~org-toggle-pretty-entities~ (=C-c C-x \=). Additionally, ~org-entities-help~ will show a table of supported entities.

#+BEGIN_SRC emacs-lisp
(use-package org-entities
  :ensure nil
  :if (skj/current-feature-required-p)
  :after org)
#+END_SRC

The [[https://github.com/emacsmirror/org-outline-numbering][org-outline-numbering]] package defines a minor mode that displays an outline numbering as overlays on Org mode
headlines. The numbering matches how it would appear when exporting the org file.

Activating ~org-outline-numbering-mode~ displays the numbers and deactivating it clears them. There is no facility for
auto-updating but the numbering can be recalculated by calling ~org-outline-numbering-display~ and cleared by calling
~org-outline-numbering-clear~.

Do not enable by default. The outline numbers is determined by parsing the entire buffer (with
~org-element-parse-buffer~). This is obviously not very efficient and can be slow for large buffers, but is currently the
simplest way to get a correctly numbered tree.

#+BEGIN_SRC emacs-lisp
(use-package org-outline-numbering
  :ensure nil
  :if (skj/current-feature-required-p)
  :after ox)
#+END_SRC

*** References

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'references)
#+END_SRC

This adds [[https://github.com/jkitchin/org-ref][org-ref]] for citations and references, along with the nice [[https://github.com/alezost/org-ref-prettify.el][org-ref-prettify]].

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package org-ref :after org)

  (use-package org-ref-prettify
    :after org-ref
    :hook (org-mode . org-ref-prettify-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'references)
#+END_SRC

*** Completion Integration

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'completion)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  (use-package company-org-block
    :after (company org)
    :custom
    ;; style: 'auto, 'prompt, or 'inline
    (company-org-block-edit-style 'auto)
    :hook
    (org-mode . (lambda ()
                  (add-to-list (make-local-variable 'company-backends)
                               'company-org-block))))

  (use-package org-ivy-search
    :after (org ivy)
    :bind ("C-c o" . org-ivy-search-view)))
#+END_SRC

The following is installed by =org-ref= we just pull it in here.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  ;; all builtin
  (use-package org-ref
    :ensure nil
    :after org)
  
  (use-package org-ref-ivy
    :ensure nil
    :after (org ivy)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'completion)
(skj/feature-end 'ui)
#+END_SRC

** Agenda

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'agenda)
#+END_SRC

Set basic things for Org Agenda management. Note that we don't append to the list ~org-agenda-files~ as this should be the
first usage and so let's make it clean. Once you've opened an agenda view, there are some great [[https://orgmode.org/manual/Agenda-Commands.html#Agenda-commands][commands and]] toggles
that add more information.

#+BEGIN_SRC emacs-lisp
(use-package org-agenda
  :if (skj/current-feature-required-p)
  :ensure nil
  :after org
  :custom
  org-agenda-files
  (list (org-file-name "inbox.org")
        (org-file-name "todo.org")
        (org-file-name "todo-code.org")
        (org-file-name "people.org")
        (org-file-name "travel.org")
        (org-file-name "gcal.org"))
  (org-agenda-hide-tags-regexp ".")
  (org-agenda-log-mode-items '(closed clock state))
  
  ;; Because opening the agenda has a tendency to "mess up" window layout...
  (org-agenda-window-setup 'current-window)
  (org-agenda-restore-windows-after-quit t))
#+END_SRC


The [[https://github.com/Malabarba/org-agenda-property][org-agenda-property]] package can be customized with ~org-agenda-property-list~ and
~org-agenda-property-position~.

#+BEGIN_SRC emacs-lisp
(use-package org-agenda-property
  :if (skj/current-feature-required-p))
#+END_SRC

The [[https://github.com/alphapapa/][org-super-agenda]] package lets you /supercharge/ your Org daily/weekly agenda. The idea is to group items into
sections, rather than having them all in one big list.

#+BEGIN_SRC emacs-lisp
(use-package org-super-agenda
  :if (skj/current-feature-required-p)
  :after org
  :defer 1
  :custom
  (org-super-agenda-groups '((:auto-dir-name t)))
  :config
  (org-super-agenda-mode))
#+END_SRC

The [[https://github.com/alphapapa/org-sidebar][org-sidebar]] package presents helpful sidebars for Org buffers. Sidebars are customizable using [[*Org Query Language][org-ql]] queries and
[[https://github.com/alphapapa/org-super-agenda][org-super-agenda]] grouping. The default sidebar includes a chronological list of scheduled and deadlined items in the
current buffer (similar to the Org agenda, but without all its features) at the top, and a list of all other non-done
to-do items below. If the buffer is narrowed, the sidebar only shows items in the narrowed portion; this allows seeing
an overview of tasks in a subtree.

- Use ~org-sidebar~ to show the sidebar
- Use ~org-sidebar-tree~ to show the tree sidebar
  - ~org-sidebar-tree-toggle~
- Use =C-c C-s= to use a relative time for schedule

#+BEGIN_SRC emacs-lisp
(use-package org-sidebar
  :if (skj/current-feature-required-p)
  :after org-super-agenda)
#+END_SRC

*** Custom Views

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'views)
#+END_SRC

Set a sensible default column view for all agenda views.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  (setq org-columns-default-format-for-agenda
        (skj/make-org-column-view
         '(item todo priority blocked tags-all
                scheduled deadline effort clock-sum clock-sum-today))))
#+END_SRC

This is useful for filtering by priority, when not using tag queries.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  (defun skj/org-skip-subtree-if-priority (priority)
    "Skip an agenda subtree if it has a priority of PRIORITY.

  PRIORITY must be string between =\"A\"= and =\"E\"=."
    (let ((subtree-end (save-excursion (org-end-of-subtree t)))
          (pri-current (org-element-property :priority (org-element-at-point))))
      (if (equal priority pri-current)
          subtree-end
        nil))))
#+END_SRC

Set up some useful Agenda views.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  (setq org-agenda-custom-commands
        '(("p"
           "People"
           tags "CATEGORY=\"People\""
           ((org-agenda-overriding-header "People:")
            (org-agenda-sorting-strategy '(scheduled-up))
            (org-agenda-overriding-columns-format
             (skj/make-org-column-view
              '(name scheduled priority tags)))
            (org-agenda-view-columns-initially t)))
          ("c"
           "TODO closed last week"
           tags "CLOSED>=\"<-1w>\"&+TODO=\"DONE\"|+TODO=\"CANCELED\""
           ((org-agenda-overriding-header "TODO Closed last week:")
            (org-agenda-sorting-strategy '(priority-down effort-down))
            (org-agenda-overriding-columns-format
             (skj/make-org-column-view
              '(item priority scheduled deadline closed tags-all)))
            (org-agenda-view-columns-initially t)))
          ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          ("d"
           "Daily agenda review"
           ((tags "PRIORITY=\"A\"&-TODO=\"DONE\""
                  ((org-agenda-overriding-header "High-priority unfinished tasks:")
                   (org-agenda-sorting-strategy '(todo-state-down effort-up))))
            ;; --=--=--=--=--=--=--=--=--=--=
            (agenda "")
            ;; --=--=--=--=--=--=--=--=--=--=
            (alltodo ""
                     ((org-agenda-skip-function
                       '(or (skj/org-skip-subtree-if-priority ?A)
                            (org-agenda-skip-if nil '(scheduled deadline))))
                      (org-agenda-sorting-strategy
                       '(priority-down todo-state-down effort-up)))))
           nil
           ("~/daily-agenda.html")))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-timeline
  :if (skj/current-feature-required-p)
  :after org-agenda
  :config
  (add-hook 'org-agenda-finalize-hook 'org-timeline-insert-timeline :append))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'views)
#+END_SRC

*** Run on Idle

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'run-on-idle)
#+END_SRC

Basically, if you don't touch Emacs =idle-org-agenda= will display your org-agenda after certain time. That can be useful
to remember tasks after come back to work.

#+BEGIN_SRC emacs-lisp
(use-package idle-org-agenda
  :if (skj/current-feature-required-p)
  :after org
  :config (idle-org-agenda-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'run-on-idle)
#+END_SRC

*** Clock Tracking

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'clock-tracking)
#+END_SRC

See https://superuser.com/questions/579281/advanced-time-tracking-in-org-mode

Also, consider https://github.com/dfeich/org-clock-convenience

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package org-clock
    :ensure nil ;; builtin
    :after org
    :custom
    ;; Save the running clock and all clock history when exiting Emacs, load it on startup
    (org-clock-persist 'history)

    ;; Show lot of clocking history so it's easy to pick items off the C-F11 list
    (org-clock-history-length 23)

    ;; Separate drawers for clocking and logs
    (org-drawers (quote ("PROPERTIES" "LOGBOOK")))

    ;; Save clock data and state changes and notes in the LOGBOOK drawer
    (org-clock-into-drawer t)

    ;; Surely, by definition ...
    (org-clock-in-switch-to-state "INPROGRESS")
    
    ;; Clock out when moving task to a done state
    (org-clock-out-when-done t)

    ;; Resume clocking task on clock-in if the clock is open
    (org-clock-in-resume t)
    
    ;; This removes clocked tasks with 0:00 duration
    (org-clock-out-remove-zero-time-clocks t)

    ;; Clock out when moving task to a done state
    (org-clock-out-when-done t)

    ;; Do not prompt to resume an active clock
    (org-clock-persist-query-resume nil)

    ;; Enable auto clock resolution for finding open clocks
    (org-clock-auto-clock-resolution (quote when-no-clock-is-running))

    ;; Include current clocking task in clock reports
    (org-clock-report-include-clocking-task t)

    ;; If idle for more than 30 minutes, resolve the things by asking what to do
    ;; with the clock time
    (org-clock-idle-time 30)

    (org-clock-clocked-in-display 'both)
    
    ;; Agenda clock report parameters
    (org-agenda-clockreport-parameter-plist
     (quote (:link t :maxlevel 5 :fileskip0 t :compact t :narrow 80)))
    
    (org-remember-clock-out-on-exit t)
    
    :config
    ;; Resume clocking task when emacs is restarted
    (org-clock-persistence-insinuate)

    (pretty-hydra-define hydra-org-clock
      (:color blue :quit-key "q" :title "  Org Clock")
      ("Clock"
       (("i"   org-clock-in                     "Clock In")
        ("c"   org-clock-in-last                "Continue")
        ("o"   org-clock-out                    "Clock Out")
        ("q"   org-clock-cancel                 "Clock Cancel")
        ("g"   org-clock-goto                   "Goto Current"))
       "Modify"
       (("m e" org-clock-modify-effort-estimate "Edit Effort")
        ("m r" org-evaluate-time-range          "Recompute interval")
        ("m u" org-timestamp-up                 "Timestamp up")
        ("m d" org-timestamp-down               "Timestamp down")
        ("m U" org-clock-timestamps-up          "Timestamp range up")
        ("m D" org-clock-timestamps-down        "Timestamp range down"))
       "Reporting"
       (("r a" org-add-note                     "Add Note")
        ("r d" org-clock-display                "Display Time")
        ("r r" org-clock-report                 "Clock Report"))
       "Timer"
       (("t n" org-timer-set-timer              "New")
        ("t s" org-timer-start                  "Start")
        ("t p" org-timer-pause-or-continue      "Pause/Continue")
        ("t x" org-timer-stop                   "Stop")
        ("t i" org-timer                        "Insert Timer")
        ("t I" org-timer-item                   "Insert Timer Item"))))

    (bind-key "<f9> c" 'hydra-org-clock/body)

    (defun skj/mode-line-append (value)
      "Append VALUE to `mode-line-format' before any end spaces."
      (if (member value mode-line-format)
          mode-line-format
        (let* ((mode-line-format/rev (reverse mode-line-format))
               (mode-line-format/last (car (seq-take mode-line-format/rev 1)))
               (mode-line-format/rest (seq-drop mode-line-format/rev 1)))
          (reverse
           (if (eq mode-line-format/last 'mode-line-end-spaces)
               (cons mode-line-format/last
                     (cons value mode-line-format/rest))
             (cons value
                   (cons mode-line-format/last mode-line-format/rest)))))))

    (setq mode-line-format
          (skj/mode-line-append '(:propertize
                                  (t org-mode-line-string)
                                  face (:foreground "cyan" :weight 'bold))))
    (add-hook 'org-clock-out-hook
              (lambda ()
                 (setq org-mode-line-string nil)
                 (force-mode-line-update)))))
#+END_SRC

Active notifications are shown every 3 minute, inactive every 3

#+BEGIN_SRC emacs-lisp
(use-package org-clock-reminder
  :if (skj/current-feature-required-p)
  :defer 1
  :after org-clock
  :custom
  (org-clock-reminder-interval (cons 3 10))
  :config 
  (org-clock-reminder-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'clock-tracking)
#+END_SRC

*** Habit Tracking

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'habit-tracking)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package org-habit
    :ensure nil
    :after org)

  (use-package org-habit-stats
    :after org-habit
    :custom
    (org-habit-following-days 7)
    (org-habit-graph-column 60)
    (org-habit-preceding-days 28)
    (org-habit-show-all-today nil)
    (org-habit-show-done-always-green t)
    (org-habit-show-habits-only-for-today t)))
#+END_SRC

This is an analog to ~org-time-stamp-format~ from org-mode which allows for formatting repeating timestamps. Unlike the
original it does not format inactive time-stamps as these can't be used for repeating tasks.

#+BEGIN_SRC emacs-lisp
(defun habit-time-stamp-format (interval &optional with-time)
  (if (string-match "[0-9]+[hdwmy]" interval)
      (format "<%s .+%s>"
              (funcall (if with-time #'cdr #'car) org-time-stamp-formats)
              interval)
    (throw :repeat interval)))
#+END_SRC

Checklists are great for repeated tasks with lots of things that need to be done. For a long time I was manually
resetting the check boxes to unchecked when marking the repeated task =DONE= but no more! There's a contributed
[[https://orgmode.org/worg/org-contrib/org-checklist.html][org-checklist]] that can uncheck the boxes automagically when the task is marked done (and has the property
=RESET__CHECK__BOXES= set).

#+BEGIN_SRC emacs-lisp
(use-package org-checklist
  :ensure nil
  :if (skj/current-feature-required-p)
  :after org-contrib)

#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'habit-tracking)
#+END_SRC

*** Progress Reporting

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'progress "Progress Reporting")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defun skj/org-dashboard-filter (entry)
    (and (> (plist-get entry :progress-percent) 0)
         (< (plist-get entry :progress-percent) 100)
         (not (member "archive" (plist-get entry :tags)))))

  (use-package org-dashboard
    :custom
    (org-expiry-add-keyword t)
    (org-dashboard-filter 'skj/org-dashboard-filter)))
#+END_SRC

Might also consider:

- [[https://github.com/gizmomogwai/org-kanban][org-kanban]]
- [[https://github.com/ianxm/emacs-scrum][org-scrum]]
- [[https://github.com/tbanel/orgaggregate/blob/master/README.org][orgtbl-aggregate]] -- aggregating a table is creating a new table by computing sums, averages, and so on, out of
  material from the first table.

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'progress)
#+END_SRC

*** Standard Calendars

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'calendars)
#+END_SRC

Remove the Bahá'í holidays, really not sure they add anything for me. But, Mexican holidays are rather good to know!

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package holidays
    :ensure nil
    :defer 3
    :custom
    (holiday-bahai-holidays nil)
    (holiday-hebrew-holidays nil)
    (holiday-islamic-holidays nil))

  (use-package mexican-holidays
    :after holidays
    :custom
    (add-to-list 'calendar-holidays holiday-mexican-holidays)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'calendars)
#+END_SRC

*** Google Calendar

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'google-calendar)
#+END_SRC

Emacs own /EasyPG/ picks up the wrong key if I use the primary email address, it seems to ignore the fact that it has been
revoked. Using the alternate email for this key, should work?

#+BEGIN_SRC emacs-lisp
(use-package plstore
  :ensure nil
  :if (skj/current-feature-required-p)
  :custom
  (plstore-encrypt-to "simonkjohnston@mac.com"))
#+END_SRC

Use my secrets store to load the Google Calendar credentials.

#+BEGIN_SRC emacs-lisp
(use-package skj-secrets
  :if (skj/current-feature-required-p)
  :ensure nil ;; locally stored
  :defer nil)
#+END_SRC

Store synced calendar entries in the following file.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defcustom skj/org-gcal-file (org-file-name "gcal.org")
    "Location of `org-mode' file to sync with Google Calendar."
    :tag "Org Agenda file for Google Calendar"
    :group 'skj-org
    :type '(file :must-match t)))
#+END_SRC

Now setup the client.

#+BEGIN_SRC emacs-lisp
(use-package org-gcal
  :if (skj/current-feature-required-p)
  :after (org skj-secrets)
  :custom
  (org-gcal-fetch-file-alist (list (cons skj/primary-email
                                         skj/org-gcal-file)))
  (org-gcal-local-timezone calendar-time-zone-name)
  (org-gcal-client-id (skj/secrets-value 'gcal-id))
  (org-gcal-client-secret (skj/secrets-value 'gcal-secret))
  :hook (emacs-startup . org-gcal-fetch))
#+END_SRC

Execute =M-x org-gcal-fetch<RET>= to fetch new calendar updates. Or, execute =M-x org-gcal-post-at-point<RET>= to turn a
=TODO= into a calendar entry.

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'google-calendar)
#+END_SRC

*** Appointment Integration

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'appt "Appointment Integration")
#+END_SRC

Configure the builtin =calendar= and =appt= packages.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package calendar
    :ensure nil
    :custom
    (diary-file (concat-path user-emacs-directory "diary")))

  (use-package appt
    :ensure nil
    :custom
    (appt-audible t)
    (appt-display-duration 30)
    (appt-display-format 'window)
    (appt-display-mode-line t)
    :config
    (appt-activate t)))
#+END_SRC

Rebuild the reminders every time we display the agenda.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defun skj/org-agenda-to-appt ()
    "Erase all reminders and rebuilt reminders for today from the agenda."
    (interactive)
    (setq appt-time-msg-list nil)
    (org-agenda-to-appt))

  ;; Add hook to do this when we finalize an agenda view
  (add-hook 'org-agenda-finalize-hook 'skj/org-agenda-to-appt 'append)

  ;; If we leave Emacs running overnight - reset the appointments one
  ;; minute after midnight
  (run-at-time "24:01" nil 'skj/org-agenda-to-appt)

  ;; Finally, run during startup so that appointments are rebuilt.
  (skj/org-agenda-to-appt))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'appt)
(skj/feature-end 'agenda)
#+END_SRC

** Babel

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'babel)
#+END_SRC

This function is useful as we want to always add to the list of babel languages, but also it's nice to be able to pass a
single value rather than a list in all cases.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defun skj/org-babel-add-languages (languages)
    "Add language to babel and load.

Add LANGUAGES to `'org-babel-load-languages' where LANGUAGES may
be one of the following:

1. a single symbol,
1. a pair with a symbol and a value to denote the enable
   state of the language,
1. or a list where each element is one of the two above.

Finally, the `org-babel-do-load-languages' is called with the
normalized values of LANGUAGES."
    (if (symbolp languages)
        (add-to-list 'org-babel-load-languages (cons languages t))
      (dolist (lang-pair languages)
        (let ((language (cond
                         ((symbolp lang-pair)
                          (cons lang-pair t))
                         ((and (consp lang-pair) (symbolp (car lang-pair)) (booleanp (cdr lang-pair)))
                          lang-pair)
                         (t (error "Invalid value for language: %s" lang-pair)))))
          (add-to-list 'org-babel-load-languages language)))))

  (defun skj/org-babel-do-load-languages ()
    "Call org-babel to load all languages."
    (org-babel-do-load-languages
     'org-babel-load-languages
     org-babel-load-languages)))
#+END_SRC

Load some common builtin languages, these do not have their own sections as they do not have any specific configuration.

- [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-elisp.html][Emacs Lisp]] ...
- [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-sqlite.html][sqlite]] is a software library that implements a self-contained, serverless, zero-configuration, transactional SQL
  database engine.
- Org Babel works with several text based [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-shell.html][shells]].

Also, always redisplay images after =C-c C-c.=

#+BEGIN_SRC emacs-lisp
(use-package ob
  :ensure nil
  :if (skj/current-feature-required-p)
  :after org
  :init
  (skj/org-babel-add-languages '(emacs-lisp sqlite shell))
  :config
  (add-hook 'org-babel-after-execute-hook
            'org-display-inline-images
            'append)
  (add-hook 'org-mode-hook 'skj/org-babel-do-load-languages))
#+END_SRC

By default, Org-mode doesn’t let you edit things in an indirect buffer except for source blocks.

This package extends `org-edit-special' so it can be used to edit (almost) any type of block in Org-mode, things like
`quote', `verse', `comment' blocks, etc.

#+BEGIN_SRC emacs-lisp
(use-package org-edit-indirect
  :if (skj/current-feature-required-p)
  :after '(edit-indirect org)
  :hook (org-mode . org-edit-indirect-mode))
#+END_SRC

skj-org
#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  (defcustom skj/babel-safe-languages '("dot" "plantuml" "sdml")
    "A list of language safe for Babel evaluation."
    :tag "Babel safe languages"
    :type '(repeat string)
    :group 'skj-org)

(defun skj/org-confirm-babel-evaluate (lang body)
  "Return t if LANG not in `skj/babel-safe-languages'."
  (message "confirm eval of %s %s" lang (member lang skj/babel-safe-languages))
  (not (member lang skj/babel-safe-languages)))

(setq org-confirm-babel-evaluate #'skj/org-confirm-babel-evaluate))
#+END_SRC

*** ditaa

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'ditaa)
#+END_SRC

DIagrams Through Ascii Art ([[https://ditaa.sourceforge.net/][ditaa]], [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-ditaa.html][ob-ditaa]]) is a command-line utility that converts diagrams drawn using ASCII art into
bitmap graphics.

#+BEGIN_SRC emacs-lisp
(use-package ob-ditaa
  :ensure nil
  :ensure-system-package ditaa
  :if (skj/current-feature-required-p)
  :after ob
  :init
  (skj/org-babel-add-languages 'ditaa))
#+END_SRC

Use =artist-mode= when drawing diagrams in ditaa.

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'ditaa)
#+END_SRC

*** GNUPlot

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'gnuplot "GNUPlot")

#+END_SRC

Enable the builtin [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-gnuplot.html][gnuplot babel]] support after adding the editing mode.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package gnuplot
    :ensure-system-package gnuplot
    :mode ("\\.gp$" . gnuplot-mode))

  (use-package ob-gnuplot
    :ensure nil
    :after (ob gnuplot)
    :init
    (skj/org-babel-add-languages 'gnuplot)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'gnuplot)
#+END_SRC

*** GraphViz

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'dot "GraphViz")
#+END_SRC

Enable the builtin [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-dot.html][dot babel]] support after adding the editing mode.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package graphviz-dot-mode
    :ensure-system-package (dot . "brew install graphviz")
    :init
    (unless (<= emacs-version-number 26)
      (setq graphviz-dot-indent-width tab-width)))
  
  (use-package ob-dot
    :ensure nil
    :after (ob graphviz-dot-mode)
    :init
    (skj/org-babel-add-languages 'dot)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'dot)
#+END_SRC

*** Mermaid

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'mermaid)
#+END_SRC

The [[https://github.com/abrochard/mermaid-mode/tree/master][mermaid-mode]] allows stand-alone and Babel integration for the [[https://mermaid.js.org/][Mermaid]] diagramming and charting tool.

#+BEGIN_SRC emacs-lisp
(use-package mermaid-mode
  :ensure-system-package
  (mmdc . "npm install -g @mermaid-js/mermaid-cli")
  :if (skj/current-feature-required-p)
  :custom
  (mermaid-output-format ".svg"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'mermaid)
#+END_SRC

*** HTTP

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'http)
#+END_SRC

https://github.com/zweifisch/ob-http

#+BEGIN_SRC emacs-lisp
(use-package ob-http
  :if (skj/current-feature-required-p)
  :init (skj/org-babel-add-languages 'http))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'http)
#+END_SRC

*** PlantUML

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'puml "PlantUML")
#+END_SRC

Enable the builtin [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-plantuml.html][PlantUML babel]] support after adding the editing mode. Configuring this to use the =plantuml=
executable.

#+BEGIN_NOTE
You will likely want to set the variables =plantuml-jar-path= and =org-plantuml-jar-path= with the path to your local
installation of PlantUML. Alternatively, set the variable =plantuml-default-exec-mode= to =executable= to use your local
plantuml executable.
#+END_NOTE

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package plantuml-mode
    :ensure-system-package plantuml
    :init
    (setq plantuml-jar-path (concat-path
                             (homebrew-prefix/package-prefix)
                             "plantuml/libexec/plantuml.jar"))
    (setq plantuml-default-exec-mode 'jar))

  (use-package flycheck-plantuml
    :after plantuml-mode
    :config
    (flycheck-plantuml-setup))
  
  (use-package ob-plantuml
    :ensure nil
    :demand t
    :after (ob plantuml-mode)
    :init
    (setq org-plantuml-jar-path plantuml-jar-path)
    (skj/org-babel-add-languages 'plantuml)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'puml)
(skj/feature-end 'babel)
#+END_SRC

** Export

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'export)
#+END_SRC

Load the underlying =org-export= package.

#+BEGIN_SRC emacs-lisp
(use-package ox
  :if (skj/current-feature-required-p)
  :ensure nil
  :after org
  :custom
  (org-export-with-smart-quotes t))
#+END_SRC

Configure the ASCII export.

#+BEGIN_SRC emacs-lisp
(use-package ox-ascii
  :if (skj/current-feature-required-p)
  :ensure nil
  :after ox
  :custom
  (org-ascii-links-to-notes nil))
#+END_SRC

Configure the HTML export.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package ox-html
    :ensure nil
    :after ox
    :custom
    (org-html-coding-system 'utf-8-unix)
    (org-link-file-path-type "relative")
    (org-html-head-include-default-style t) ;; turn off per-project
    (org-html-head-include-scripts nil)
    (org-html-table-default-attributes
     '(:border "0" :cellspacing "0" :cellpadding "6" :rules "none" :frame "none"))
    (org-html-validation-link nil))

  ;; Set this to an empty string as I'd rather use KaTeX than MathJax.
  (setf org-html-mathjax-template ""))
#+END_SRC

The package [[https://github.com/emacsorphanage/ox-pandoc][ox-pandoc]] is an exporter for Org mode which converts Org-mode files to a wide variety of other formats using
the [[https://pandoc.org/][pandoc]] tool. Pandoc can produce PDFs, HTML, presentations, markdown files, office documents and e-pub publications
as well as a number of other more specialised formats.

#+BEGIN_SRC emacs-lisp
(use-package ox-pandoc
  :if (skj/current-feature-required-p)
  :ensure-system-package pandoc
  :defer 5
  :after ox)
#+END_SRC

Add Org exporter backends for Markdown and [[https://github.com/larstvei/ox-gfm][Github-Flavored Markdown]].

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

 (use-package ox-md
   :ensure nil
   :defer 3
   :after ox)

  (use-package ox-gfm
    :after ox-md
    :commands (org-gfm-export-as-markdown
               org-gfm-export-to-markdown)))
#+END_SRC

The best way to produce a PDF from an org file is to export it to a =.texi= file, and then use =texi2pdf= to produce the
PDF.

#+BEGIN_SRC emacs-lisp
(use-package ox-texinfo
  :ensure nil
  :if (skj/current-feature-required-p)
  :ensure-system-package
  (texi2pdf . "brew install texinfo")
  :defer 3
  :after ox)
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'export)
#+END_SRC

** Publishing

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'publish)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ox-publish
  :ensure nil
  :if (skj/current-feature-required-p)
  :defer 3
  :after ox
  :custom
  (org-publish-use-timestamps-flag t)
  (org-publish-sitemap-sort-folders 'first))
#+END_SRC

Use ~(setq org-publish-cache nil)~ to reset the timestamp cache.

Dir locals are stored in the variable ~safe-local-variable-values~. This is cleared on startup, a bit of a pain, but
safety first. Note that it *is not* gated by the current feature, this is a global action.

#+BEGIN_SRC emacs-lisp
(use-package files
  :ensure nil
  :config
  ;; (setq dir-local-variables-alist nil)
  (setq dir-locals-directory-cache nil)
  (setq dir-locals-class-alist nil)
  (setq safe-local-variable-values nil))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'publish)
#+END_SRC

** Key Bindings

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'key-bindings)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (global-set-key (kbd "C-c l") #'org-store-link)
  (global-set-key (kbd "C-c a") #'org-agenda)
  (global-set-key (kbd "C-c c") #'org-capture)
  (global-set-key (kbd "C-<f5>") 'org-store-agenda-views))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'key-bindings)
(skj/feature-end 'org)
#+END_SRC


* Other Writing Modes

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'writing "Other Writing Modes")
#+END_SRC

For distraction-free editing, use the command =M-x focus-mode= which will dim all but the block of text/code you are
currently within.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (let ((dimmed-foreground (alist-get 'base2 skj/theme-core-color-alist)))
    (use-package focus
      :if (skj/current-feature-required-p)
      :custom-face
      (focus-unfocused
       ((t (:inherit font-lock-comment-face :foreground ,dimmed-foreground)))))))
#+END_SRC

Add a simple /lorem ipsum/ tool to add filler text into an Emacs buffer.

#+BEGIN_SRC emacs-lisp
(use-package lorem-ipsum
  :if (skj/current-feature-required-p)
  :config
  (lorem-ipsum-use-default-bindings))
#+END_SRC

This will setup the following keybindings:

| Key Binding | Function                      |
|-------------+-------------------------------|
| =C-c l p=     | ~lorem-ipsum-insert-paragraphs~ |
| =C-c l s=     | ~lorem-ipsum-insert-sentences~  |
| =C-c l l=     | ~lorem-ipsum-insert-list~       |

** Emoji Support

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'emoji)
#+END_SRC

Emacs has to be able to properly render emojis as characters, so a suitable font is required. Noto Color Emoji is
recomended for optimal results.

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p) window-system)
  (set-fontset-font t 'symbol (font-spec :family "Noto Color Emoji") nil 'prepend))
#+END_SRC

[[https://github.com/iqbalansari/emacs-emojify][Emojify]] is an Emacs extension to display emojis. It can display github style emojis like =:smile:= or plain ascii ones
like =:)=. It tries to be as efficient as possible, while also providing a lot of [[https://github.com/iqbalansari/emacs-emojify#customizations][flexibility]]

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p) window-system)

  (use-package emojify))
#+END_SRC

=emojify-mode= can be enabled/disabled separately for a buffer by using the command =emojify-mode=, to enable/disable it
globally use the command =global-emojify-mode=.

#+BEGIN_SRC emacs-lisp
(use-package company-emoji
  :if (skj/current-feature-required-p)
  :after (company)
  :if window-system
  :config
  (add-to-list 'company-backends 'company-emoji t)

  (defun --set-emoji-font (frame)
    "Adjust the font settings of FRAME so Emacs can display emoji properly."
    (if (system-mac-p)
        ;; For NS/Cocoa
        (set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji") frame 'prepend)
      ;; For Linux
      (set-fontset-font t 'symbol (font-spec :family "Symbola") frame 'prepend)))

  ;; For when Emacs is started in GUI mode:
  (--set-emoji-font nil)
  
  ;; Hook for when a frame is created with emacsclient
  ;; see https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Frames.html
  (add-hook 'after-make-frame-functions '--set-emoji-font))
#+END_SRC

Setup ivy emoji support to use the same list as company, for consistency.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package ivy-emoji
    :after (ivy company-emoji)
    :if window-system
    ;; mnemonics i e = insert emoji
    :bind ("C-c i e" . ivy-emoji))

  (use-package company-emoji-list
    :ensure nil
    :after ivy-emoji
    :custom
    (ivy-emoji-list
     (mapcar #'(lambda (emoji)
                 (concat
                  (get-text-property 0 :unicode emoji) " "
                  (substring-no-properties emoji)))
             (company-emoji-list-create)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'emoji)
#+END_SRC

** Markdown and Polymode

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'markdown)
#+END_SRC

The [[https://jblevins.org/projects/markdown-mode/][markdown-mode]] package is a major mode for editing Markdown-formatted text. Note that this package provides major
modes for generic markdown and GitHub-flavored markdown.

- Math support can be toggled interactively later using =C-c C-x C-e= (~markdown-toggle-math~).
- Markup hiding can be toggled using =C-c C-x C-m= (~markdown-toggle-markup-hiding~).
- Native code fontify can be toggled interactively by pressing =C-c C-x C-f=
  (~markdown-toggle-fontify-code-blocks-natively~).

| Variable                                  | Description                                                                                                       |
|-------------------------------------------+-------------------------------------------------------------------------------------------------------------------|
| ~markdown-enable-math~                      | Font lock for inline and display LaTeX math expressions                                                           |
| ~markdown-enable-html~                      | Font lock for HTML tags and attributes                                                                            |
| ~markdown-fontify-code-blocks-natively~     | Whether to fontify code in code blocks using the native major mode                                                |
| ~markdown-hide-markup~                      | Determines whether all possible markup is hidden or otherwise beautified                                          |
| ~markdown-gfm-use-electric-backquote~       | Use ~markdown-electric-backquote~ for interactive insertion of GFM code blocks when you press backquote three times |
| ~markdown-gfm-uppercase-checkbox~           | When non-nil, complete GFM task list items with =[X]= instead of =[x]=                                                |
| ~markdown-make-gfm-checkboxes-buttons~      | Whether GitHub Flavored Markdown style task lists should turn into buttons                                        |
| ~markdown-marginalize-headers~              | Put opening atx header markup in the left margin                                                                  |
| ~markdown-marginalize-headers-margin-width~ | Width of margin used for marginalized headers                                                                     |
  
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :if (skj/current-feature-required-p)
  :custom
  (markdown-enable-math t)
  (markdown-enable-html t)
  (markdown-fontify-code-blocks-natively t)
  (markdown-hide-markup t)
  (markdown-gfm-use-electric-backquote t)
  (markdown-gfm-uppercase-checkbox t)
  (markdown-make-gfm-checkboxes-buttons t)
  (markdown-marginalize-headers t)
  (markdown-marginalize-headers-margin-width 6)
  :mode (("\\.markdown\\'" . markdown-mode)
         ("\\.md\\'" . markdown-mode)
         ("README\\.md\\'" . gfm-mode))
  :hook
  (markdown-mode . markdown-toggle-fontify-code-blocks-natively)
  (org-mode . electric-pair-local-mode)
  :config
  (set-italic-face-attributes 'markdown-italic-face))
#+END_SRC

Polymode is a framework for multiple major modes (MMM) inside a single Emacs buffer. It is fast and has a simple but
flexible object oriented design. Creating new polymodes normally takes a few lines of code.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package polymode)

  (use-package poly-markdown
    :after (polymode markdown-mode)
    :mode ("\\.md" . poly-markdown-mode)))
#+END_SRC

Edit regions in separate buffers, like `org-edit-src-code' but for arbitrary regions.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package edit-indirect)

  (use-package poly-markdown
    :after (polymode markdown-mode)
    :mode ("\\.md" . poly-markdown-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'markdown)
#+END_SRC

** Blogging

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'blogging)
#+END_SRC

Editing jekyll files, using =polymode= for the mix of YAML and Markdown.

#+BEGIN_SRC emacs-lisp
(use-package jekyll-modes
  :if (skj/current-feature-required-p)
  :after (poly-markdown))
;;  :mode ("\\.md$" . jekyll-markdown-mode)
#+END_SRC

Emacs major mode for managing [[https://jekyllrb.com/][jekyll]] blogs ([[https://github.com/masasam/emacs-easy-jekyll][repo]]).

#+BEGIN_SRC emacs-lisp
(use-package easy-jekyll
  :if (skj/current-feature-required-p))
#+END_SRC

Thanks to [[https://cute-jumper.github.io/emacs/2013/10/06/orgmode-to-github-pages-with-jekyll][Org-mode to GitHub pages with Jekyll]].

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defun org-jekyll-post-link-follow (path)
    (org-open-file-with-emacs path))

  (defun org-jekyll-post-link-export (path desc format)
    (cond
     ((eq format 'html)
      (format "<a href=\"{%% post_url %s %%}\">%s</a>" (file-name-sans-extension path) desc))))

  (org-add-link-type "jekyll-post" 'org-jekyll-post-link-follow 'org-jekyll-post-link-export))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'blogging)
#+END_SRC

** Wiki Stuff

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'wikis)
#+END_SRC

This allows direct access to edit files on the Wiki, and an Org mode exporter via /=M-x org-mw-export-as-mediawiki<RET>=/.

#+BEGIN_SRC emacs-lisp
;; (use-package mediawiki)

(use-package ox-mediawiki
  :if (skj/current-feature-required-p)
  :after (ox mediawiki))
#+END_SRC

XWiki mode is an offline editing mode only.

#+BEGIN_SRC emacs-lisp
(use-package xwiki-mode
  :if (skj/current-feature-required-p))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'wikis)
#+END_SRC

** LaTeX

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'latex "LaTeX")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defcustom skj/latex-shared-paths (list (expand-file-name "~/Projects/latex/texmf"))
    "A list of directories holding shared files for LaTeX writing."
    :tag "Shared LaTeX directories"
    :group 'skj
    :type '(repeat directory))

  (defcustom skj/bibtex-files (list (expand-file-name "~/Projects/latex/personal.bib"))
    "A list of BibTeX files to use for citation searches."
    :tag "Shared BibTeX files"
    :group 'skj
    :type '(repeat file)))
#+END_SRC

*** AUCTeX

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'auctex "AUCTeX")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  (use-package tex
    :ensure auctex
    :hook
    (LaTeX-mode . electric-pair-local-mode))

  (setq latex-run-command "xelatex"
        TeX-auto-save t
        TeX-parse-self t)

  (use-package auctex-latexmk
    :after auctex)

  (use-package latex-pretty-symbols)

  (use-package latex-extra
    :after auctex
    :hook (LaTeX-mode . latex-extra-mode)))
#+END_SRC

This is a group of backends for =company-mode= providing auto-completion for
AUCTeX.

#+BEGIN_SRC emacs-lisp
(use-package company-auctex
  :if (skj/current-feature-required-p)
  :config (company-auctex-init))
#+END_SRC

This add-on defines three =company-mode= backends.

#+BEGIN_SRC emacs-lisp
(use-package company-math
  :if (skj/current-feature-required-p)
  :commands company-math-symbols-unicode
  :custom
  (company-tooltip-align-annotations t)
  :config
  (add-to-list 'company-backends 'company-math-symbols-unicode t))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'auctex)
#+END_SRC

*** Bibliographies

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'bibliographies)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package biblio)

  (use-package bibtex-utils))
#+END_SRC

Completion, using [[https://github.com/gbgar/company-bibtex][company-bibtex]] and [[https://github.com/tmalsburg/helm-bibtex/blob/master/README.org][ivy-bibtex]] packages.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package company-bibtex
    :config (setq company-bibtex-bibliography skj/bibtex-files)
    (add-to-list 'company-backends 'company-bibtex t))

  (use-package ivy-bibtex
    :config (setq bibtex-completion-bibliography skj/bibtex-files)))
#+END_SRC

Tools to retrieve content.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package bibretrieve)

  (use-package gscholar-bibtex))
#+END_SRC

The [[https://github.com/emacs-citar/citar][citar]] package provides a completing-read front-end to browse and act on BibTeX, BibLaTeX, and CSL JSON bibliographic
data, and LaTeX, markdown, and org-cite editing support. See [[https://kristofferbalintona.me/posts/202206141852/#citar][this page]] for some configuration ideas.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package citar
    :config (setq citar-bibliography skj/bibtex-files)))

;;(use-package citar-org
;;  :after oc
;;  :config (setq org-cite-insert-processor 'citar
;;                org-cite-follow-processor 'citar
;;                org-cite-activate-processor 'citar))
#+END_SRC



#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package zotero
    :commands (zotero-browser)
    :custom
    (zotero-auth-token
     (zotero-auth-token-create :token (auth-source-pass-get 'secret "Zotero/api-key")
                               :token-secret (auth-source-pass-get 'secret "Zotero/api-key")
                               :userid (auth-source-pass-get 'secret "Zotero/userid")
                               :username skj/default-user-name))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'bibliographies)
#+END_SRC

*** Preview

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'preview)
#+END_SRC

Use =M-x latex-math-preview-expression=

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p) window-system)
  
  (use-package latex-math-preview)

  (use-package latex-preview-pane
    :config (latex-preview-pane-enable)))
#+END_SRC

Automatically toggle Org mode LaTeX fragment previews as the cursor enters and exits them. Basically, in window mode
LaTeX previews are generated for math (for example) and shown as previews in-line. These previews are then turned off as
you enter them so that you can edit the underlying source.

#+BEGIN_SRC emacs-lisp
(use-package org-fragtog
  :if (and (skj/current-feature-required-p) window-system)
  :hook (org-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'preview)
(skj/feature-end 'latex)
#+END_SRC

** RFC Reader

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'rfc "RFC Editing")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package rfc-mode
  :if (skj/current-feature-required-p)
  :commands (rfc-mode-browse rfc-mode-read)
  :custom
  (rfc-mode-directory (expand-file-name "~/Documents/rfc/")))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'rfc)
#+END_SRC

** Spell and Style Checking

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'spelling "Spell and Style Checking")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package ispell
    :ensure nil
    :defer 1
    :config
    (setq ispell-program-name (executable-find "aspell"))
    (let* ((env-language (getenv "LANG"))
	       (dictionary (first (split-string env-language "\\."))))
      (setq ispell-extra-args (list (concat "--lang=" dictionary)))))

  (use-package flyspell
    :defer 2
    :after (flycheck ispell)
    :diminish
    :custom
    (flyspell-issue-message-flag nil)
    :hook ((text-mode . flyspell-mode)
           (prog-mode . flyspell-prog-mode)))

  (use-package flyspell-lazy
    :after flyspell
    :commands (flyspell-lazy-mode)
    :defines (flyspell-lazy-idle-seconds
              flyspell-lazy-window-idle-seconds)
    :custom
    (flyspell-lazy-idle-seconds 1)
    (flyspell-lazy-window-idle-seconds 3)
    :config
    (flyspell-lazy-mode +1))

  (use-package flyspell-correct-ivy
    :after (flyspell ivy)
    :custom
    (flyspell-correct-interface #'flyspell-correct-ivy)))
#+END_SRC

I tried the package =auto-dictionary= but for some reason this keeps choosing Portuguese as my language. Funnily enough, I
don't speak Portuguese.

[[https://github.com/bnbeckwith/writegood-mode][Writegood mode]] is a minor mode to aid in finding common writing problems. Matt Might’s [[http://matt.might.net/articles/shell-scripts-for-passive-voice-weasel-words-duplicates/][weaselwords]] scripts inspired this
mode. As well as the additional weasel words it is possible to add to the irregular passive voice verbs in
=writegood-passive-voice-irregulars=.

#+BEGIN_SRC emacs-lisp
(use-package writegood-mode
  :if (skj/current-feature-required-p)
  :diminish writegood-mode
  :custom
  (dolist (word '("least" "most" "occasionally"))
    (add-to-list 'writegood-weasel-words word))
  :hook ((markdown-mode . writegood-mode)
         (gfm-mode . writegood-mode)
         (LaTeX-mode . writegood-mode)
         (org-mode . writegood-mode)
         (text-mode . writegood-mode)))
#+END_SRC

This is more a batch checker, you run the external tool =style= on a buffer or region. To check writing style, execute:
=M-x smog-check-buffer<RET>=.

#+BEGIN_SRC emacs-lisp
(use-package smog
  :if (skj/current-feature-required-p)
  :ensure-system-package style
  :custom
  (smog-command "style -L en"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'spelling)
(skj/feature-end 'writing)
#+END_SRC


* Developer Configuration

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'dev "Development Configuration")
#+END_SRC

Create a sub-group for developer settings, this keeps them away from core configuration.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  (defgroup skj-dev nil
    "Simon's developer settings."
    :tag "Developer settings"
    :group 'skj
    :tag "skj-dev"
    :prefix "skj-dev/"))
#+END_SRC

** UI Settings

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'ui "UI Settings")
#+END_SRC

*** Prettify Things

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'pretty "Prettify Things")
#+END_SRC

While "/prettification/" may be a nice feature throughout it is particularly nice when programming. Emacs 24.4 =prog-mode=
comes with a builtin =prettify-symbols-mode=. It is customized by changing =prettify-symbols-alist=.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package prettify-symbols-mode
    :ensure nil)

  (use-package prog-mode
    :ensure nil
    :after prettify-symbols-mode
    :if (skj/current-feature-required-p)
    :hook prettify-symbols-mode))
#+END_SRC

The packages =prettify-math= and =prettify-greek= extend the configuration above. The math package requires we set the
delimiters before the module loaded.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package prettify-math
    :custom
    (prettify-math-delimiters-alist
     '(("$" tex)
       ("$$" tex block)
       (("\\(" . "\\)") tex block)
       ("`" asciimath)
       ("``" asciimath block))))

  (use-package prettify-greek
    :config
    (prettify-symbols-alist
     (append prettify-symbols-alist prettify-greek-lower))))
#+END_SRC

=fira-code-mode= is a simple minor mode for [[https://github.com/tonsky/FiraCode][Fira Code]] ligatures. You can pre-install the fonts with the command =M-x
fira-code-mode-install-fonts<RET>=.

#+BEGIN_SRC emacs-lisp
(use-package fira-code-mode
  :if (and (skj/current-feature-required-p) window-system)
  :hook (prog-mode . fira-code)
  :config (fira-code-mode-set-font))
#+END_SRC

This enables left-hand line numbers, the types are ~'relative~, ~'visual~, and ~t~ for absolute.

#+BEGIN_SRC emacs-lisp
(use-package display-line-numbers
  :if (skj/current-feature-required-p)
  :ensure nil
  :custom
  (display-line-numbers-type t)
  :hook (prog-mode . display-line-numbers-mode)
  :config
  (set-face-attribute 'line-number nil :foreground "#eee8d5")
  (set-face-attribute 'line-number-current-line nil :weight 'normal :foreground "#93a1a1"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'pretty)
#+END_SRC

*** Structural Editing

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'structure "Structural Editing")
#+END_SRC

Mostly useful for lispy languages this keeps parentheses matching so it's not possible to screw up, well, it's less
likely.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package smartparens
    :diminish smartparens-mode
    :config
    ;; part of the parent package, setup defaults
    (require 'smartparens-config)
    ;; override behavior for Emacs losp
    (sp-with-modes '(emacs-lisp-mode inferior-emacs-lisp-mode)
      (sp-local-pair "`" nil :actions nil)
      (sp-local-pair "'" nil :actions nil))
    :hook
    ((emacs-lisp-mode
      inferior-emacs-lisp-mode
      racket-mode
      racket-repl-mode) . smartparens-strict-mode)))
#+END_SRC

But definitely add [[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] so you can more easily see matching parenthesis.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :if (skj/current-feature-required-p)
  :diminish rainbow-delimiters-mode
  :hook (prog-mode . 'rainbow-delimiters))
#+END_SRC

This can be a real benefit where indent rules are well-defined.

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :if (skj/current-feature-required-p)
  :diminish aggressive-indent-mode
  :config
  (add-to-list 'aggressive-indent-excluded-modes 'make-mode))
#+END_SRC

Visual cues for indentation can also be helpful for lining up in languages like HTML or lisp.

#+BEGIN_SRC emacs-lisp
(use-package highlight-indent-guides
  :if (skj/current-feature-required-p)
  :hook (prog-mode)
  :custom
  (highlight-indent-guides-method 'character)
  (highlight-indent-guides-responsive 'stack)
  (set-face-foreground 'highlight-indent-guides-character-face
                       (alist-get 'magenta skj/theme-core-color-alist)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'structure)
#+END_SRC

*** Compilation

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'compile "Compilation")
#+END_SRC

Major mode for compilation log buffers. To visit the source for a line-numbered error, move point to the error message
line and type =RET=. To kill the compilation, type =C-c C-k=.

#+BEGIN_SRC emacs-lisp
(use-package compile
  :ensure t ;; builtin
  :if (skj/current-feature-required-p))
#+END_SRC

This is a minimalist package that enhances ~compilation-mode~ in the following ways.

- Support color output.
- Support progress updates on a single line (as used by ninja, sphinx and many other build systems).
- Use scrolling behavior similar to most terminals.
- Optionally use foreground & background independent of theme colors.

#+BEGIN_SRC emacs-lisp
(use-package fancy-compilation
  :if (skj/current-feature-required-p)
  :after (ansi-color compile)
  :commands (fancy-compilation-mode)
  :hook (compile-mode . fancy-compilation-mode)
  :custom
  (fancy-compilation-override-colors t)
  (fancy-compilation-quiet-prelude t)
  (fancy-compilation-quiet-prolog t))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'compile)
#+END_SRC

*** Generic Completion

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'complete "Completion")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package company-ctags
    :after company
    :config
    (company-ctags-auto-setup))
)
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'complete)
#+END_SRC

*** Odds & Ends

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'oae "Odds & Ends")
#+END_SRC

This package [[https://github.com/tarsius/hl-todo][highlights TODO]]-like tags in buffers.

#+BEGIN_SRC emacs-lisp
(use-package hl-todo
  :if (skj/current-feature-required-p)
  :diminish hl-todo-mode
  :hook (prog-mode . hl-todo-mode))
#+END_SRC

Optional minor mode to enable /sub-word/ [[https://www.gnu.org/software/emacs/manual/html_node/ccmode/Subword-Movement.html][movement and editing]].

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package syntax-subword
    :diminish syntax-subword-mode
    :hook (subword-mode . syntax-subword-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package syntax-subword
    :diminish syntax-subword-mode
    :hook (subword-mode . syntax-subword-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'oae)
(skj/feature-end 'ui)
#+END_SRC

** Project Support

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'project "Project Support")
#+END_SRC

*** Projectile

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'projectile)
#+END_SRC

Projectile is a project interaction library for Emacs. Its goal is to provide a nice set of features operating on a
project level without introducing external dependencies (when feasible).

=projectile-git-autofetch= is a minor mode for Emacs to automatically fetch repositories you are currently working on (by
default, all open repositories known to projectile).

=project-explorer= provides a tree-based project explorer sidebar.

=org-projectile= ([[https://github.com/IvanMalison/org-projectile][link]]) provides functions for the creation of =org-mode= TODOs that are associated with =projectile= projects.

After adding/removing projects, run =M-x projectile-discover-projects-in-search-path=.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package projectile
    :defer 2
    :commands projectile-mode
    :diminish projectile-mode
    :after (hydra)
    :bind (:map projectile-mode-map
                ("s-p" . projectile-command-map)
                ("C-c p" . projectile-command-map))
    :custom
    (projectile-auto-discover t)
    (projectile-completion-system 'ivy)
    (projectile-enable-caching t)
    (projectile-require-project-root t)
    (projectile-project-search-path (list skj/project-root-dir))
    :config
    ;; steal more from https://docs.projectile.mx/projectile/configuration.html#projectile-commander    
    (pretty-hydra-define hydra-projectile
      (:color blue :quit-key "q" :title "🗁  Projectile")
      ("Projects"
       (("a"   projectile-discover-projects-in-directory "Discover Projects")
        ("s"   counsel-projectile-switch-project           "Switch Project")
        ("x"   projectile-remove-known-project     "Remove Known Project")
        ("c"   projectile-invalidate-cache         "Clear Cache")
        ("X"   projectile-cleanup-known-projects   "Cleanup Known Projects")
        ("c"   projectile-configure-project        "Configure"))
       "Directories"
       (("d"   counsel-projectile-find-dir                 "Find Directory")
        ("e"   projectile-dired                    "Open Dired at root")
        ("v"   projectile-vc                       "Open Magit"))
       "Files"
       (("f"   counsel-projectile-find-file                "Find File")
        ("r"   projectile-recentf                  "Recent Files")
        ("g"   counsel-projectile-rg                  "Ripgrep Files")
        ("z"   projectile-cache-current-file       "Cache Current File"))
       "Buffers"
       (("o"   projectile-multi-occur              "Multi Occur")
        ("b"   counsel-projectile-switch-to-buffer         "Switch to Buffer")
        ("k"   projectile-kill-buffers             "Kill Buffers"))))   
    (bind-key "<f9> p" 'hydra-projectile/body)
    (projectile-global-mode))

  (use-package projectile-git-autofetch
    :after projectile
    :config (projectile-git-autofetch-mode 1))

  (use-package projectile-ripgrep
    :after (ripgrep projectile))

  (use-package org-projectile
    :after (org projectile))

  (use-package counsel-projectile
    :after (counsel projectile)
    :hook (projectile-mode . counsel-projectile))

  ;; invoke via flycheck-projectile-list-errors
  (use-package flycheck-projectile
    :after (flycheck projectile)
    :bind (:map projectile-command-map
                ("A" . flycheck-projectile-list-errors))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'projectile)
#+END_SRC

*** iBuffer Integration

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'ibuffer "iBuffer Integration")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ibuffer-projectile
  :if (skj/current-feature-required-p)
  :after (ibuffer projectile)
  :hook
  (ibuffer . (lambda ()
               (ibuffer-projectile-set-filter-groups)
               (unless (eq ibuffer-sorting-mode 'alphabetic)
                 (ibuffer-do-sort-by-alphabetic)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'ibuffer)
#+END_SRC

*** Project Explorer

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'explorer)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package project-explorer
  :if (skj/current-feature-required-p)
  :custom
  (pe/filenotify-enabled t)
  (pe/inline-folders t)
  (pe/omit-gitignore t)
  (pe/side 'left)
  (pe/width 40)
  :bind
  ("<f8>" . project-explorer-toggle))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'explorer)
#+END_SRC

*** Find Files

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'ivy "Ivy Find Files")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package find-file-in-project
  :if (skj/current-feature-required-p)
  :config (ivy-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'ivy)
(skj/feature-end 'project)
#+END_SRC

** Tree-Sitter (Generic)

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'tree-sitter "Tree-Sitter (Generic)")
#+END_SRC

The following is a necessary [[https://emacs-tree-sitter.github.io/installation/][package]] until tree-sitter is added to the Emacs core in version 29, in =treesit.el=. The
minor mode =tree-sitter-mode= provides a buffer-local syntax tree, which is kept up-to-date with changes to the buffer’s
text. In this case I only enable support for specific languages and modes in their own configuration below via hooks.
Alternatively support can be enabled for all languages with =:config (global-tree-sitter-mode)=.

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p)
           (< emacs-version-number 29))

  (use-package tree-sitter)

  (use-package tree-sitter-langs
    :after tree-sitter))
#+END_SRC

- Run =M-x tree-sitter-hl-mode= to replace the regex-based highlighting provided by =font-lock-mode= with tree-based syntax
  highlighting.
- Run =M-x tree-sitter-debug-mode= to show the current buffer’s syntax tree in a separate buffer.
- Run =M-x tree-sitter-query-builder= to open the query playground, where you can write tree queries and see matches
  highlighted in the source buffer.

  
#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p)
           (< emacs-version-number 29))

  (use-package tree-sitter-indent
    :after tree-sitter)

  (use-package tree-sitter-ispell
    :after tree-sitter))
#+END_SRC

Code folding is a great feature, unfortunately at this point the ~ts-fold~ packages need to be loaded directly from the
filesystem.
  
#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p)
           (< emacs-version-number 29))

  (skj/git-clone "https://github.com/emacs-tree-sitter/ts-fold.git"
                 "/Users/simonjo/Projects/ts-fold")

  (use-package ts-fold
    :after tree-sitter
    :diminish ts-fold-mode
    :load-path "/Users/simonjo/Projects/ts-fold")

  (use-package fringe-helper)

  (use-package ts-fold-indicators
    :after (ts-fold fringe-helper)
    :diminish ts-fold-indicator-mode
    :load-path "/Users/simonjo/Projects/ts-fold"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'tree-sitter)
#+END_SRC

** Language Server (Generic)

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'lsp "Language Server (Generic)")
#+END_SRC

- Documentation: https://emacs-lsp.github.io/lsp-mode/
- Supported language servers: https://emacs-lsp.github.io/lsp-mode/page/languages/

#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :if (skj/current-feature-required-p)
  :commands lsp
  :custom
  (lsp-completion-provider :capf)
  (lsp-idle-delay 0.6)
  (lsp-keep-workspace-alive nil)
  (lsp-keymap-prefix "M-o")
  (lsp-lens-enable t)
  (lsp-signature-doc-lines 5)
  :hook (lsp-mode . yas-minor-mode)
  :hook (lsp-mode . lsp-lens-mode))
#+END_SRC

This package contains all the higher level UI modules of =lsp-mode=, like flycheck support and code lenses.

#+BEGIN_SRC emacs-lisp
(use-package lsp-ui
  :if (skj/current-feature-required-p)
  :commands lsp-ui-mode
  :custom
  (lsp-ui-doc-enable nil)
  (lsp-ui-doc-position 'bottom)
  (lsp-ui-peek-always-show t)
  (lsp-ui-peek-fontify 'always)
  (lsp-ui-sideline-enable t)
  (lsp-ui-sideline-show-hover t)
  :hook (lsp-mode . lsp-ui-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;;;###autoload
(defun skj/imenu-toggle-maybe-lsp ()
  "Toggle an imenu list popup; it will use lsp-ui if it is enabled."
  (interactive)
  (if (bound-and-true-p lsp-mode)
	  (lsp-ui-imenu)
    (imenu-list-smart-toggle)))
#+END_SRC

This package provides an interactive =ivy= interface to the workspace symbol functionality offered by =lsp-mode=.

- ~lsp-ivy-workspace-symbol~ - workspace symbols for the current workspace
- ~lsp-ivy-global-workspace-symbol~ - workspace symbols from all of the active
  workspaces.

#+BEGIN_SRC emacs-lisp :exports none
(use-package lsp-ivy
  :if (skj/current-feature-required-p)
  :after (lsp ivy))
#+END_SRC

*Key Bindings/Commands*

- =completion-at-point= for completions
- Signatures when writing methods (/=C-n=/, /=C-p=/ to cycle signatures)
- =lsp-find-definition=: /=C-c l g r=/
- =lsp-find-references=: /=C-c l g g=/
- =lsp-rename=: /=C-c l r r=/
- =lsp-format-buffer=: /=C-c l ==/
- =lsp-ui-peek-find-references= to show references inline (/=M-n=/, /=M-p=/ to cycle)

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'lsp)
#+END_SRC

** Test and Debug

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'test "Test and Debug")
#+END_SRC

Toggle Test allows you to quickly switch between test and test subject. This
is a very useful tool to have when you are TDDing.

#+BEGIN_SRC emacs-lisp
(use-package toggle-test
  :config
  (global-set-key (kbd "C-c t") 'tgt-toggle))
#+END_SRC

*** Coverage

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'coverage)
#+END_SRC

=cov= shows code coverage data for your program in emacs. Currently, it supports =gcov=, =lcov=, =coverage.py=, and =clover=
output, as well as the Coveralls format produced by =undercover.el=.

#+BEGIN_SRC emacs-lisp
(use-package cov)
#+END_SRC

Need to customize either ~cov-coverage-file-paths~ or ~cov-coverage-file-paths~ for different coverage tools/languages.

Alternatively, consider [[https://github.com/twada/coverlay.el][coverlay.el]] or [[https://github.com/undercover-el/undercover.el][undercover.el]].

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'coverage)
#+END_SRC

*** Regex Tools

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'regex-tools)
#+END_SRC

The [[https://github.com/jwiegley/regex-tool][regex-tool]] package provides the common three-pane (regex, text, groups) view for testing regular expressions against
test text. Use =C-c C-c= to force an update.  Use =C-c C-k= to quit all the regex-tool buffers and remove the frame.

#+BEGIN_SRC emacs-lisp
(use-package regex-tool
  :if (skj/current-feature-required-p))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'regex-tools)
#+END_SRC

*** DAP Settings

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'dap "DAP Settings")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package dap-mode
    :custom
    (dap-auto-configure-features
                  '(sessions locals controls tooltip))
    :config
    (dap-mode 1))

  (use-package dap-ui
    :ensure nil
    :config
    (dap-ui-mode 1)
    (dap-ui-controls-mode 1)
    ;; Enables mouse hover support
    (dap-tooltip-mode 1)
    ;; Use tooltips for mouse hover,
    ;; if it is not enabled `dap-mode' will use the minibuffer.
    (tooltip-mode 1)
    ;; Displays floating panel with debug buttons
    (dap-ui-controls-mode 1)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'dap)
#+END_SRC

*** REST & SOAP Clients

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'clients "REST & SOAP Clients")
#+END_SRC

~[[https://github.com/federicotdn/verb][verb-mode]]~ - a powerful HTTP/REST client. This allows an org-mode first approach
to testing and documenting services.

#+BEGIN_SRC emacs-lisp
(use-package verb
  :if (skj/current-feature-required-p)
  :config
  (add-to-list 'http-content-type-mode-alist
               '("application/json" . json-mode)))
#+END_SRC

The ~[[https://github.com/pashky/restclient.el][restclient-mode]]~ REST client set of tools.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package restclient)

  (use-package company-restclient
    :after restclient
    :commands company-restclient
    :init
    (add-to-list 'company-backends 'company-restclient t))

  (use-package restclient-test
    :after restclient)

  (use-package ob-restclient
    :after (org restclient))

  (skj/org-babel-add-languages 'restclient))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package soap-client
  :if (skj/current-feature-required-p))
#+END_SRC

To inspect a loaded WSDL document, you can do the following:

#+BEGIN_EXAMPLE emacs-lisp
(use-package soap-inspect
  :ensure nil
  :defer nil)

(soap-inspect previously-loaded-wsdl)
#+END_EXAMPLE

~[[https://github.com/emacs-pe/http.el][http-mode]]~ a simplified HTTP client.

#+BEGIN_SRC emacs-lisp
(use-package http
  :if (skj/current-feature-required-p)
  :config
  (add-to-list 'http-content-type-mode-alist
               '("application/json" . json-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'clients)
#+END_SRC

*** Swagger

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'swagger)
#+END_SRC

- =swagg= :: [[https://github.com/isamert/swagg.el][allows you to]] take parse a swagger.json file, and produce an org-mode buffer/file out of it's
  contents.
- =swagger-to-org= :: [[https://github.com/ahungry/swagger-to-org][allows you to]] take parse a =swagger.json= file, and produce an org-mode buffer/file out of it's
  contents.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  (use-package swagg)
  (use-package swagger-to-org))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'swagger)
(skj/feature-end 'test)
#+END_SRC

** Data Formats

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'data "Data Formats")
#+END_SRC

*** ASCII

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'ascii)
#+END_SRC

Show a [[https://github.com/lassik/emacs-ascii-table][character map]] of the ubiquitous 7-bit ASCII character set (128 characters in total).

Do =M-x ascii-table= to bring up a window with the ASCII table. Press =b= for binary, =o= for octal, =d= for decimal and =x= for
hexadecimal. Press =TAB= to change the way control characters are shown.

#+BEGIN_SRC emacs-lisp
(use-package ascii-table :if (skj/current-feature-required-p))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'ascii)
#+END_SRC

*** CSV

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'csv)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package pcsv)

  (use-package csv-mode
    :mode "\\.csv\\'"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'csv)
#+END_SRC

*** JSON

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'json)
#+END_SRC

The JSON parser package `json' is builtin.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package json-mode
    :mode "\\.json\\'")

  (use-package json-navigator)

  (use-package json-reformat))
#+END_SRC

Support for JQ-uery.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package jq-mode
    :ensure-system-package jq
    :after json-mode)

  (use-package counsel-jq
    :after json-mode)

  (use-package restclient-jq
    :ensure nil
    :after (restclient jq-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'json)
#+END_SRC

*** TOML

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'toml)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package toml)

  (use-package toml-mode
    :mode "\\.toml\\'"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'toml)
#+END_SRC

*** YAML

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'yaml)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package yaml-mode
    :hook lsp
    :mode "\\.yaml\\'"
    :init
    (setq-default yaml-indent-offset 2))

  (use-package yaml-imenu
    :after yaml-mode
    :config (yaml-imenu-enable))

  (use-package yaml)

  (use-package yaml-pro
    :after yaml)

  (use-package flycheck-yamllint
    :ensure-system-package yamllint
    :defer t
    :after flycheck
    :hook
    (flycheck-mode . flycheck-yamllint-setup)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'yaml)
(skj/feature-end 'data)
#+END_SRC

** Language Environments

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'lang "Language Environments")
#+END_SRC

[[https://www.tabnine.com/][TabNine]] is the all-language auto-completer. It uses machine learning to provide responsive, reliable, and relevant
suggestions. The package =company-tabnine= provides TabNine completion backend for =company-mode=. It takes care of TabNine
binaries, so installation is easy.

#+BEGIN_SRC emacs-lisp
(use-package company-tabnine
  :if (skj/current-feature-required-p)
  :after company
  :commands company-tabnine
  :init
  (add-to-list 'company-backends 'company-tabnine t)
  :config
  (unless (file-directory-p
           (or company-tabnine-binaries-folder
               (expand-file-name "")))
    (company-tabnine-install-binary)))
#+END_SRC

Emacs Refactor ([[https://github.com/Wilfred/emacs-refactor][EMR]]) is a framework for providing language-specific refactoring in Emacs. It includes refactoring
commands for a variety of languages, including elisp itself!

#+BEGIN_SRC emacs-lisp
(use-package emr
  :if (skj/current-feature-required-p)
  :after projectile
  :commands
  emr-show-refactor-menu
  :bind
  (:map prog-mode-map
   ("M-RET" . emr-show-refactor-menu)))

#+END_SRC

*** BNF-like

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'bnf "BNF-like")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package bnf-mode)

  (use-package ebnf-mode
    :custom
    (ebnf-mode-eop-char ?\;)
    (ebnf-mode-indent-offset 4)
    (ebnf-mode-indent-by-production nil)
    :config
    (setq ebnf-mode-production-re "^\\s-*\\([[:alnum:]_]+\\)\\s-*::=")))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'bnf)
#+END_SRC

*** Emacs Lisp

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'elisp "Emacs Lisp")
#+END_SRC

Before anything else...

#+BEGIN_SRC emacs-lisp
(use-package elisp-mode
  :ensure nil
  :if (skj/current-feature-required-p))
#+END_SRC

A simple but effective thing, =eldoc-mode= is a MinorMode which [[https://www.emacswiki.org/emacs/ElDoc][shows you]], in the echo area, the argument list of the
function call you are currently writing.

#+BEGIN_SRC emacs-lisp
(use-package eldoc
  :ensure nil
  :if (skj/current-feature-required-p)
  :defer 1
  :diminish eldoc-mode
  :custom
  (lsp-eldoc-render-all t)
  :hook ((emacs-lisp-mode
          lisp-interaction-mode
          ielm-mode) . eldoc-mode))
#+END_SRC

*Interactive Tools*

These are editing enhancements for Lisp editing.

- [[https://github.com/xiongtx/eros][eros]] :: Evaluation Result OverlayS for Emacs Lisp.
- [[https://github.com/jwiegley/eval-expr/blob/master/eval-expr.el][eval-expr]] :: Enhanced eval-expression command
- highlight-defined :: Minor mode providing syntax highlighting of known Emacs Lisp symbols.
- highlight-quoted :: Highlight Lisp quotes and quoted symbols
- ipretty :: Provides interactive functions to /pretty-print/ the result of an expression and a global mode ~ipretty-mode~
  that advices ~eval-print-last-sexp~ to pretty print.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package eros :hook (emacs-lisp-mode . eros-mode))

  (use-package eval-expr)

  (use-package highlight-defined
    :custom
    (highlight-defined-face-use-itself t)
    :hook
    ((help-mode emacs-lisp-mode) . highlight-defined-mode))

  (use-package highlight-quoted
    :hook
    (emacs-lisp-mode . highlight-quoted-mode))

  (use-package ipretty
    :config (ipretty-mode 1)))
#+END_SRC

Package [[https://github.com/mhayashi1120/Emacs-erefactor][erefactor]] -- simple refactoring, linting utilities for Emacs-Lisp.

#+BEGIN_SRC emacs-lisp
(use-package erefactor
  :if (skj/current-feature-required-p))
#+END_SRC

*Code Quality*

[[https://github.com/mattiase/relint][Relint]] scans Emacs Lisp files for mistakes in regexps, including deprecated syntax and bad practice. Can be called
interactively with =M-x relint-file= or =M-x relint-current-buffer=. It also checks the regexp-like arguments to the
functions `skip-chars-forward', `skip-chars-backward', `skip-syntax-forward' and `skip-syntax-backward'. Additionally
[[https://github.com/purcell/flycheck-relint][flycheck-relint]] performs these checks continuously.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package relint)

  (use-package flycheck-relint
    :after (flycheck relint)
    :config
    (flycheck-relint-setup)))
#+END_SRC

Elsa is a tool that analyses your code without loading or running it. It is 100% side-effect free and we strive to keep
it that way, so you can analyse any elisp code from anywhere safely.

Elsa adds a powerful type system on top of Emacs lisp (completely optional). In can track types and provide helpful
hints when things don't match up before you even try to run the code.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package elsa)

  (use-package flycheck-elsa
    :after
    (flycheck elsa)
    :custom
    (flycheck-elsa-backend 'eldev)
    :hook
    (emacs-lisp-mode . flycheck-elsa-setup)))
#+END_SRC

The [[https://github.com/purcell/package-lint][package-lint]] library provides a linter for the metadata in Emacs Lisp files which are intended to be packages. You
can integrate it into your build process. package-lint detects various issues that may make your package uninstallable
or unusable for some users, and it warns about significant deviations from the Elisp coding conventions, such as
non-compliant symbol naming, and use of reserved keybindings. Among other community uses, =package-lint= is a prerequisite
for submission of packages to MELPA.
[<35;78;45M
Currently the /flycheck/-checker is only activated if a =;; Package-Requires:=, =;; Version:= or =;; Package-Version:= header is
present in the current buffer.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package package-lint)

  (use-package flycheck-package
    :after (flycheck package-lint)))
#+END_SRC

*Documentation*

[[https://www.emacswiki.org/emacs/CheckDoc][CheckDoc]] checks your Emacs Lisp code for errors in documentation and style. Running CheckDoc is a must before posting to
=gnu.emacs.sources= or uploading to the [[https://www.emacswiki.org/emacs/ElispArea][ElispArea]]. Also added [[https://github.com/Fuco1/elisp-docstring-mode][elisp-docstring-mode]] and [[https://github.com/magnars/string-edit.el][string-edit]] for better docstring
editing.

Call ~string-edit-at-point~ when inside a string. A new buffer pops up with unescaped content, letting you edit it
directly.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package checkdoc
    :ensure nil
    :hook
    (emacs-lisp-mode . checkdoc-minor-mode))

  (use-package elisp-docstring-mode)

  (use-package string-edit-at-point))
#+END_SRC

*Useful Libraries*

Some useful libraries for Emacs lisp development:

- [[https://github.com/langston-barrett/contract.el][contract]] (manual install) :: This library provides facilities for programming Emacs Lisp in the /design by contract/
  style. It's implementation and interface are heavily inspired by Racket's contracts.
- [[https://github.com/magnars/dash.el][dash]] :: A modern list API for Emacs. No ~'cl~ required.
- [[https://github.com/emacsorphanage/ov][ov]] :: Simple way to manipulate overlay for Emacs. Overlay is capable of manipulating text appearance, cursor behavior,
  etc. It doesn't affect font-lock or text-properties.

*Debugging & Profiling*

- [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Edebug.html][edebug]] :: Builtin source-level debugger for Emacs Lisp programs
- [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Profiling.html][elp]] :: The elp library offers an alternative approach, which is useful when you know in advance which Lisp
  function(s) you want to profile.
- [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Profiling.html][profiler]] :: Builtin package -- to begin profiling, type =M-x profiler-start=. You can choose to sample CPU usage
  periodically (=cpu=), when memory is allocated (=memory=), or both. Then run the code you’d like to speed up.
- [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Test-Coverage.html][testcover]] :: Builtin coverage testing for a file of Lisp code by loading the testcover library and using the command
  =M-x testcover-start RET /file/ RET= to instrument the code.
- [[https://github.com/emacs-mirror/emacs/blob/master/lisp/emacs-lisp/trace.el][trace]] :: Builtin tracing facility for Emacs Lisp functions.
- etrace (manual install) :: This package for GNU Emacs allows latency tracing to be performed on Emacs Lisp code and
  the results output to files using the Chromium Catapult Trace Event Format. These trace files can then be loaded into
  trace analysis utilities in order to generate flame graphs and other useful visualisations and analyses.
- [[https://github.com/joddie/macrostep][macrostep]] :: Macrostep is an Emacs minor mode for interactively stepping through the expansion of macros in Emacs Lisp
  source code. It lets you see exactly what happens at each step of the expansion process by pretty-printing the
  expanded forms inline in the source buffer, which is temporarily read-only while macro expansions are visible.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  ;; builtins
  (use-package edebug :ensure nil)

  (use-package elp :ensure nil)

  (use-package profiler :ensure nil)

  (use-package testcover :ensure nil)

  (use-package trace :ensure nil)

  ;; externals
  (use-package macrostep))
#+END_SRC

*Testing*

For unit testing, start with the builtin ERT (Emacs Lisp Regression Testing) library.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package ert :ensure nil)

  (use-package ert-expectations :after ert)

  ;; This seems to create an error: ertml--run-tests: Invalid function: (message (&rest _))
  ;;(use-package ert-modeline
  ;;  :after ert
  ;;  :hook emacs-lisp-mode)
  )
#+END_SRC

*Build Tooling*

Eldev ([[https://github.com/doublep/eldev][Elisp development tool]]) is an Emacs-based build tool, targeted solely at Elisp projects. It is an alternative to
Cask. Unlike Cask, Eldev itself is fully written in Elisp and its configuration files are also Elisp programs. If you
are familiar with Java world, Cask can be seen as a parallel to Maven — it uses project description, while Eldev is sort
of a parallel to Gradle — its configuration is a program on its own.

Run the following id the =eldev= command is not found.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (unless (executable-find  "eldev")

    (defun skj/run-string-as-script (content)
      (let* ((script-file (make-temp-file "emacs-eldev-")))
        (write-region content nil script-file)
        (call-process "sh" nil "eldev" nil script-file)))

    (use-package request
      :defer nil
      :config
      (request "https://raw.github.com/doublep/eldev/master/bin/eldev"
        :success (lambda (&rest arg-plist)
                   (skj/run-string-as-script
                    (plist-get arg-plist :data)))))

    (let ((file-path (concat-path skj/local-bin-dir "eldev-initx")))
      (write-region
       "#!/usr/bin/env bash

if [[ ! -f Eldev ]]; then
    eldev init --non-interactive
fi

if [[ -d githooks ]]; then
    eldev githooks
fi
"
       nil
       file-path)
      (set-file-modes file-path #o700))

    (let* ((config-dir (concat-path (xdg-config-home) "eldev"))
           (config-file (concat-path config-dir "config")))
      (make-directory config-dir)
      (write-region
       "; -*- mode: emacs-lisp; lexical-binding: t; -*-

; This file is for eldev startup configuration.

(setf eldev-coloring-mode t)
"
       nil
       config-file)
      (set-file-modes config-file #o600))))
#+END_SRC

Run the following when the =eldev= command is found, which may have been installed in the previous block.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (when (executable-find  "eldev")

    (use-package eldev)

    (use-package flycheck-eldev
      :after (flycheck eldev))))

;; (call-process (format "%s %s" (executable-find "eldev") "upgrade-self"))
#+END_SRC

More documentation [[https://doublep.github.io/eldev/][here]].

*Emacs Lisp Repl*

Because the builtin =ielm=, /inferior emacs lisp mode/, is damn hard to remember, here's a simple shortcut.

#+BEGIN_SRC emacs-lisp
(use-package ielm
  :ensure nil
  :if (skj/current-feature-required-p)
  :init
  (defalias 'emacs-lisp-repl 'ielm))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'elisp)
#+END_SRC

*** Common Lisp

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'common-lisp)
#+END_SRC

Get an implementation:

- SBCL :: [[http://www.sbcl.org/][Steel Bank Common Lisp]] is a high performance Common Lisp compiler. It is open source / free software, with a
  permissive license. In addition to the compiler and runtime system for ANSI Common Lisp, it provides an interactive
  environment including a debugger, a statistical profiler, a code coverage tool, and many other extensions.
  - install: brew install sbcl
- CLISP :: [[https://clisp.sourceforge.io/][GNU Common Lisp]]
  - install: brew install clisp
- Clozure CL :: Clozure Common Lisp (Clozure CL, or CCL) is a free Common Lisp implementation with a long history. Some
  distinguishing features of the implementation include fast compilation speed, native threads, a precise, generational,
  compacting garbage collector, and a convenient foreign-function interface.
  - install: brew install clozure-cl
- Allegro CL :: is the most powerful dynamic object-oriented development system available today, and is especially
  suited to enterprise-wide, complex application development. Complex applications with billions of objects are now made
  easy with [[https://franz.com/products/allegro-common-lisp/][Allegro CL 10]]. The command-line tool is =alisp=.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defconst skj-dev/common-lisp-executable-alist
    '((allegro . "alist")
      (allegro-express . "allegro-express")
      (ccl . "dx86cl64")
      (clisp . "clisp")
      (sbcl . "sbcl")))
  
  (defcustom skj-dev/common-lisp-packages '(clisp sbcl)
    "Name of Common Lisp implementations to enable."
    :tag "Enabled Common Lisps"
    :type '(repeat
            (choice
             (const :tag "Allegro CL" allegro)
             (const :tag "Allegro Express" allegro-express)
             (const :tag "Clozure CL" ccl)
             (const :tag "GNU Common Lisp" clisp)
             (const :tag "Steel Bank Common Lisp" sbcl)))
    :group 'skj-dev)
  
  (defcustom skj-dev/common-lisp-interpreter 'sbcl
    "Name of the default Common Lisp interpreter to connect to."
    :tag "Common Lisp interpreter"
    :type '(radio
            (const :tag "Allegro CL" allegro)
            (const :tag "Allegro Express" allegro-express)
            (const :tag "Clozure CL" ccl)
            (const :tag "GNU Common Lisp" clisp)
            (const :tag "Steel Bank Common Lisp" sbcl))
    :group 'skj-dev)

  (defun skj-dev/common-lisp-executable ()
    (let* ((name skj-dev/common-lisp-interpreter)
           (executable (assoc name skj-dev/common-lisp-executable-alist)))
      (unless (null executable)
        (file-truename (executable-find (cdr executable)))))))
#+END_SRC

Quicklisp – [[https://www.quicklisp.org/beta/][Quicklisp]] is a library manager for Common Lisp. It works with your existing Common Lisp implementation to
download, install, and load any of over 1,200 libraries with a few simple commands.

Note that the installation procedure creates a new file =setup.lisp= in the =quicklisp=, load this once setup, not the
original file.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defun skj-dev/common-lisp-run-script (file &optional expr destination)
    (let* ((interpreter skj-dev/common-lisp-interpreter)
           (args (cond
                  ((eq interpreter 'ccl) '("--load" "--eval" ""))
                  ((eq interpreter 'clisp) '("-i" "-x" ""))
                  ((eq interpreter 'sbcl) '("--load" "--eval" "--quit"))
                  (t nil)))
           (load-arg (string-join (list (car args) file) " "))
           (eval-arg (if (null expr)
                         ""
                       (string-join (list (cadr args) (shell-quote-argument expr)) " ")))
           (quit-arg (caddr args)))
      (if (null args)
          (init-message "Could not load quicklisp for %s" skj-dev/common-lisp-interpreter)
        (call-process (string-join (list
                                    (skj-dev/common-lisp-executable)
                                    load-arg
                                    eval-arg
                                    quit-arg)
                                   " ")
                      nil
                      destination))))

  (let ((quicklisp-file "quicklisp.lisp")
        (quicklisp-directory (expand-file-name "~/quicklisp"))
        (quicklisp-url "https://beta.quicklisp.org/"))

    (unless (file-directory-p quicklisp-directory)
      (make-directory quicklisp-directory)

      (let ((quicklisp-source (expand-file-name
                               (concat-path quicklisp-directory
                                            quicklisp-file)))
            (quicklisp-sig (expand-file-name
                            (concat-path quicklisp-directory
                                         (concat quicklisp-file ".asc"))))
        (require 'url) ; built-in
        (url-copy-file (concat quicklisp-url quicklisp-file)
                       quicklisp-source)
        (url-copy-file (concat quicklisp-url quicklisp-file ".asc")
                       quicklisp-sig)

        (require 'epa) ; built-in
        (epa-verify-file quicklisp-sig)

        ;; Install with current runtime.
        (skj-dev/common-lisp-run-script quicklisp-source
                                        "(quicklisp-quickstart:install)"
                                        "*Quicklisp Install*"))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package slime
    :custom
    (inferior-lisp-program (skj-dev/common-lisp-executable))
    (slime-complete-symbol*-fancy t)
    (slime-complete-symbol-function 'slime-fuzzy-complete-symbol)
    (slime-contribs '(slime-fancy slime-fancy-inspector slime-fancy-inspector slime-quicklisp)))

  (use-package slime-company
    :after (slime company)
    :commands slime-setup
    :custom
    (slime-company-completion 'fuzzy)
    (slime-company-after-completion 'slime-company-just-one-space)
    :init
    (slime-setup '(slime-fancy slime-company)))

  (use-package slime-repl-ansi-color
    :after slime
    :config
    (slime-setup '(slime-repl-ansi-color)))

  (use-package elisp-slime-nav
    :after slime
    :hook
    ((emacs-lisp-mode ielm-mode) . elisp-slime-nav-mode)))
#+END_SRC

Browse the Common Lisp HyperSpec documentation for the symbol at point.

#+BEGIN_SRC emacs-lisp
(use-package clhs
  :if  (skj/current-feature-required-p)
  :after etags
  :commands clhs-doc
  :bind
  (:map help-ap ("\C-l" . clhs-doc))
  :config
  (custom-set-variables
   '(tags-apropos-additional-actions
     '(("Common Lisp" clhs-doc clhs-symbols)))))
#+END_SRC

This is a collection of Yasnippets for Common Lisp. It includes snippets for top-level forms.

#+BEGIN_SRC emacs-lisp
(use-package common-lisp-snippets
  :if  (skj/current-feature-required-p))
#+END_SRC

Here would be a good place for Clojure too.

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'common-lisp)
#+END_SRC

*** Scheme

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'scheme)
#+END_SRC

Homebrew knows about =chezscheme=, =chibi-scheme=, =gambit-scheme=, =gerbil-scheme=, =mit-scheme=, =racket=, =sagittarius-scheme=,
=scheme48=, and =sisc-scheme=. However, chez does not currently work on Apple Silicon and MIT scheme has stopped building
and been removed by brew.

Client for the Scheme LSP server. Currently this client only supports CHICKEN 5, Gambit 4.9.4+ and Guile 3.

#+BEGIN_SRC emacs-lisp
(use-package lsp-scheme
  :if (skj/current-feature-required-p)
  :after lsp-mode
  :defer 4
  :hook
  (scheme-mode . lsp-scheme-guile))
#+END_SRC

Geiser ([[https://www.nongnu.org/geiser/][home]]) is a generic Emacs/Scheme interaction mode, featuring an enhanced REPL and a set of minor modes improving
Emacs' basic scheme major mode.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (setq geiser-active-implementations '(guile))
  
  (use-package geiser)

  (use-package geiser-repl
    :ensure nil ;; included in geiser
    :after geiser)

  (use-package macrostep-geiser
    :after (geiser geiser-repl)
    :hook
    ((geiser-mode . macrostep-geiser-setup)
     (geiser-repl-mode . macrostep-geiser-setup))))
#+END_SRC

Geiser implementations.

See [[https://cisco.github.io/ChezScheme/]].
  
#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p)
           (member 'chez geiser-active-implementations)
           (not (system-mac-p)))
  (use-package geiser-chez
    :after geiser
    :ensure-system-package chezscheme))
#+END_SRC

See [[https://github.com/ashinn/chibi-scheme]].

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p)
           (member 'chibi geiser-active-implementations))
  (use-package geiser-chibi
    :after geiser
    :ensure-system-package chibi-scheme))
#+END_SRC

See [[https://call-cc.org/]].

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p)
           (member 'chicken geiser-active-implementations))
  (use-package geiser-chicken
    :after geiser
    :ensure-system-package chicken))
#+END_SRC

See [[https://gambitscheme.org/]].

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p)
           (member 'gambit geiser-active-implementations))
  (use-package geiser-gambit
    :after geiser
    :ensure-system-package gambit-scheme))
#+END_SRC

See [[https://practical-scheme.net/gauche/]].

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p)
           (member 'gauche geiser-active-implementations))
  (use-package geiser-gauche
    :after geiser
    :ensure-system-package gauche))
#+END_SRC

See [[https://www.gnu.org/software/guile/]].

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p)
           (member 'guile geiser-active-implementations))

  (use-package geiser-guile
    :after geiser
    :ensure-system-package guile
    :init
    (add-to-list 'geiser-implementations-alist '((regexp "\\.scm\\'") guile))
    :custom
    (geiser-guile-binary (executable-find "guile")))

  (use-package flycheck-guile))
#+END_SRC

See [[https://www.gnu.org/software/mit-scheme/]].

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p)
           (member 'mit geiser-active-implementations)
           (not (system-mac-p)))
  (use-package geiser-mit
    :after geiser
    :ensure-system-package mit-scheme
    :custom
    (geiser-mit-binary (executable-find "scheme"))))
#+END_SRC

See [[http://racket-lang.org/]].

#+BEGIN_SRC emacs-lisp
(when (and (skj/current-feature-required-p)
           (member 'racket geiser-active-implementations))
  (use-package geiser-racket
    :after geiser
    :ensure-system-package racket
    :init
    (add-to-list 'geiser-implementations-alist '((regexp "\\.rkt\\'") racket))
    :custom
    (geiser-racket-binary (executable-find "racket"))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'scheme)
#+END_SRC

*** Racket

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'racket)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package dr-racket-like-unicode)

  (use-package racket-mode
    :ensure-system-package racket
    :hook (racket-mode . racket-xp-mode))

  (use-package scribble-mode
    :after racket-mode
    :hook (scribble-mode . display-line-numbers-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'racket)
#+END_SRC

*** Ada

Not currently using this, but have used the following:

- =eglot= as an LSP client to the AdaCore (GNAT) [[https://github.com/AdaCore/ada_language_server][ALS]].
- =ada-mode=
- =ada-ref-man=
- =ob-ada-spark=
- =gpr-yasnippets=


It is important to note that you not only need a compiler (again, AdaCore) but also the [[https://alire.ada.dev/][Alire]] package manager. Download
=alr= and run =alr toolchain --select= to get an Ada environment installed.

*** Rust

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'rust)
#+END_SRC

The key to Rust development in Emacs is the [[https://github.com/brotzeit/rustic][Rustic]] package. This wraps and extends the older [[https://github.com/rust-lang/rust-mode][rust-mode]] and other tools.

- https://robert.kra.hn/posts/rust-emacs-setup/

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defun rustic-mode-auto-save-hook ()
    "Enable auto-saving in rustic-mode buffers."
    (when buffer-file-name
      (setq-local compilation-ask-about-save nil)))

  (defun rustic-mode-minor-modes ()
    ;; Mode for displaying code-lens overlays.
    (lsp-lens-mode 1)
    ;; Enable subword movement and editing (Subword mode).
    (syntax-subword-mode 1)
    ;; Set buffer default fill column.
    (set-fill-column 100))
  
  (use-package rustic
    :hook
    ((rustic-mode . rustic-mode-minor-modes)
     (rustic-mode . rustic-mode-auto-save-hook))
    :config
    ;; org-mode Babel formatting
    (setq rustic-babel-format-src-block t)
    (setq rustic-babel-auto-wrap-main t)
    ;; ------------------------------------------------------
    ;; run cargo fmt on all file saves!
    (setq rustic-format-on-save t)
    (setq rustic-format-trigger 'on-save)
    ;; Enable clippy using cargo watch
    (setq lsp-rust-analyzer-cargo-watch-enable t)
    (setq lsp-rust-analyzer-cargo-watch-command "clippy")
    ;; set the lsp server to use
    (setq rustic-lsp-server 'rust-analyzer)
    ;; ?
    (setq lsp-rust-analyzer-cargo-load-out-dirs-from-check t)
    ;; lsp feature switches
    (setq lsp-rust-analyzer-display-chaining-hints t)
    (setq lsp-rust-analyzer-display-parameter-hints t)
    (setq lsp-rust-analyzer-proc-macro-enable t)
    (setq lsp-rust-analyzer-server-display-inlay-hints t)))

  ;(add-hook 'rustic-mode-hook 'rustic-mode-minor-modes)
  ;(add-hook 'rustic-mode-hook 'rustic-mode-auto-save-hook))
#+END_SRC


#+BEGIN_SRC emacs-lisp
(use-package cargo-mode
  :after rustic
  :hook (rustic-mode . cargo-minor-mode))
#+END_SRC

This package will attempt to add a =use= statement for the symbol at point; =M-x rust-auto-use=.

#+BEGIN_SRC emacs-lisp
(use-package rust-auto-use
  :if (skj/current-feature-required-p)
  :after rustic)
#+END_SRC

This sets up the ability to switch between code and tests for the code.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defun skj/rust-setup-toggle-test ()
    "Set the `toggle-test' configuration for the current Rust project."
    (interactive)
    (let ((root (projectile-project-root)))
      (if root
          (if (file-exists-p (concat-path root "Cargo.toml"))
              (progn
                (add-to-list 'tgt-projects
                             (cons
                              (list :root-dir root)
                              '((:src-dirs "src")
                                (:test-dirs "tests")
                                (:test-prefixes "test_"))))
                (message "Added toggle-test for %s" root))
            (message "Project root is not a Rust project"))
        (message "No project root"))))

  (add-hook 'rustic-mode 'skj/rust-setup-toggle-test))
#+END_SRC

DAP debugger profile for Rust.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (add-hook 'rustic-mode-hook
            (lambda () (require 'dap-mode)
              (dap-register-debug-template
               "Rust::GDB Run Configuration"
               (list :type "gdb"
                     :request "launch"
                     :name "GDB::Run"
                     :gdbpath "rust-gdb"
                     :target nil
                     :cwd nil)))))
#+END_SRC

Access Rust documentation from within emacs. You can now convert package-specific documentation with
~rustic-doc-convert-current-package~. Search the org files with ~rustic-doc-search~ (bound to =C-#= by default) if you are in
Rust mode, Rustic mode or Org mode. If you hover over a symbol when you invoke the command, ~rustic-doc-search~ will
insert a default value.

#+BEGIN_SRC emacs-lisp
(use-package rustic-doc
  :ensure nil
  :if (skj/current-feature-required-p)
  :after (org rustic)
  :ensure-system-package
  (fd
   pandoc
   (cargo-makedocs . "cargo install cargo-makedocs"))
  :diminish rustic-doc-mode
  :config
  (rustic-doc-setup))
#+END_SRC

Make a better ~rustic-popup~.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (pretty-hydra-define hydra-rust
    (:color blue :quit-key "q" :title "🦀 Rust")
    ("Build"
     (("b"    rustic-cargo-build              "Build")
      ("c d"  rustic-cargo-build-doc          "Build Docs")
      ("c o"  rustic-cargo-doc                "Open Docs")
      ("c t"  rustic-cargo-test               "Run Tests")
      ("c f"  rustic-cargo-fmt                "Format")
      ("c k"  rustic-cargo-check              "Check")
      ("c c"  rustic-cargo-clippy             "Clippy")
      ("c x"  rustic-cargo-clean              "Clean"))
     "Source"
     (("g i"  lsp-find-implementation         "Find Implementations")
      ("g d"  lsp-find-declaration            "Find Declaration")
      ("g g"  lsp-find-definition             "Find Definition")
      ("g r"  lsp-find-references             "Find References")
      ("g r"  lsp-find-type-definition        "Find Type Definition")
      ("s u"  lsp-rust-analyzer-move-item-up  "Move Up")
      ("s d"  lsp-rust-analyzer-move-item-down "Move Down")
      ("s j"  lsp-rust-analyzer-join-lines    "Join Lines")
      ("s r"  lsp-rename                      "Rename")
      ("s x"  lsp-rust-analyzer-expand-macro  "eXpand Macro"))
     "Run"
     (("r"    rustic-cargo-run                "Run")
      ("c b"  rustic-cargo-bench              "Run Benchmarks"))
     "Dependencies"
     (("o"    rustic-cargo-outdated           "Show Outdated")
      ("d u"  rustic-cargo-update             "Update All")
      ("d a"  rustic-cargo-add                "Add")
      ("d r"  rustic-cargo-rm                 "Remove")
      ("d o"  rustic-cargo-outdated           "Show Outdated"))
     "LSP Other"
     (("a"    lsp-execute-code-action           "Code Action")
      ("l c"  lsp-rust-analyzer-open-cargo-toml "Open Cargo.toml")
      ("l d"  lsp-rust-analyzer-open-external-docs "Open External Doc")
      ("l r"  lsp-rust-analyzer-related-tests "Find Tests")
      ("l s"  lsp-rust-analyzer-status        "Show Status")
      ("l i"  lsp-ui-imenu                    "Show Module Tree"))))

  (bind-key "<f9> r" 'hydra-rust/body))
#+END_SRC

Org-Babel Integration

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package ob-rust
    :after (ob rust))

  (skj/org-babel-add-languages 'rust))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'rust)
#+END_SRC

*** PEST Mode

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'pest "PEST")
#+END_SRC

#+BEGIN_SRC emacs-lisp
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package pest-mode
  :if (skj/current-feature-required-p)
  :ensure-system-package (pesta . "cargo install pesta")
  :mode "\\.pest\\'")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package flymake-pest
    :after (pest-mode)
    :hook ((pest-mode . flymake-pest-setup)
           (pest-input-mode . flymake-pest-input-setup)))

  (use-package flycheck-pest
    :after (flycheck pest-mode)
    :config (flycheck-pest-setup)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'pest)
#+END_SRC

*** Python Mode

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'python "Python")
#+END_SRC


- yasnippet-django
- py-snippets

  
#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'python)
#+END_SRC

*** SDML Mode

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'sdml)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (skj/git-clone "https://github.com/sdm-lang/emacs-sdml-mode.git"
                 "/Users/simonjo/Projects/sdm-lang/emacs-sdml-mode"))
#+END_SRC

This is the core mode package.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package sdml-mode
    :defer nil
    :after (tree-sitter tree-sitter-indent)
    :commands sdml-mode-setup
    :mode "\\.sdml?\\'"
    :load-path "/Users/simonjo/Projects/sdm-lang/emacs-sdml-mode/sdml-mode")

  (require 'sdml-mode))
#+END_SRC

This enables spell-checking of defined nodes in the tree.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package tree-sitter-ispell)
  
  (use-package sdml-ispell
    :defer nil
    :after (sdml-mode tree-sitter-ispell)
    :commands sdml-ispell-setup
    :load-path "/Users/simonjo/Projects/sdm-lang/emacs-sdml-mode/sdml-ispell"
    :config (sdml-ispell-setup))
  
  (require 'sdml-ispell))
#+END_SRC

This enables flycheck for SDML buffers.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package tsc)

  (use-package flycheck-sdml
    :defer nil
    :after (flycheck tsc sdml-mode)
    :commands flycheck-sdml-setup
    :load-path "/Users/simonjo/Projects/sdm-lang/emacs-sdml-mode/flycheck-sdml"
    :hook (sdml-mode . flycheck-mode)
    :config (flycheck-sdml-setup))
  
  (require 'flycheck-sdml))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (require 'ts-fold)
  (require 'ts-fold-indicators)

  (use-package sdml-fold
    :defer nil
    :after (ts-fold ts-fold-indicators sdml-mode)
    :load-path "/Users/simonjo/Projects/sdm-lang/emacs-sdml-mode/sdml-fold")
  
  (require 'sdml-fold))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'sdml)
#+END_SRC

*** Ocaml

- =dune-format=
- =flycheck-ocaml=
- =learn-ocaml=
- =merlin=
- =ocamlformat=
- =opam-switch-mode=
- =tuareg=
- =utop=
- =merlin=
- =ocp-index=

*** Smithy

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'smithy "Smithy (AWS)")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package smithy-mode
  :if nil ;;(skj/current-feature-required-p)
  :after tree-sitter
  :hook
  (smithy-mode tree-sitter-mode)
  (smithy-mode tree-sitter-hl-mode)
  :config
  (tree-sitter-load 'smithy)
  (add-to-list 'tree-sitter-major-mode-language-alist
               ('smithy-mode 'smithy)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'smithy)
#+END_SRC

*** SQL Stuff

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'sql "SQL")
#+END_SRC

The builtin =sql= package provides a sql-mode and a sql-interactive-mode. The original goals were two simple modes
providing syntactic highlighting. The interactive mode had to provide a command-line history; the other mode had to
provide "send region/buffer to SQL interpreter" functions.

#+BEGIN_SRC emacs-lisp
(use-package sql :ensure nil)
#+END_SRC

Support formatting SQL buffers.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package sqlformat
    :after sql
    :ensure-system-package
    (sqlfluff . "pip3 install sqlfluff")
    :custom
    (sqlformat-command "sqlfluff")
    :hook
    (sql-mode sqlformat-on-save-mode))

  (use-package flymake-sqlfluff
    :after (flymake sqlformat)
    :hook
    (sql-mode . flymake-sqlfluff-load)))
#+END_SRC

Use the builtin =sql-mode= in Org blocks.

#+BEGIN_SRC emacs-lisp
(use-package ob-sql-mode
  :if (skj/current-feature-required-p)
  :after sql)
#+END_SRC

Emacs own interface for SQL databases.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package emacsql)

  (use-package emacsql-sqlite-module
    :after emacsql))
#+END_SRC

Using =abbrev-mode= SQL keywords are all capitalized, but readable within comments.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defun sql-in-code-context-p ()
    (if (fboundp 'buffer-syntactic-context) ; XEmacs function.
        (null (buffer-syntactic-context))
      ;; Attempt to simulate buffer-syntactic-context
      ;; I don't know how reliable this is.
      (let* ((beg (save-excursion
 		            (beginning-of-line)
 		            (point)))
 	         (list
 	          (parse-partial-sexp beg (point))))
        (and (null (nth 3 list))		; inside string.
 	         (null (nth 4 list))))))	; inside cocmment

  (defun sql-pre-abbrev-expand-hook ()
    ;; Allow our abbrevs only in a code context.
    (setq local-abbrev-table
	      (if (sql-in-code-context-p)
	          sql-mode-abbrev-table)))

  (add-hook 'sql-mode-hook
            (lambda ()
              (add-hook 'pre-abbrev-expand-hook #'sql-pre-abbrev-expand-hook nil t)
              (abbrev-mode 1))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'sql)
#+END_SRC

*** Web Development

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'web "Web Development")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :if (skj/current-feature-required-p)
  :hook (web-mode . (lambda ()
                      (set (make-local-variable 'company-backends)
                           '(company-web-html))
                      (company-mode t)))
  :mode "\\(\\.html?\\|\\.njk\\)\\'"
  :custom
  (web-mode-markup-indent-offset 2)
  (web-mode-code-indent-offset 2)
  (web-mode-enable-current-element-highlight t)
  (web-mode-ac-sources-alist
   '(("css" . (ac-source-css-property))
     ("html" . (ac-source-words-in-buffer ac-source-abbrev)))))
#+END_SRC

Support for editing common template pages, specifically Jinja mode.

#+BEGIN_SRC emacs-lisp
(use-package jinja2-mode
  :if (skj/current-feature-required-p))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package html-check-frag
  :if (skj/current-feature-required-p)
  :after html-mode
  :hook (html-mode . (lambda () (html-check-frag-mode 1))))
#+END_SRC

Extensions to the standard =html-mode=.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package auto-rename-tag
    :hook html-mode)

  (use-package css-mode
    :ensure nil
    :defer 2)

  (use-package scss-mode
    :after css-mode
    :defer 3)
  
  (use-package less-css-mode
    :after css-mode
    :defer 3)

  (use-package cakecrumbs
    :custom
    (cakecrumbs-html-major-modes '(html-mode web-mode nxml-mode sgml-mode))
    (cakecrumbs-scss-major-modes '(scss-mode less-css-mode css-mode))
    :config
    (cakecrumbs-auto-setup))

  (defun skj/toggle-showcss()
    "Toggle showcss-mode"
    (interactive)
    (if (derived-mode-p
         'html-mode
         'nxml-mode
         'nxhtml-mode
         'web-mode
         'handlebars-mode)
        (showcss-mode 'toggle)
      (message "Not in an html mode")))

  (use-package show-css
    :bind ("C-c C-k" . skj/toggle-showcss))

  (use-package flycheck-css-colorguard
    :after (css-mode flycheck)))
#+END_SRC

Completion

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package ac-html-bootstrap)

  (use-package ac-html-csswatcher)

  (use-package company-web
    :after company
    :hook (web-mode . company-mode)
    :config
    (add-to-list 'company-backends '(company-css company-web-html) t))

  (use-package counsel-css))
#+END_SRC

Some support for React development.

#+BEGIN_SRC emacs-lisp
(use-package react-snippets
  :if (skj/current-feature-required-p))
#+END_SRC

Basic GraphQL support. See [[https://github.com/jdormit/ob-graphql][ob-graphql]] for more information.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package graphql-mode
    :after (request json))

  (use-package ob-graphql
    :after (ob graphql-mode)))
#+END_SRC

This is a really nice extension that allows you to render an HTML snippet using Chrome. It creates a result block that
is a PNG export, see [[https://github.com/nikclayton/ob-html-chrome][ob-html-chrome]] for more information.

#+BEGIN_SRC org :tangle no
,#+NAME: src:flag-example
,#+BEGIN_SRC html-chrome :exports both :flags --window-size=320,240 --force-device-scale-factor=2
  <p>This is an HTML paragraph.</p>
,#+END_SRC
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ob-html-chrome
  :if (skj/current-feature-required-p)
  :after (ob)
  :custom
  (org-babel-html-chrome-chrome-executable
   ;; TODO: This works for macOS only
   "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'web)
#+END_SRC

*** JavaScript

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'javascript "JavaScript")
#+END_SRC

Note that =js2-refactor= is a dependency for the general =emr= above.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package js2-mode
    :mode (("\\.js\\'" . js2-mode)
           ("\\.mjs\\'" . js2-mode)))

  (use-package js2-highlight-vars)

  (use-package js2-refactor
    :hook js2-mode
    :config
    (js2r-add-keybindings-with-prefix "C-c C-r"))

  (use-package js2hl)

  (use-package ac-js2
    :after js2-mode
    :commands ac-js2-company
    :config
    (add-to-list 'company-backends 'ac-js2-company t))

  (use-package xref-js2))
#+END_SRC

Integration of [[https://beautifier.io/][beautifier.io]].

#+BEGIN_SRC emacs-lisp
(use-package web-beautify
  :if (skj/current-feature-required-p)
  :ensure-system-package
  (js-beautify . "npm install -g js-beautify"))
#+END_SRC

Enable the builtin Babel JavaScript support.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)
  
  (use-package ob-js
    :ensure nil
    :ensure-system-package node
    :after (ob js2-mode)
    :config
    (add-to-list 'org-babel-tangle-lang-exts '("js" . "js")))

  (skj/org-babel-add-languages 'js))
#+END_SRC

Package =jquery-doc= provides:

- source for auto-complete and company-mode
- a command jquery-doc to lookup the documentation for a method in jquery

If you'd like to update the API data to the latest version available you can use the =jquery-doc-fetch-and-generate-data=
command. Warning: it may take a few seconds to parse all the data.

#+BEGIN_SRC emacs-lisp
(use-package jquery-doc
 :if (skj/current-feature-required-p)
 :after js2-mode
 :commands jquery-doc-setup
 :hook
 (js2-mode . jquery-doc-setup))
#+END_SRC

Configure projectile to detect JavaScript packages based on the =package.json= file.

#+BEGIN_SRC emacs-lisp
(require 'projectile)
(projectile-register-project-type
 'npm '("package.json")
 :project-file "package.json"
 :compile "npm install"
 :test "npm test"
 :run "npm start"
 :test-suffix ".spec")
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'javascript)
#+END_SRC

*** Typescript

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'typescript)
#+END_SRC

TypeScript support includes:

- [[https://github.com/emacs-typescript/typescript.el][typescript-mode]] :: is a self-contained, lightweight and minimalist major-mode focused on providing basic
  font-lock/syntax-highlighting and indentation for Typescript syntax, without any external dependencies. Output from
  =tsc= and =tslint= is also handled seamlessly through =compilation-mode=.
- [[https://github.com/emacs-typescript/ts-comint][ts-comint]] :: Run a TypeScript interpreter (REPL) in an inferior process window (=M-x run-ts=).
- [[https://github.com/ananthakumaran/tide][tide]] :: /Run a TypeScript interpreter in an inferior process window/.

However, note:

#+BEGIN_QUOTE
Emacs 29 will ship with support for a parser-library called tree-sitter, and will actually have in-tree support for
TypeScript! So now you can just use the provided typescript-ts-mode and get better support for TypeScript than
typescript.el ever provided. This new mode also supports TSX.

Development of TypeScript-support will from now on continue in Emacs core, rather than this repo. We hope you'll like
the new experience.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package typescript-mode)

  (use-package ts-comint
    :ensure-system-package
    (tsun . "npm install -g tsun"))

  (defun skj/tide-setup ()
    "This should be agnostic of the Emacs version"
    (interactive)
    (tide-setup)
    (flycheck-mode +1)
    (setq flycheck-check-syntax-automatically '(save mode-enabled))
    (eldoc-mode +1)
    (tide-hl-identifier-mode +1)
    (company-mode +1))
  
  (when (< emacs-version-number 29)
    ;; Using older typescript-mode
    (use-package tide
      :ensure t
      :after (typescript-mode company flycheck)
      :hook
      ((typescript-mode . skj/tide-setup)
       (typescript-mode . tide-hl-identifier-mode)
       (before-save . tide-format-before-save))))

  (when (>= emacs-version-number 29)
    ;; Using treesitter based typescript-ts-mode
    (use-package tide
      :ensure t
      :after (company flycheck)
      :hook
      ((typescript-ts-mode . skj/tide-setup)
       (tsx-ts-mode . skj/tide-setup)
       (typescript-ts-mode . tide-hl-identifier-mode)
       (before-save . tide-format-before-save)))))
#+END_SRC

Use =typescript-mode= in Org blocks.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package ob-typescript
    :after typescript-mode)

  (skj/org-babel-add-languages 'typescript))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'typescript)
#+END_SRC

*** Dart and Flutter

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'dart "Dart and Flutter")
#+END_SRC

For Flutter development it's focused around [[https://github.com/bradyt/dart-mode][dart-mode]], although there's more 

For this install, assuming that the Flutter SDK, using =:ensure-system-package=, not simply Dart.
Using the =flutter= CLI we can get the relevant version numbers for the SDK tools.

Note, the loading of =dart-mode= results in a warning regarding `define-minor-mode', it seems safe to ignore.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (defun skj/set-flutter-sdk-versions ()
    "Set variables with the form `dart--NAME--version' from the SDK"
    (let ((versions (shell-command-to-string "flutter --version")))
      (when (match-data) (set-match-data nil))
      (while (string-match "\\(\\([A-Z][a-z]+\\) \\([0-9]+\\.[0-9]+\\.[0-9]+\\)\\)"
                           versions
                           (or (match-end 0) 0))
        (set (intern (format "dart--%s--version"
                             (downcase (substring versions (match-beginning 2) (match-end 2)))))
             (substring versions (match-beginning 3) (match-end 3))))))

  (use-package dart-mode
    :after projectile
    :ensure-system-package flutter
    :init
    (skj/set-flutter-sdk-versions)
    :hook lsp
    :config
    (reformatter-define dart-format :program "dart" :args '("format"))
    (add-to-list 'projectile-project-root-files-bottom-up "pubspec.yaml")
    (add-to-list 'projectile-project-root-files-bottom-up "BUILD"))

  (use-package lsp-dart :after (dart-mode lsp-mode)))
#+END_SRC

Now install the [[https://github.com/amake/flutter.el][flutter]] package (Emacs tools for working with the Flutter SDK). Flutter.el helps you run the flutter
binary interactively as an inferior process. It's designed to work together with dart-mode: for instance the example
configuration below binds ~flutter-run-or-hot-reload~ to =C-M-x= in =dart-mode=. While editing your Dart code, just hit =C-M-x=
to either run your app, or if it's already running, to hot-reload it.

#+BEGIN_SRC emacs-lisp
(use-package flutter
  :if (skj/current-feature-required-p)
  :after dart-mode
  :hook
  (dart-mode . flutter-test-mode)
  :bind
  (:map dart-mode-map ("C-M-x" . #'flutter-run-or-hot-reload))
  :config
  (flutter-sdk-path "/Applications/flutter/"))
#+END_SRC

The =flutter= package includes a set of l10n functions, the following will check your buffer for errant strings.

#+BEGIN_SRC emacs-lisp
(use-package flutter-l10n-flycheck
  :if (skj/current-feature-required-p)
  :after (flutter flycheck))
#+END_SRC

Emacs tool for running flutter mobile apps on desktop using [[https://github.com/ericdallo/hover.el][hover]].

#+BEGIN_SRC emacs-lisp
(use-package hover
  :if (skj/current-feature-required-p)
  :after dart-mode)
#+END_SRC

Finally, enable Dart code blocks in Babel.

#+BEGIN_SRC emacs-lisp
(use-package ob-dart
  :if (skj/current-feature-required-p)
  :after dart-mode
  :init
  (skj/org-babel-add-languages 'dart))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'dart)
#+END_SRC

*** Swift

- =company-sourcekit=

*** Lua

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'lua)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package lua-mode)

  (use-package company-lua
    :after (company lua-mode)
    :commands company-lua
    :init
    (add-to-list 'company-backends 'company-lua t))
  
  (use-package ob-lua
    :ensure nil
    :after ob
    :init
    (skj/org-babel-add-languages 'lua)
    :config
    (require 'lua-mode))

  (use-package vimrc-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'lua)
#+END_SRC

*** Semantic Web

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'rdf "Semantic Web")
#+END_SRC

The [[https://github.com/nxg/ttl-mode][ttl-mode]] package provides RDF Turtle, and Notation 3, mode.

#+BEGIN_SRC emacs-lisp
(use-package ttl-mode
   :if (skj/current-feature-required-p)
   :hook (ttl-mode . turn-on-font-lock)
   :mode (("\\.n3\\'" . ttl-mode)
          ("\\.ttl\\'" . ttl-mode)))
#+END_SRC

Lookup RDF prefixes

#+BEGIN_SRC emacs-lisp
(use-package rdf-prefix
  :if (skj/current-feature-required-p))
#+END_SRC

SPARQL mode, including =org-mode= blocks.

#+BEGIN_SRC emacs-lisp
(use-package sparql-mode
  :if (skj/current-feature-required-p)
  :mode
  (("\\.sparql\\'" . sparql-mode)
   ("\\.rq\\'" . sparql-mode))
  :init
  (skj/org-babel-add-languages 'sparql))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'rdf)
#+END_SRC

*** Proof Assistants

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'provers "Proof Assistants")
#+END_SRC

[[https://proofgeneral.github.io/][Proof General]] is a generic Emacs interface for proof assistants (also known as interactive theorem provers). It is
supplied ready to use for the proof assistants [[https://coq.inria.fr/][Coq]], EasyCrypt, qrhl, and PhoX. This package provides =coq-mode= referenced
in the sections following.

#+BEGIN_SRC emacs-lisp
(use-package proof-general
  :if (skj/current-feature-required-p))
#+END_SRC

Emacs commenting support tools for Coq proof assistance

#+BEGIN_SRC emacs-lisp
(use-package coq-commenter
  :if (skj/current-feature-required-p)
  :hook (coq-mode)
  :bind (:map coq-commenter-mode-map
              ("C-;" . coq-commenter-comment-proof-in-region)
              ("C-x C-;" . coq-commenter-comment-proof-to-cursor)
              ("C-'" . coq-commenter-uncomment-proof-in-region)
              ("C-x C-'" . coq-commenter-uncomment-proof-in-buffer)))
#+END_SRC

This package includes a collection of =company-mode= back-ends for =proof-general='s Coq mode, and other useful extensions
to Proof-General.

#+BEGIN_SRC emacs-lisp
(use-package company-coq
  :if (skj/current-feature-required-p)
  :hook (coq-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package org-contrib
    :ensure nil
    :after org)

  (use-package ob-coq
    :ensure nil
    :after (proof-general org-contrib)
    :init
    (skj/org-babel-add-languages 'coq)))
#+END_SRC

The =boogie-friends= package is an experimental collection of Emacs modes for writing verified programs in z3 and
languages of the Boogie family (including Dafny).

#+BEGIN_SRC emacs-lisp
(use-package boogie-friends
  :if (skj/current-feature-required-p)
  :mode
  ("\\.smt2\\'" . z3-smt2-mode)
  ("\\.dfy\\'" . dafny-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'provers)
(skj/feature-end 'lang)
#+END_SRC

** AWS Integration

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'aws "AWS Integrations")
#+END_SRC

[[https://github.com/sebasmonia/awscli-capf][awscli-capf]] provides support for AWS CLI completion, with quick access to the vast documentation. When you type =aws= in
your shell buffer, completion at point would suggest valid commands. And by leveraging some company-mode extensions, the
docs are one =C-h= away!

#+BEGIN_SRC emacs-lisp
(use-package awscli-capf
  :if (skj/current-feature-required-p)
  :commands awscli-capf
  :hook
  (shell-mode . (lambda ()
                  (add-to-list 'completion-at-point-functions #'awscli-capf))))
#+END_SRC

[[https://github.com/baron42bba/aws-snippets][aws-snippets]] adds =yasnippet= snippets for AWS CLI and CloudFormation templates.

#+BEGIN_SRC emacs-lisp
(use-package aws-snippets
  :if (skj/current-feature-required-p))
#+END_SRC

[[https://github.com/cniles/axe][axe]] lets you use Emacs as a frontend for interacting with AWS resources. It makes available a number of tasks, such as
listing buckets, invoking lambdas and tailing logs, ergonomically available through emacs.

#+BEGIN_SRC emacs-lisp
(use-package axe
  :if (skj/current-feature-required-p)
  :custom
  (axe-region 'us-west-2))
#+END_SRC

Editing and Flycheck modes for Cloud Formation Templates.

#+BEGIN_SRC emacs-lisp
(use-package cfn-mode
  :if (skj/current-feature-required-p))

(use-package flycheck-cfn
  :if (skj/current-feature-required-p)
  :after (flycheck cfn-mode)
  :config
  (flycheck-cfn-setup))
#+END_SRC

Also consider =aws-ec2=.

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'aws)
#+END_SRC

** Issue Tracking

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'issues "Issue Tracking")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-sync
  :if (skj/current-feature-required-p)
  :after org)
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'issues)
#+END_SRC

** Developer Services

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'services "Developer Services")
#+END_SRC

*** Wakatime

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'wakatime)
#+END_SRC

[[https://wakatime.com/emacs][Wakatime]] service customization. This service tries to keep track of what projects and what tools you use as an engineer.
Set the API key in =~/.wakatime.cfg=.

#+BEGIN_SRC emacs-lisp
(use-package wakatime-mode
  :if (skj/current-feature-required-p)
  :demand t
  :diminish wakatime-mode
  :custom
  (wakatime-cli-path (locate-file "wakatime-cli" exec-path))
  :config
  (global-wakatime-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'wakatime)
(skj/feature-end 'services)
(skj/feature-end 'dev)
#+END_SRC


* Social

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'social)
#+END_SRC

** Gnus

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'gnus)
#+END_SRC

Basic [[https://www.gnu.org/software/emacs/manual/html_node/gnus/][Gnus Newsreader]] configuration. Enter Gnus with =M-x gnus=.

#+BEGIN_SRC emacs-lisp
(when (skj/current-feature-required-p)

  (use-package gnus
    :ensure nil
    :custom
    (gnus-select-method '(nntp "news.gnus.org")))

  (use-package nnhackernews
    :after gnus
    :custom
    (add-to-list 'gnus-secondary-select-methods '(nnhackernews ""))))
#+END_SRC

Enter the =nnhackernews:news= newsgroup with /=RET=/.

And of course, more icons!

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-gnus
  :if (and window-system (skj/current-feature-required-p))
  :after gnus
  :config
  (all-the-icons-gnus-setup))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'gnus)
#+END_SRC

** Mastadon

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'mastadon)
#+END_SRC

=mastodon.el= ([[https://codeberg.org/martianh/mastodon.el][here]]) is an Emacs client for the AcitivityPub social networks that implement the Mastodon API. For info see
https://joinmastodon.org/.

#+BEGIN_SRC emacs-lisp
(use-package mastodon
  :if (skj/current-feature-required-p)
  :config
  (setq mastodon-instance-url "https://hachyderm.io"
        mastodon-active-user skj/default-user-name))
#+END_SRC

=M-x mastadon= Opens a =*mastodon-home*= buffer in the major mode and displays toots. If your credentials are not yet saved,
you will be prompted for email and password. The app registration process will take place if your =mastodon-token-file=
does not contain =:client_id= and =:client_secret=.

=M-x mastodon-toot= (or =t= from a mastodon.el buffer) Pops a new buffer/window in =text-mode= and =mastodon-toot= minor mode.
Enter the contents of your toot here. =C-c C-c= sends the toot. =C-c C-k= cancels. Both actions kill the buffer and window.

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'mastadon)
(skj/feature-end 'social)
#+END_SRC


* For Fun

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'fun)
#+END_SRC

Don't forget to =M-x asm-blox=!

#+BEGIN_SRC emacs-lisp
(use-package asm-blox :if (skj/current-feature-required-p))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'fun)
#+END_SRC

** Ledger

- =ledger-mode= 
- =flycheck-ledger=
- =company-ledger=

The =ledger-mode= Emacs library provides a major mode for editing files in the format used by the ledger command-line
accounting system. It also provides automated support for some ledger workflows, such as reconciling transactions, or
running certain reports.

** LLM Integration

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'llm "LLM Integration")
#+END_SRC

The [[https://github.com/rksm/org-ai][org-ai]] package provides a minor-mode for org-mode and a global minor-mode that allows you to interact with the
OpenAI API. It allows you to:

- have a conversation with ChatGPT
- generate images with DALL-E
- supports speech input and output
- =#+begin_ai= and =#+end_ai= blocks for =org-mode=
- various commands usable everywhere

Check their site for information on getting, and securely storing, an API key.

#+BEGIN_SRC emacs-lisp
(use-package org-ai
  :if (skj/current-feature-required-p)
  :defer 3
  :after org
  :custom
  (org-ai-use-auth-source t)
  :commands
  (org-ai-mode org-ai-global-mode)
  :hook
  (org-mode . org-ai-mode)
  :init
  (org-ai-global-mode)
  :config
  (org-ai-install-yasnippets))
#+END_SRC

Add the following to the =use-package= above if enrolled in the GPT-4 beta.

#+BEGIN_EXAMPLE emacs-lisp
(setq org-ai-default-chat-model "gpt-4")
#+END_EXAMPLE

The following, [[https://github.com/tyler-dodge/org-assistant][org-assistant]], is an alternative to =org-ai= but according to the assistant home page it is focused more on
the Babel cases for /reproducible sessions/ and /allows for notebook style prompt development/.

#+BEGIN_SRC emacs-lisp :noeval
(use-package org-assistant
  :if (skj/current-feature-required-p))
#+END_SRC

For interactive Q&A, run [[https://github.com/xenodium/chatgpt-shell][chatgpt-shell]] in a side-by-side buffer. This has four /modes/:

- ~chatgpt-shell~
- ~dall-e-shell~
- ~ob-chatgpt-shell~
- ~ob-dall-e-shell~

#+BEGIN_SRC emacs-lisp :noeval
(use-package chatgpt-shell ;; ob-chatgpt-shell
  :if (skj/current-feature-required-p)
  :custom
  (chatgpt-shell-openai-key
   (auth-source-pass-get 'secret "OpenAI/api-key")))
#+END_SRC

https://github.com/karthink/gptel

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'llm)
#+END_SRC

  
* Work Configuration

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-start 'work "Work Configuration")
#+END_SRC

The following should be a symlink to work configuration under version control.

#+INCLUDE: "/Users/simonjo/.emacs.d/org-init/work-init.org"

#+BEGIN_SRC emacs-lisp :exports none
(skj/feature-end 'work)
#+END_SRC


* Finishing Up

#+BEGIN_SRC emacs-lisp :exports none
(init-message "Finishing Up")
#+END_SRC

These things need to be last, some match actions taken at the start of the file. First, turn advice redefinition
warnings back on.

#+BEGIN_SRC emacs-lisp
(setq ad-redefinition-action 'warn)
#+END_SRC

** Reset the GC Threshold

#+BEGIN_SRC emacs-lisp :exports none
(init-message "Reset the GC Threshold")
#+END_SRC

Set garbage collection back to reasonable values now that startup is complete.

#+BEGIN_SRC emacs-lisp
(setq gc-cons-percentage 0.1
      gc-cons-threshold (* 2 1024 1024))
#+END_SRC

** Run Emacs as a Server?

#+BEGIN_SRC emacs-lisp :exports none
(init-message "Run Emacs as a Server?")
#+END_SRC

Pretty self-explanatory, if we aren’t already running as a client, start the server process.

#+BEGIN_SRC emacs-lisp
(use-package server
  :ensure nil
  :defer nil
  :config
  (unless (and (fboundp 'server-running-p) (server-running-p))
    (init-message "Starting Emacs server")
    (server-start)))
#+END_SRC

And, Done!


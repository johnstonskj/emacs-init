#+TITLE: Emacs Initialization
#+OPTIONS: toc:2

This is the org-mode version of my Emacs configuration. It is pretty long, but
after having a modular version I've actually found having a hyperlinked output
is super useful. Also, I do like literate programming in general although it's
hard to find a good implementation.

The following function gates logging in the rest of the file. It's first so I
can wrap it around /anything/ in the rest of this file. Note that this depends
on the value of =debug-on-error= but can easily be overridden and set/unset
explicitly.

#+BEGIN_SRC emacs-lisp
(defvar skj/debug-init (and (boundp debug-on-error) debug-on-error)
  "Do I want to debug the init process?")
#+END_SRC

Set the garbage collection threshold to a high value during initialization to
speed things along.

#+BEGIN_SRC emacs-lisp
(setq gc-cons-percentage 0.6
      gc-cons-threshold most-positive-fixnum)
#+END_SRC

We'll also set up a hook to see how long startup took, and with the number of
garbage collection cycles. It's not a perfect metric, but good to know if it
changes without corresponding change to this file.

#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "Emacs ready in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract after-init-time before-init-time)))
                     gcs-done)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :lexical t :exports none
(require 'subr-x) ;; builtin convenience functions.

(defun progress (head &rest tail)
  "Debug messages used to show progress during startup.

The value of HEAD is always shown first with any values in TAIL appended
with a distinctive separator."
  (if skj/debug-init
      (let ((str (format "%s%s" head (if tail (concat " » " (string-join tail " » ")) ""))))
	    (message "INIT: %s" str)
	    str)
    nil))
#+END_SRC

* Utility Functions

#+BEGIN_SRC emacs-lisp :exports none
(setq l1-msg (progress "Utility Functions"))
#+END_SRC

The functions manipulate the path for executable commands outside of Emacs.
They affect both Emacs =exec-path= variable and the
=PATH= environment variable.

#+BEGIN_SRC emacs-lisp
(defun exec-path-prepend (path)
  "Add PATH to the beginning of the current `exec-path` variable,
and the shell's `$PATH` variable."
  (unless (member path exec-path)
    (setq exec-path (cons path exec-path))
    (setenv "PATH" (concat path ":" (getenv "PATH")))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun exec-path-append (path)
  "Add PATH to the end of the current `exec-path` variable, and
the shell's `$PATH` variable."
  (unless (member path exec-path)
    (setq exec-path (append exec-path (list path)))
    (setenv "PATH" (concat (getenv "PATH") ":" path))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun executable-required (command installer &optional advice)
  "Called to determine if the executable COMMAND exists, and if not the user
is asked whether to execute INSTALLER.

The value of ADVICE is used in logging to show where the command was required."
  (unless (executable-find command)
    (message "WARN: Required command =%s= not found." command)
    (if (yes-or-no-p (format "Run '%s'? " installer))
        (progn
          (message "Running installer...")
          (shell-command installer))
      (message "INFO: Need to install command `%s' via =%s=%s."
               command
               installer
               (if advice (format "; %s" advice) "")))))
#+END_SRC

The following is a simple predicate that allows for us to add others and be
more descriptive than dealing with the =system-type=
(and other) variables directly.

#+BEGIN_SRC emacs-lisp
(defun system-mac-p ()
  "Return `t` if this is Darwin, else nil."
  (eq system-type 'darwin))
#+END_SRC


* Initial Customization
#+BEGIN_SRC emacs-lisp :exports none
(setq l1-msg (progress "Initial Customization"))
#+END_SRC

** Startup Settings

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Startup Settings"))
#+END_SRC

The following should all be pretty self-explanatory.

#+BEGIN_SRC emacs-lisp
(setq echo-keystrokes 0.5
      inhibit-startup-screen t
      inhibit-startup-echo-area-message t
      ring-bell-function 'ignore)
#+END_SRC

The following enable/disable features for graphical clients only.

#+BEGIN_SRC emacs-lisp
(when window-system
  (setq
   ;; Turn off scrollbars, who needs them!
   scroll-bar-mode -1
   ;; Restricts how close point can come to the top or bottom of a window, its
   ;; value is a number of screen lines.
   scroll-margin 1
   ;; Determines the number of lines by which to automatically scroll, when point
   ;; moves off the screen
   scroll-step 1
   ;; They take up space for no good reason.
   tool-bar-mode -1)
  (when (>= emacs-major-version 26)
    (pixel-scroll-mode))
  (when (>= emacs-major-version 29)
    (setq pixel-scroll-precision-mode 1)))
#+END_SRC

We do the following to suppress warnings from third-party packages during startup. These
are warnings generated when functions are redefined with =defadvice=.

#+BEGIN_SRC emacs-lisp
(require 'advice) ;; buildin

(setq ad-redefinition-action 'accept)
#+END_SRC

** Load Path

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Load Path"))
#+END_SRC

These paths get added to the module search path, the =lib= directory should be a
symlink to my local Git repository.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (concat-path user-emacs-directory "lib"))
(add-to-list 'load-path (concat-path user-emacs-directory "lib/skj"))
#+END_SRC

This is a directory that contains links to packages outside the standard load path.
For example packages still in development.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (concat-path user-emacs-directory "llib"))
#+END_SRC

** Personal Customization Group

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Personal Customization Group"))
#+END_SRC

For those things I want to ensure I can find and tweak at runtime I use the
following customization group. This allows you to /=M-x customize-group=/ and
select =skj=.

#+BEGIN_SRC emacs-lisp
(defgroup skj nil
  "Simon's personal environment settings."
  :tag "skj"
  :prefix "skj/")
#+END_SRC

** Load Customized Values

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Load Customized Values"))
#+END_SRC

It is a good idea to use a separate file for customized settings. Some users
actually create a temporary file so that changes are session-only. However,
I prefer to keep the customization and if they prove useful move them to the
main initialization files.

#+BEGIN_SRC emacs-lisp
(setq custom-file (concat-path user-emacs-directory "custom.el"))
#+END_SRC

Assuming that the code in =custom-file= is execute before the code ahead of this
line is not a safe assumption. So load this file proactively.

#+BEGIN_SRC emacs-lisp
(load-file custom-file)
#+END_SRC

** User Information

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "User Information"))
#+END_SRC

Basic identity values, these are my common non-work values.

#+BEGIN_SRC emacs-lisp
(defcustom
  skj/primary-email
  "johnstonskj@gmail.com"
  "Primary, non-work, email address."
  :tag "Primary email address"
  :group 'skj
  :type 'string)

(defcustom
  skj/full-name
  "Simon Johnston"
  "Name to go with email-address."
  :tag "Primary email name"
  :group 'skj
  :type 'string)
#+END_SRC

The following are used by Emacs.

#+BEGIN_SRC emacs-lisp
(setq user-login-name "johnstonskj"
      user-full-name skj/full-name
      user-mail-address skj/primary-email)
#+END_SRC

This is just useful to have, the expanded version ensures that anywhere I use
it I don't have to worry about a function ignoring the tilde.

#+BEGIN_SRC emacs-lisp
(defvar user-home-directory (expand-file-name "~"))
#+END_SRC

This sets my most common location, and while mostly used by calendaring and
[[*Org Agenda]], I keep it here. Note the three required packages are all Emacs
builtins.

#+BEGIN_SRC emacs-lisp
(require 'calendar) ;; builtin
(require 'cal-dst) ;; builtin
(require 'solar) ;; builtin

(setq calendar-latitude 47.6062
      calendar-longitude -122.3321
      calendar-location-name "Seattle, WA")

(setq calendar-time-zone -480
      calendar-standard-time-zone-name "PST"
      calendar-daylight-time-zone-name "PDT")
#+END_SRC

This isn't absolutely necessary, but keeping a use-case neutral form seems
like a good idea. See also [[*Google Calendar]].

#+BEGIN_SRC emacs-lisp
(setq calendar-time-zone-name "America/Los_Angeles")
#+END_SRC

** Package Management Setup

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Package Management Setup"))
#+END_SRC

This section sets up the package management used in the rest of the file. I
use =use-package= rather than calling =install-package= as it groups a lot of
configuration in a sane and readable manner.

*** Add Package Repositories

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Add Package Repositories")
#+END_SRC

Add the most common package archives and set priorities.

#+BEGIN_SRC emacs-lisp
(require 'package) ;; builtin

(add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/"))
(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
(add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/"))

(setq package-archive-priorities '(("gnu" . 30)
                                   ("melpa-stable" . 20)
                                   ("melpa" . 10)))
#+END_SRC

*** Package Manager Configuration

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Package Manager Configuration")
#+END_SRC

Ensure =use-package= is always installed/available first.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
#+END_SRC

Setting =use-package-always-ensure= to =t= saves us the trouble of having to
specify =:ensure t= in any future packages we’d like to declare and install. The
=:ensure= macro basically makes sure that the packages are correctly installed
at every startup, and automatically installs the missing ones for you. This is
extremely useful when you frequently move between different machines and need
to port your entire Emacs configuration over to a new setup.

#+BEGIN_SRC emacs-lisp
(eval-and-compile
  (setq use-package-always-ensure t
        use-package-expand-minimally nil))
#+END_SRC

Always compile packages, and use the newest version available.

#+BEGIN_SRC emacs-lisp
(use-package auto-compile
  :init
  (setq load-prefer-newer t)
  :custom
  (auto-compile-display-buffer nil)
  (auto-compile-mode-line-counter t)
  :config
  (auto-compile-on-load-mode))
#+END_SRC

If we are debugging, let's go ahead and get a =use-package= statistics report at
the end of the startup process.

#+BEGIN_SRC emacs-lisp
(when skj/debug-init
  (eval-and-compile
    (setq use-package-compute-statistics t))
  (add-hook 'emacs-startup-hook
            (lambda () (use-package-report))))
#+END_SRC

*** Auto-Update Packages

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Auto-Update Packages")
#+END_SRC

[[https://github.com/rranelli/auto-package-update.el][This package]] provides functionality for automatically updating your Emacs
packages periodically. It is specially useful for people that work in multiple
machines and tend to forget to manually update packages from time to time.

Configure the update to happen every 7 days, at 3:00am, deleting any
old/obsolete packages after updating.

#+BEGIN_SRC emacs-lisp
(use-package auto-package-update
  :config (setq auto-package-update-interval 7
                auto-package-update-delete-old-versions t
                auto-package-update-hide-results t)
  (auto-package-update-at-time "03:00")
  (auto-package-update-maybe))
#+END_SRC
  
=auto-package-update-maybe= will update your installed packages, if there is an
update pending.

** More Paths

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "More Paths"))
#+END_SRC

Additional paths and locations that are really not feature-specific.

*** Command Execution Paths

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Command Execution Paths")
#+END_SRC

[[https://brew.sh/][Homebrew]] is great, but just in case it isn't on the path, this helps a lot.

#+BEGIN_SRC emacs-lisp
(require 'homebrew) ;; local file

(exec-path-prepend (homebrew-prefix/bin))
#+END_SRC

#+RESULTS:

This is a weird one, can't remember why ...

#+BEGIN_SRC emacs-lisp
(when (and (system-mac-p) window-system)
  (exec-path-prepend "usr/local/bin"))
#+END_SRC

*** Common Project Directory

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Common Project Directory")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'xdg) ;; builtin
#+END_SRC

Set the root for all my projects, home and work.

#+BEGIN_SRC emacs-lisp
(defcustom
  skj/project-root-dir
  (expand-file-name "~/Projects")
  "Root directory for development projects."
  :tag "Project root directory"
  :group 'skj
  :type 'directory)
#+END_SRC


* Generic Configuration

#+BEGIN_SRC emacs-lisp :exports none
  (setq l1-msg (progress "Generic Configuration"))
#+END_SRC

By generic I mean not /specifically/ for the major uses in [[*Org-Mode]],
[[*Other Writing Modes]], or [[*Developer Configuration]]. Some of these are not
necessarily "generic" unless you do all your work on Git for example.

** Authentication/Authorization Stores

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Authentication/Authorization Stores"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package password-store)

;; password-store-otp ?

(use-package pass :after password-store)

(use-package ivy-pass :after password-store)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq auth-sources
      (list '(password-store)
            (concat-path user-emacs-directory "authinfo.gpg")))
#+END_SRC

** Core UI Settings

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Core UI Settings"))
#+END_SRC

These are customizations beyond those needed for startup in [[*Startup Settings]].

*** Input Encoding

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Input Encoding")
#+END_SRC

We really like UTF-8; seriously, on a modern system there isn't a good excuse
to not use it for everything.

#+BEGIN_SRC emacs-lisp
(set-locale-environment "en_US.UTF-8")
(set-language-environment "UTF-8")
(setq-default buffer-file-coding-system 'utf-8
              coding-system-for-read 'utf-8
              coding-system-for-write 'utf-8
              file-name-coding-system 'utf-8
              keyboard-coding-system 'utf-8
              locale-coding-system 'utf-8
              prefer-coding-system 'utf-8
              require-final-newline t
              terminal-coding-system 'utf-8)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package iso-transl)
#+END_SRC

It is worth mentioning the ~set-input-method~ (=C-x RET=) function that allows for a number
of input methods other than the usual keyboard changes. One useful tool is to
set the input method to =TeX= which allows the use of character entities to
be add by their TeX command names. Also, choose =sgml= for entering HTML
entities. See [[*Org Entities]] later for an alternative tool

*** Basic Editing Customization

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg  "Basic Editing Customization")
#+END_SRC

Because this *is not* the 1950's!

#+BEGIN_SRC emacs-lisp
(use-package emacs ;; can't access `paragraphs' package directly.
  :config (setq sentence-end-double-space nil
                colon-double-space nil))
#+END_SRC

=TAB= and =SPC= handling.

#+BEGIN_SRC emacs-lisp
(setq-default
 indent-tabs-mode nil
 indicate-empty-lines t
 tab-always-indent 'complete
 tab-width 4)
#+END_SRC

Set the fill column value and turn on visual indicator.

#+BEGIN_SRC emacs-lisp
(use-package display-fill-column-indicator
  :hook (prog-mode . display-fill-column-indicator-mode)
  :init (setq-default fill-column 78))
#+END_SRC

OMG!! Enable the overwriting of selected text when you type ... like every
sane editor and O/S!

#+BEGIN_SRC emacs-lisp
(delete-selection-mode t)
#+END_SRC

Save place in files between Sessions

#+BEGIN_SRC emacs-lisp
(save-place-mode 1)
#+END_SRC

*** Default Faces

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg  "Default Faces")
#+END_SRC

These are useful things to have around.

#+BEGIN_SRC emacs-lisp
(defcustom skj/default-font-family "fira code" 
  "Default font family."
  :tag "Default font family"
  :type 'string
  :group 'skj)

(defcustom skj/default-font-weight 'light
  "Default font weight."
  :type '(choice (const light)
                 (const semi-light)
                 (const normal)
                 (const semi-bold)
                 (const bold))
  :tag "Default font weight"
  :group 'skj)

(defcustom skj/default-font-size 130
  "Default font size."
  :tag "Default font size"
  :type 'int
  :group 'skj)
#+END_SRC

This isn't so useful on macOS as it doesn't seem to decode weight and width
correctly so I can't use Fira Code Light.

#+BEGIN_SRC emacs-lisp
(set-face-attribute
 'default
 nil
 :inherit nil
 :extend nil
 :stipple nil
 :background "#fdf6e3"
 :foreground "#657b83"
 :inverse-video nil
 :box nil
 :strike-through nil
 :overline nil
 :underline nil
 :slant 'normal
 :weight skj/default-font-weight
 :height skj/default-font-size
 :width 'normal
 :foundry "nil"
 :family skj/default-font-family)
#+END_SRC

Make the menu system readable, the default colors after theming are kind of heinous.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'tty-menu-disabled-face nil
                    :background "slategray" :foreground "lightgray")
(set-face-attribute 'tty-menu-enabled-face nil
                    :background "slategray" :foreground "brightwhite" :weight 'bold)
(set-face-attribute 'tty-menu-selected-face nil
                    :background "darkslategray")
#+END_SRC

*** Theme Support

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Theme Support")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package color-theme-sanityinc-solarized
  :init
  (setq custom-enabled-themes '(sanityinc-solarized-light)
        custom-safe-themes
        '("4cf3221feff536e2b3385209e9b9dc4c2e0818a69a1cdb4b522756bcdf4e00a4" default))
  :config (setq color-theme-is-global t)
  (color-theme-sanityinc-solarized-light))
#+END_SRC

*** Fringes

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Fringes")
#+END_SRC

Set fringes to appear only on the left-hand side.

#+BEGIN_SRC emacs-lisp
(when window-system
  (fringe-mode 'left-only))
#+END_SRC

*** Mode Line

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Mode Line")
#+END_SRC

I like to keep this pretty simple, certainly no powerline!.

#+BEGIN_SRC emacs-lisp
(setq display-time-string-forms
  '((propertize (concat " " 24-hours ":" minutes " "))))

(display-time-mode t)
(line-number-mode t)
(column-number-mode t)
#+END_SRC

For battery mode, simplify the usual and use icons, it makes it easier to
find.

#+BEGIN_SRC emacs-lisp
(require 'battery) ;; builtin

(when (functionp battery-status-function)
(cond ((string= "AC" (battery-format "%L" (funcall battery-status-function)))
     (setq battery-mode-line-format ""))
    ((string-match-p "N/A" (battery-format "%B" (battery-status-function)))
     (setq battery-mode-line-format ""))
    (t
     (setq battery-mode-line-format ":%p%%"))))

(display-battery-mode 1)
#+END_SRC

*** Notifications
:PROPERTIES:
:CUSTOM_ID: core-ui-notifications
:END:

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Notifications")
#+END_SRC

[[https://github.com/jwiegley/alert][Alert]] is a Growl-workalike for Emacs which uses a common notification
interface and multiple, selectable "styles", whose use is fully customizable
by the user.

#+BEGIN_SRC emacs-lisp
(use-package alert
  :config (setq alert-fade-time 10 ;; seconds
                alert-default-style (if (system-mac-p)
                                        'osx-notifier
                                      'notifications)))
#+END_SRC

*** Images

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Images")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(if (image-type-available-p 'imagemagick)
    (message "Emacs has imagemagick support :)")
   (message "Emacs does not have imagemagick support :("))
#+END_SRC

*** Icons

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Icons")
#+END_SRC

This one isn't a true package, but a part of the [[https://github.com/sebastiencs/icons-in-terminal][icons-in-terminal]] repository.

#+BEGIN_SRC emacs-lisp
(require 'icons-in-terminal)
#+END_SRC

To ensure fonts have been installed on your system, execute:
/=M-x all-the-icons-install-fonts<RET>=/

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :if window-system
  :demand
  :config
  (all-the-icons-completion-mode))

(use-package all-the-icons-completion
  :if window-system
  :after (all-the-icons))

(use-package all-the-icons-dired
  :if window-system
  :after dired-mode
  :hook (dired-mode . all-the-icons-dired-mode))

(use-package all-the-icons-ibuffer
  :if window-system
  :after ibuffer-mode
  :hook (ibuffer-mode . all-the-icons-ibuffer-mode))
#+END_SRC

The VSCode common icons.

#+BEGIN_SRC emacs-lisp
(use-package vscode-icon
  :if window-system
  :commands (vscode-icon-for-file))
#+END_SRC

Now enable modes using the icons above.

#+BEGIN_SRC emacs-lisp
(use-package mode-icons
  :if window-system
  :config (mode-icons-mode))

(use-package major-mode-icons
  :if window-system
  :config (major-mode-icons-mode 1))
#+END_SRC

Add the fontawesome utility to allow search for icons. by name

#+BEGIN_SRC emacs-lisp
(use-package fontawesome :after ivy)
#+END_SRC

*** Mouse

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Mouse")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'mouse) ;; builtin

(setq
 mouse-wheel-follow-mouse 't
 mouse-wheel-scroll-amount '(1 ((shift) . 1)))

(xterm-mouse-mode t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(global-set-key [mouse-4] (lambda ()
                            (interactive)
                            (scroll-down 1)))
(global-set-key [mouse-5] (lambda ()
                            (interactive)
                            (scroll-up 1)))
#+END_SRC

*** Windows

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Windows")
#+END_SRC

Using multiple side-by-side windows is a great way to utilize the
large high-resolution displays that exists today. This [[https://github.com/Lindydancer/multicolumn][package]]
provides the "missing features" of Emacs to create a side-by-side
layout, to navigate efficiently, and to manage the windows.

#+BEGIN_SRC emacs-lisp
(use-package multicolumn)
#+END_SRC

In OS X 10.9, each monitor is a separate space. If you want to stretch an
Emacs frame across multiple monitors, you can change this in "System
Preferences -> Mission Control -> Displays have separate Spaces".

*** Buffers

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Buffers")
#+END_SRC

[[https://www.emacswiki.org/emacs/RecentFiles][Recentf]] is a minor mode that builds a list of recently opened files. This list
is automatically saved across sessions on exiting Emacs - you can then access
this list through a command or the menu.

#+BEGIN_SRC emacs-lisp
(use-package recentf
  :bind ("C-x C-r" . recentf-open-files)
  :config (setq recentf-max-menu-items 100
                recentf-max-saved-items 100)
  (recentf-mode))
#+END_SRC

[[https://www.emacswiki.org/emacs/IbufferMode][Ibuffer]] is an advanced replacement for BufferMenu, which lets you operate on
buffers much in the same manner as Dired. The most important Ibuffer features
are highlighting and various alternate layouts. Ibuffer is part of Emacs since
version 22.

#+BEGIN_SRC emacs-lisp
(use-package ibuffer)

(use-package ibuffer-sidebar
  :bind ("C-x C-b" . ibuffer-sidebar-toggle-sidebar))
#+END_SRC

This [[https://github.com/lukhas/buffer-move][package]] is for lazy people wanting to swap buffers without
typing /=C-x b=/ on each window.

#+BEGIN_SRC emacs-lisp
(use-package buffer-move)

(when (fboundp 'windmove-default-keybindings)
  (windmove-default-keybindings))
#+END_SRC

This [[https://github.com/beacoder/everlasting-scratch][package]] provides a global minor mode =everlasting-scratch-mode=
that causes the scratch buffer to respawn after it's killed and with
its content restored.

#+BEGIN_SRC emacs-lisp
(use-package everlasting-scratch
  :hook (after-init))
#+END_SRC

Finally, set the default buffer mode.

#+BEGIN_SRC emacs-lisp
(setq-default major-mode 'text-mode)

(add-hook 'text-mode-hook 'auto-fill-mode)
#+END_SRC

*** Multiple Cursors

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Multiple Cursors")
#+END_SRC

[[https://github.com/magnars/multiple-cursors.el][Multiple cursors]] for Emacs.

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors)
#+END_SRC

When you have an active region that spans multiple lines, the following will add a cursor to each line:

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
#+END_SRC

When you want to add multiple cursors not based on continuous lines, but based on keywords in the buffer, use:

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c m c") 'mc/edit-lines)
(global-set-key (kbd "C-c m >") 'mc/mark-next-like-this)
(global-set-key (kbd "C-c m <") 'mc/mark-previous-like-this)
(global-set-key (kbd "C-c m *") 'mc/mark-more-like-this)
(global-set-key (kbd "C-c m !") 'mc/mark-all-like-this)
#+END_SRC

This package contains [[https://github.com/knu/mc-extras.el][extra functions]] for multiple-cursors mode.

#+BEGIN_SRC emacs-lisp
(use-package mc-extras)
#+END_SRC

*** Undo Tree

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Undo Tree")
#+END_SRC

How does anyone work without an [[https://gitlab.com/tsc25/undo-tree][Undo Tree]]!

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :config (global-undo-tree-mode))
#+END_SRC

** Completion UI Settings

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Completion UI Settings"))
#+END_SRC

*** Ivy

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Ivy")
#+END_SRC

The guidance is to do all this /before/ installing the [[https://github.com/abo-abo/swiper][ivy]] packages themselves.

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-ivy
  :if window-system
  :config (all-the-icons-ivy-setup))

  (use-package all-the-icons-ivy-rich
  :if window-system
  :init (all-the-icons-ivy-rich-mode 1))
#+END_SRC

Do these *before* ivy.

#+BEGIN_SRC emacs-lisp
(use-package ivy-historian
  :init (historian-mode +1)
  :config (ivy-historian-mode +1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ivy
  :config (setq ivy-use-virtual-buffers t
                enable-recursive-minibuffers t
                ivy-count-format "(%d/%d) ")
  (ivy-mode 1))
#+END_SRC

Do these *after* ivy, but right now do not activate them.

#+BEGIN_SRC emacs-lisp
(use-package ivy-file-preview
  :after (ivy))
;;  :config (ivy-file-preview-mode 1))

(use-package ivy-rich
  :after (ivy))
;;  :config (ivy-rich-mode 1))
#+END_SRC

*** Counsel

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Counsel")
#+END_SRC

[[https://github.com/abo-abo/swiper][Counsel]] integrations; note that while ~counsel-osx-app~ looks good I didn't use
it.

#+BEGIN_SRC emacs-lisp
(use-package counsel
  :after (ivy)
  :config
  (setq counsel-find-file-ignore-regexp "\\(?:\\`\\|[/\\]\\)\\(?:[#.]\\)")
  (counsel-mode 1))

(use-package counsel-fd)
;; M-x counsel-fd-dired-jump to jump to a subdirectory under current directory
;; M-x counsel-fd-file-jump to jump to a file under current directory

(use-package counsel-web
  :config
  (setq counsel-web-engine 'google
        counsel-web-search-action #'browse-url
        counsel-web-search-alternate-action #'w3m)
  ;; Define "C-c w" as a prefix key.
  (defvar counsel-web-map
    (let ((map (make-sparse-keymap "counsel-web")))
      (define-key map (kbd "w") #'counsel-web-suggest)
      (define-key map (kbd "s") #'counsel-web-search)
      (define-key map (kbd ".") #'counsel-web-thing-at-point)
      map))
  (global-set-key (kbd "C-c w") counsel-web-map))
#+END_SRC

*** Company

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Company")
#+END_SRC

[[https://company-mode.github.io/][Company]] is a text completion framework for Emacs. The name stands for
"complete anything". It uses pluggable back-ends and front-ends to
retrieve and display completion candidate.

#+BEGIN_SRC emacs-lisp
(use-package company
  :hook
  (after-init . global-company-mode)
  :config
  (setq company-files-exclusions '(".DS_Store")
        company-tooltip-align-annotations t
        company-format-margin-function #'company-text-icons-margin))

  (use-package company-quickhelp :if window-system)
#+END_SRC

*** Key Bindings

Ivy-based interface to standard commands

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-s") 'swiper-isearch)
(global-set-key (kbd "M-x") 'counsel-M-x)
(global-set-key (kbd "C-x C-f") 'counsel-find-file)
(global-set-key (kbd "M-y") 'counsel-yank-pop)
(global-set-key (kbd "<f1> f") 'counsel-describe-function)
(global-set-key (kbd "<f1> v") 'counsel-describe-variable)
(global-set-key (kbd "<f1> l") 'counsel-find-library)
(global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
(global-set-key (kbd "<f2> u") 'counsel-unicode-char)
(global-set-key (kbd "<f2> j") 'counsel-set-variable)
(global-set-key (kbd "C-x b") 'ivy-switch-buffer)
(global-set-key (kbd "C-c v") 'ivy-push-view)
(global-set-key (kbd "C-c V") 'ivy-pop-view)
#+END_SRC

Ivy-based interface to shell and system tools

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c c") 'counsel-compile)
(global-set-key (kbd "C-c g") 'counsel-git)
(global-set-key (kbd "C-c j") 'counsel-git-grep)
(global-set-key (kbd "C-c L") 'counsel-git-log)
(global-set-key (kbd "C-c k") 'counsel-rg)
(global-set-key (kbd "C-c m") 'counsel-linux-app)
(global-set-key (kbd "C-c n") 'counsel-fzf)
(global-set-key (kbd "C-x l") 'counsel-locate)
(global-set-key (kbd "C-c J") 'counsel-file-jump)
(global-set-key (kbd "C-S-o") 'counsel-rhythmbox)
(global-set-key (kbd "C-c w") 'counsel-wmctrl)
#+END_SRC

Ivy-resume (resumes the last Ivy-based completion) and other commands

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c C-r") 'ivy-resume)
(global-set-key (kbd "C-c b") 'counsel-bookmark)
(global-set-key (kbd "C-c d") 'counsel-descbinds)
(global-set-key (kbd "C-c g") 'counsel-git)
(global-set-key (kbd "C-c o") 'counsel-outline)
(global-set-key (kbd "C-c t") 'counsel-load-theme)
(global-set-key (kbd "C-c F") 'counsel-org-file)
#+END_SRC

** O/S Specific UI Settings

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "O/S Specific UI Settings"))
#+END_SRC

*** macOS System Integration

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "macOS System Integration")
#+END_SRC

- =osx-lib=: An Emacs package with functions and commands for interacting with
  macOS.
- =osx-plist=: This is a simple parser for macOS plist files. The main entry
  points are =osx-plist-parse-file= and =osx-plist-parse-buffer=.
- =osx-trash=: Make =delete-by-moving-to-trash= do what you expect it to do on macOS.
- =reveal-in-osx-finder=: Provides the function =reveal-in-osx-finder= for file
  and dired buffers.

#+BEGIN_SRC emacs-lisp
(use-package osx-lib
  :if (system-mac-p))

(use-package osx-plist
  :if (system-mac-p))

(use-package osx-trash
  :if (system-mac-p)
  :config
  (osx-trash-setup))

(use-package reveal-in-osx-finder
  :if (system-mac-p))
#+END_SRC

*** macOS Keyboard Settings

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "macOS Keyboard Settings")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (system-mac-p)
  (setq mac-command-modifier 'super
        mac-control-modifier 'control
        mac-option-modifier 'meta))
;; mac-right-command-modifier 'super
;; mac-right-option-modifier 'meta
;; ns-alternate-modifier mac-option-modifier
;; ns-command-modifier mac-command-modifier
;; ns-function-modifier 'hyper
;; ns-right-command-modifier mac-right-command-modifier))
#+END_SRC

** Initial Flycheck Settings

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Initial Flycheck Settings"))
#+END_SRC

[[https://www.flycheck.org/en/latest/][Flycheck]].

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :hook ('after-init . global-flycheck-mode))
#+END_SRC

** Shell & Terminal Settings

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Shell & Terminal Settings"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq term-prompt-regexp "^[^#$%>\n]*[#$%>] *")

(add-to-list 'auto-mode-alist '("\\.zsh\\'" . sh-mode))

(add-hook 'sh-mode-hook
          (lambda ()
            (if (string-match "\\.zsh$" buffer-file-name)
                (sh-set-shell "zsh"))))
#+END_SRC

Emacs-libvterm, =/vterm/=, is fully-fledged terminal emulator inside GNU Emacs
based on libvterm, a C library. As a result of using compiled code (instead of
elisp), emacs-libvterm is fully capable, fast, and it can seamlessly handle
large outputs.

#+BEGIN_SRC emacs-lisp
(use-package vterm
  :config (setq vterm-shell "zsh"
                vterm-max-scrollback 10000))
#+END_SRC

** Gnus

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Gnus"))
#+END_SRC

Basic [[https://www.gnu.org/software/emacs/manual/html_node/gnus/][Gnus Newsreader]] configuration. Enter Gnus with /=M-x gnus=/
.
#+BEGIN_SRC emacs-lisp
(require 'gnus) ;; builtin

(setq gnus-select-method '(nntp "news.gnus.org"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package nnhackernews
  :config
  (add-to-list 'gnus-secondary-select-methods '(nnhackernews "")))
#+END_SRC

Enter the =nnhackernews:news= newsgroup with /=RET=/.

And of course, more icons!

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-gnus
  :if window-system
  :config (all-the-icons-gnus-setup))
#+END_SRC

** Remote (TRAMP) Editing

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Remote (TRAMP) Editing"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'tramp) ;; builtin

(setq tramp-default-method "ssh")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package counsel-tramp)

(use-package docker-tramp)
#+END_SRC

** Version Control

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Version Control"))
#+END_SRC

*** Core Git

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Core Git")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package git-attr)

(use-package git-blamed)

(use-package git-commit-insert-issue
  :hook (git-commit-mode))

(use-package git-link)

(use-package git-timemachine
  :config (setq git-timemachine-show-minibuffer-details t))

(use-package git-modes)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ibuffer-git)
#+END_SRC

*** Magit

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Magit")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package magit
  :config (setq git-commit-fill-column 72
                magit-completing-read-function 'ivy-completing-read))

(use-package magit-lfs
  :after magit)
#+END_SRC

This package displays keyword entries from source code comments and Org files
in the Magit status buffer.  Activating an item jumps to it in its file.  By
default, it uses keywords from -hl-todo-, minus a few (like "NOTE").

#+BEGIN_SRC emacs-lisp
(use-package magit-todos
  :after magit
  :config (magit-todos-mode))
#+END_SRC

*** Forge Integration

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Magit Forge Integration")
#+END_SRC

To start using Forge in a certain repository visit the Magit status buffer for
that repository and type =f n= (=forge-pull=). Alternatively, you can use /=M-x
forge-add-repository=/, which makes it possible to add a forge repository
without pulling all topics and even without having to clone the respective Git
repository.

#+BEGIN_SRC emacs-lisp
(use-package forge
  :after magit)
#+END_SRC

Forge uses the Ghub package to access the APIs of supported Git forges. How
this works and how to create and store a token is documented in the magit
[[https://magit.vc/manual/ghub.html#Getting-Started][Getting Started]] section.

*** Diff Highlighting

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Diff Highlighting")
#+END_SRC

`diff-hl-mode' highlights uncommitted changes on the side of the
window (using the /fringe/, by default), allows you to jump between
the hunks and revert them selectively.

#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :after magit
  :hook ((magit-pre-refresh . diff-hl-magit-pre-refresh)
         (magit-post-refresh . diff-hl-magit-post-refresh))
  :config (global-diff-hl-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package magit-diff-flycheck
  :after (flycheck magit))
#+END_SRC

*** iBuffer Integration

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "iBuffer Integration")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ibuffer-vc
  :config
  (add-hook 'ibuffer-hook
            (lambda ()
              (ibuffer-vc-set-filter-groups-by-vc-root)
              (unless (eq ibuffer-sorting-mode 'alphabetic)
                (ibuffer-do-sort-by-alphabetic)))))
#+END_SRC

*** Code Reviews

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Code Reviews")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package code-review)
#+END_SRC


* Snippet Support

#+BEGIN_SRC emacs-lisp :exports none
(setq l1-msg (progress "Snippet Support"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defcustom
  skj/snippet-repo-dir
  (concat-path skj/project-root-dir "emacs-snippets")
  "Snippet repository local path."
  :tag "Snippet repository local path"
  :group 'skj
  :type 'directory)
#+END_SRC

** Core Snippet Support

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Core Snippet Support"))
#+END_SRC

First of all, the primary snippet tool is =yasnippet=.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :hook (prog-mode . yas-minor-mode)
  :config
  (dolist (path (list
                 (concat-path user-emacs-directory "snippets")
                 skj/snippet-repo-dir))
    (unless (member path yas-snippet-dirs)
      (setq yas-snippet-dirs
            (cons path yas-snippet-dirs))))
  (yas-global-mode 1))
#+END_SRC

Remember to execute /=M-x yas-reload-all<RET>=/ when any snippets change.

** Snippet Collections

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Snippet Collections"))
#+END_SRC

Basic snippets, pretty useful.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet-snippets)
#+END_SRC

These are super useful, create a new =.gitignore= file and type =emacs<RET>=
followed by language such as =rust<RET>= and maybe =macos<RET>= for good measure.

#+BEGIN_SRC emacs-lisp
(use-package gitignore-snippets
  :config
  (gitignore-snippets-init))
#+END_SRC

These are common license files, easy to add to a new project.

#+BEGIN_SRC emacs-lisp
(use-package license-snippets)
#+END_SRC

** Snippet Completion

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Snippet Completion"))
#+END_SRC

=ivy-yasnippet= lets you preview yasnippet snippets with ivy. To use it, call
~ivy-yasnippet~ in =yas-minor-mode=.

#+BEGIN_SRC emacs-lisp
(use-package ivy-yasnippet)
#+END_SRC


* Org-Mode

#+BEGIN_SRC emacs-lisp :exports none
(setq l1-msg (progress "Org-Mode"))
#+END_SRC

The almighty [[https://orgmode.org/][Emacs Org Mode]]!

#+BEGIN_SRC emacs-lisp
(defcustom
  skj/org-directory
  (concat-path skj/project-root-dir "emacs-org")
  "The root directory for non-work Org files."
  :tag "Org file directory"
  :group 'skj
  :type 'directory)
#+END_SRC

The following are worth reading for more details and future ideas:

- http://doc.norang.ca/org-mode.html
- https://github.com/zzamboni/dot-emacs/blob/master/init.org
- https://orgmode.org/worg/org-tutorials/encrypting-files.html
- https://github.com/daviwil/emacs-from-scratch/blob/master/show-notes/Emacs-06.org
(Agendas and Templates)
- https://orgmode.org/manual/Custom-Agenda-Views.html#Custom-Agenda-Views
- https://www.lucacambiaghi.com/vanilla-emacs/readme.html (6.4. org capture
  templates)
- https://github.com/akirak/org-reverse-datetree

** Initial Configuration

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Initial Configuration"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org
  :mode ("\\.org\\'" . org-mode)
  :config (setq org-confirm-babel-evaluate nil
                org-cycle-separator-lines 2
                org-default-notes-file (concat-path skj/org-directory "inbox.org")
                org-edit-src-content-indentation 2
                org-ellipsis " ▾"
                org-enforce-todo-dependencies t
                org-fontify-quote-and-verse-blocks t
                org-hide-emphasis-markers t
                org-image-actual-width '(480)
                org-log-done 'time
                org-log-into-drawer t
                org-pretty-entities t
                org-src-fontify-natively t
                org-src-preserve-indentation t
                org-src-tab-acts-natively t
                org-startup-folded 'content
                org-startup-indented t
                org-startup-with-inline-images t)
  (require 'org-mouse))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defconst skj/org-column-headings
  '((all-tags "%30ALLTAGS(All Tags)")
    (blocked "%1BLOCKED()")
    (category "%10CATEGORY(Category)")
    (clock-sum "%10CLOCKSUM(Actual){:}")
    (clock-sum-today "%10CLOCKSUM_T(Actual Day){:}")
    (closed "%24CLOSED(Closed on)")
    (deadline "%24DEADLINE(Deadline)")
    (effort "%10EFFORT(Effort){:}")
    (file "%15FILE")
    (item "%45ITEM(Task)")
    (priority "%1PRIORITY(!)")
    (scheduled "%24SCHEDULED(Scheduled to Start)")
    (tags-all "%20TAGS(Tags)")
    (todo "%10TODO(State)")))

(defconst skj/org-column-separator " ")

(defun skj/make-org-column-view (columns &optional column-separator)
  "Construct a column view heading string.

The argument COLUMNS is a list of symbols where each symbol is a key to
the alist in `skj/org-column-headings'. Any column symbol not
found in `skj/org-column-headings' will be discarded and the
resulting list of values combined with the value of COLUMN-SEPARATOR,
or the default value in `skj/org-column-separator'."
  (string-join
   (mapcar
    'car 
    (seq-filter
     (lambda (elt) (not (null elt)))
     (mapcar
      (lambda (column) (alist-get column skj/org-column-headings))
      columns)))
    (or column-separator skj/org-column-separator)))
#+END_SRC

Add the /official/ [[https://orgmode.org/worg/org-contrib/][contributed]] packages for =org-mode=.

#+BEGIN_SRC emacs-lisp
(use-package org-contrib :after org)
#+END_SRC

The only problem with hiding emphasis markers is that rich text becomes hard
to edit because it is unclear whether your cursor is on the marker or the
first or last character. The =org-appear= package helps by displaying the
markers while the cursor is on a rich text word.

#+BEGIN_SRC emacs-lisp
(use-package org-appear
  :after org
  :hook (org-mode . org-appear-mode))
#+END_SRC

Links in org-mode by default are displayed as “descriptive” links, meaning
they hide their target URLs (or a destination in general). While this looks
great, it makes it a bit tricky to figure out how you can edit their URL.

#+BEGIN_SRC emacs-lisp
(require 'org)

(define-key org-mode-map (kbd "C-c h") 'org-toggle-link-display)
#+END_SRC

Set the default column view for all org-mode files.

#+BEGIN_SRC emacs-lisp
(setq org-columns-default-format
      (skj/make-org-column-view
       '(item category todo priority blocked tags-all scheduled deadline effort)))
#+END_SRC

The [[https://github.com/alphapapa/ts.el][ts]] package is a useful tool for a bunch of time related stuff in agenda
and more.

#+BEGIN_SRC emacs-lisp
(use-package ts)
#+END_SRC

*** Org Query Language

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Org Query Language")
#+END_SRC

A powerful [[https://github.com/alphapapa/org-ql][query language]] for org files.

#+BEGIN_SRC emacs-lisp
(use-package org-ql :after org)
#+END_SRC

*** Priorities

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Priorities")
#+END_SRC

I like using the letters for display, it's a shame that the different Org
interfaces use integers, chars, /and/ strings.

#+BEGIN_SRC emacs-lisp
(setq
 org-priority-highest ?A
 org-priority-lowest ?E
 org-priority-default ?C)

(setq
 org-highest-priority ?A
 org-lowest-priority ?E
 org-default-priority ?C)
#+END_SRC

Use fancy icons for different priority levels, this hooks into org-agenda but
could be used without.

#+BEGIN_SRC emacs-lisp
(use-package
  org-fancy-priorities
  :hook
  (org-agenda)
  :config
  (setq org-fancy-priorities-list
        '((?A . "⚡") (?B . "⬆") (?C . " ") (?D . "⬇") (?E . "☕"))
        org-priority-faces
        '((?A :foreground "red" :weight bold)
          (?B :foreground "orange" :weight semi-bold)
          (?C :foreground "green" :weight normal)
          (?B :foreground "blue" :weight semi-light)
          (?C :foreground "grey" :weight light))))
#+END_SRC

*** Categories

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Categories")
#+END_SRC

Would be nice to customize `org-agenda-category-icon-alist' but for two
issues:

1. Column views seem to ignore category properties and just use file names.
2. The icon list expects image data, no terminal mode.

*** Tags

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Tags")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-tag-alist
      '((:startgroup)
        ("idea" . ?i) ("call" . ?c) ("errand" . ?e) ("pay" . ?p) ("remind" . ?r) ("writing" . ?w)
        (:endgroup)
        ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        (:startgrouptag)
        ("home" . ?H)
        (:grouptags)
        ("fix" . ?f) ("clean" . ?l) ("garage" . ?g) ("yard" . ?y) ("family" . ?a) ("friends" . ?r)
        ("finance" . ?$) ("estate" . ?#) ("pets" . ?t)
        (:endgrouptag)
        ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        (:startgrouptag)
        ("activities" . ?A)
        (:grouptags)
        ("diving" . ?v) ("hacking" . ?h) ("music" . ?u) ("synth" . ?s) ("blogging" . ?b)
        (:endgrouptag)
        ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        (:startgrouptag)
        ("travel" . ?T)
        (:grouptags)
        ("flight" . ?F) ("car" . ?C) ("train" . ?R) ("hotel" . ?O) ("event" . ?V)
        (:endgrouptag)
        ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        (:startgrouptag)
        ("work" . ?W)
        (:grouptags)
        ("planning" . ?%) ("design" . ?^) ("coding" . ?!) ("meeting" . ??)
        ("admin" . ?/) ("business" . ?B) ("technical" . ?T) ("hr" . ?H)
        (:endgrouptag)))
#+END_SRC

Currently this fails!

#+BEGIN_SRC emacs-lisp
;; (use-package org-tag-beautify :config (org-tag-beautify-mode 1))
#+END_SRC

It results in the following:

#+BEGIN_EXAMPLE
all-the-icons-fileicon: Unable to find icon with name ‘svelte’ in icon set ‘fileicon’
#+END_EXAMPLE

*** Task Types (TODO)

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Task Types (Keywords)")
#+END_SRC

Specify (<char>Before/After) where either Before/After may be @ for
record time AND comment, ! for just time

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
      '(;; Simple reminders
        (sequence "NUDGE(g)" "|" "DONE(d!)")
        ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        ;; General to-do items
        (sequence "TODO(t)" "NEXT(n!)" "INPROGRESS(p!)" "WAIT(w@/!)" "|" "DONE(d!)" "CANCELED(c@)")
        ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        ;; Work-like task items
        (sequence "BACKLOG(b)" "PLAN(p!)" "READY(r!)" "ACTIVE(a@/!)" "REVIEW(v)" "WAIT(w@/!)" "HOLD(h)" "|" "DONE(d!)" "CANCELED(c@)")
        ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        ;; Appointment and Meeting tracking
        (sequence "MEETING(M)" "REQUESTED(R!)" "BOOKED(B@)" "DEFERRED(F@)" "RESCHEDULE(E@)" "|" "DONE(d@)" "CANCELED(c@)")))

(setq-default org-enforce-todo-dependencies t)
#+END_SRC

Edna provides an extensible means of specifying conditions which must be
fulfilled before a task can be completed and actions to take once it is.

Org Edna runs when either the BLOCKER or TRIGGER properties are set on a
heading, and when it is changing from a TODO state to a DONE state.

#+BEGIN_SRC emacs-lisp
(require 'org-id) ;; builtin

(setq org-id-method 'uuid
      org-id-prefix nil
      org-id-include-domain nil)

(use-package org-edna
  :config (org-edna-mode))
#+END_SRC

*** Expiration

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Expiration")
#+END_SRC

This gives you a chance to get rid of old entries in your Org files by
expiring them. The package is a part of =org-contrib=.

#+BEGIN_SRC emacs-lisp
(use-package org-contrib
  :after org
  :config
  (require 'org-expiry)
  (setq org-expiry-handler-function 'org-expiry-add-keyword))
#+END_SRC

*** Capture Templates

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Capture Templates")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(let ((deadline "DEADLINE: %^t\n")
      (prop-id ":ID: %(org-id-new)")
      (prop-created ":CREATED: %U")
      (prop-level
       ":LEVEL: %^{Level|Team|VP|SVP|STeam|Flagship}")
      (prop-effort
       ":EFFORT: %^{Effort|1h|0:15|0:30|1h|4h|1d|2d|1w|2w|1m|3m|6m|1y}")
      (props (lambda (ps)
               (format
                ":PROPERTIES:\n%s:END:\n"
                (if (null ps) "" (concat (string-join ps "\n") "\n"))))))
    (setq org-capture-templates
        (list
         (list
          "t" "Add a TODO entry"
           'entry
           '(file+headline org-default-notes-file "Task Inbox")
           (concat "** TODO %?\n"
                   (funcall props (list prop-created prop-id prop-effort)))
           :clock-in t
           :clock-resume t
           :empty-lines-after 1)
          ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          (list
           "n" "Add a task as NEXT"
           'entry
           '(file+headline org-default-notes-file "Task Inbox")
           (concat "** NEXT %?\n"
                   deadline
                   (funcall props (list prop-created prop-id prop-effort)))
           :empty-lines-after 1)
          ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          (list
           "p" "Add a project"
           'entry
           '(file+headline org-default-notes-file "Task Inbox")
           (concat "** %? [%] :project: \n"
                   deadline
                   (funcall props (list prop-created prop-id)))
           :empty-lines-after 2
           :refile-targets)
          ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          (list
           "g" "Add a goal"
           'entry
           '(file+headline org-default-notes-file "Task Inbox")
           (concat "** %? :goal: \n"
                   deadline
                   (funcall props (list prop-created prop-id prop-level)))
           :empty-lines-after 1
           :refile-targets)
          ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          (list
           "a" "Annotate current task"
           'plain
           '(clock)
           "- Note taken on %T \\\n  %?"
           :empty-lines-after 1)
          ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          (list
           "m" "Add a planned meeting"
           'entry
           '(file+headline org-default-notes-file "Meeting Requests")
           (concat "** MEETING with %? :meeting: \n"
                   deadline
                   (funcall props (list prop-created)))
           :empty-lines-after 1)
          ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
          (list
           "i" "A Random idea"
           'entry
           '(file+headline org-default-notes-file "Thoughts")
           (concat "* %? :idea: \n"
                   (funcall props (list prop-created)))
           :empty-lines-after 1))))
#+END_SRC

*** Faces

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Faces")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-todo-keyword-faces
      '(("NEXT" . (:foreground "green" :weight bold))
        ("PLAN" . (:foreground "green" :weight bold))
        ("INPROGRESS" . (:foreground "blue" :weight bold))
        ("ACTIVE" . (:foreground "blue" :weight bold))))

(add-hook 'org-mode-hook #'turn-on-font-lock)
#+END_SRC

*** Project File Integration

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Project File Integration")
#+END_SRC

Adds all TODO items from a =todo.org= file in the magit project's root
to the magit status buffer.

#+BEGIN_SRC emacs-lisp
(use-package magit-org-todos
  :after (magit org)
  :config
  (magit-org-todos-autoinsert))
#+END_SRC

** Core UI Additions

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Core UI Additions"))
#+END_SRC

The Org-Superstar package improves the look of Org mode headings by replacing
the asterisk symbols with nicer looking circles. The package also enhances the
looks of plain lists and todo items.

#+BEGIN_SRC emacs-lisp
(use-package org-superstar
  :after org
  :hook (org-mode . org-superstar-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-beautify-theme
  :after org
  :if window-system)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-modern :after org)
#+END_SRC

This package presents helpful sidebars for Org buffers. Sidebars are
customizable using [[*Org Query Language][org-ql]] queries and
=org-super-agenda= grouping. To show the tree execute /=M-x
org-sidebar-tree<RET>=/.

#+BEGIN_SRC emacs-lisp
(use-package org-sidebar :after org)
#+END_SRC

Use /=C-c C-s=/ to use a relative time for schedule.

=org-collector= collects headline properties into tables with optional
pre-processing.

#+BEGIN_SRC emacs-lisp :exports none
(use-package org-contrib
  :after org
  :config (require 'org-collector))
#+END_SRC

The =[[https://github.com/nobiot/org-transclusion][org-transclusion]]= package
lets you insert a copy of text content via a file link or ID link within an
Org file. It lets you have the same content present in different buffers at
the same time without copy-and-pasting it.

#+BEGIN_SRC emacs-lisp :exports none
(use-package org-transclusion :after org)
#+END_SRC

Package =[[https://github.com/eliascotto/accent][accent]]= shows a popup with
accented characters based on the current letter under the cursor. Based on the
MacOS features for adding accented letters with a long keypress.

#+BEGIN_SRC emacs-lisp :exports none
(use-package accent
  :config
  (global-set-key (kbd "C-x C-a") 'accent-menu)
  (setq accent-position 'after))
#+END_SRC

*** Org Entities

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Org Entities")
#+END_SRC

The =org-entities= package included in Org Mode allows for entering character
entries in TeX-like form, so =\approx= becomes =≈=. You can toggle the display
between the entered form and the display form with
~org-toggle-pretty-entities~ (=C-c C-x \=). Additionally, ~org-entities-help~ will
show a table of supported entities. 

*** Notifications

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Notifications")
#+END_SRC

Provides notifications for scheduled or deadlined agenda entries. This uses
the =alert= package configured in [[#core-ui-notifications]] above.

#+BEGIN_SRC emacs-lisp
(use-package org-alert
  :after org
  :config (setq org-alert-interval 300
                org-alert-notify-cutoff 10
                org-alert-notify-after-event-cutoff 10
                org-alert-notification-title "Org Agenda"))
#+END_SRC

*** Prettier Bullets

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Prettier Bullets")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :after org
  :config
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC

*** References

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "References")
#+END_SRC

This adds [[https://github.com/jkitchin/org-ref][org-ref]] for citations and references, along with the nice
[[https://github.com/alezost/org-ref-prettify.el][org-ref-prettify]].

#+BEGIN_SRC emacs-lisp
(use-package org-ref :after org)

(use-package org-ref-prettify
  :after org-ref
  :hook (org-mode . org-ref-prettify-mode))
#+END_SRC

*** Completion Integration

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Completion Integration")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package company-org-block
  :after (company org)
  :config
  ;; style: 'auto, 'prompt, or 'inline
  (setq company-org-block-edit-style 'auto)
  (add-hook 'org-mode-hook
            (lambda ()
              (add-to-list (make-local-variable 'company-backends)
                           'company-org-block))))

(use-package org-ivy-search
  :after (org ivy)
  :bind ("C-c o" . org-ivy-search-view))

(use-package ivy-todo
  :after (org ivy)
  :bind ("C-c t" . ivy-todo)
  :commands ivy-todo
  :config (setq ivy-todo-default-tags '("PROJECT")))
#+END_SRC

The following is installed by =org-ref= we just pull it in here.

#+BEGIN_SRC emacs-lisp
(require 'org-ref)
(require 'org-ref-ivy)
#+END_SRC

** Org Agenda

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Org Agenda"))
#+END_SRC

Set basic things for Agenda management. Note that we don't append to the list
~org-agenda-files~ as this should be the first usage and so let's make it clean.

#+BEGIN_SRC emacs-lisp
(require 'org-agenda) ;; builtin

(setq org-agenda-files
      (list (concat skj/org-directory "/inbox.org")
            (concat skj/org-directory "/todo.org")
            (concat skj/org-directory "/gcal.org")
            (concat skj/org-directory "/birthdays.org")
            (concat skj/org-directory "/holidays.org"))
      org-agenda-hide-tags-regexp "."
      org-agenda-log-mode-items '(closed clock state))
#+END_SRC

Because opening the agenda has a tendency to "mess up" window layout...

#+BEGIN_SRC emacs-lisp
(setq org-agenda-window-setup 'current-window
      org-agenda-restore-windows-after-quit t)
#+END_SRC

The [[https://github.com/Malabarba/org-agenda-property][property package]] can be customized with ~org-agenda-property-list~ and
~org-agenda-property-position~.

#+BEGIN_SRC emacs-lisp
(use-package org-agenda-property)
#+END_SRC

This [[https://github.com/alphapapa/org-super-agenda][package]] lets you "supercharge" your Org daily/weekly agenda. The idea is
to group items into sections, rather than having them all in one big list.

#+BEGIN_SRC emacs-lisp
(use-package org-super-agenda :after org)
#+END_SRC

*** Custom Views

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Custom Views")
#+END_SRC

Set a sensible default column view for all agenda views.

#+BEGIN_SRC emacs-lisp
(setq org-columns-default-format-for-agenda
      (skj/make-org-column-view
       '(item todo priority blocked tags-all
              scheduled deadline effort clock-sum clock-sum-today)))
#+END_SRC

This is useful for filtering by priority, when not using tag queries.

#+BEGIN_SRC emacs-lisp
(defun skj/org-skip-subtree-if-priority (priority)
  "Skip an agenda subtree if it has a priority of PRIORITY.
  
  PRIORITY must be string between =\"A\"= and =\"E\"=."
  (let ((subtree-end (save-excursion (org-end-of-subtree t)))
        (pri-current (org-element-property :priority (org-element-at-point))))
    (if (equal priority pri-current)
        subtree-end
      nil)))
#+END_SRC

Set up some useful Agenda views.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-custom-commands
      '(("c"
         "TODO closed last week"
         tags "CLOSED>=\"<-1w>\"&+TODO=\"DONE\"|+TODO=\"CANCELED\""
         ((org-agenda-overriding-header "TODO Closed last week:")
          (org-agenda-sorting-strategy '(priority-down effort-down))
          (org-agenda-overriding-columns-format
           (skj/make-org-column-view
            '(item priority scheduled deadline closed tags-all)))
          (org-agenda-view-columns-initially t)))
        ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        ("d"
         "Daily agenda review"
         ((tags "+PRIORITY=\"A\"&-TODO=\"DONE\"|-TODO=\"CANCELED\""
           ((org-agenda-overriding-header "High-priority unfinished tasks:")
            (org-agenda-sorting-strategy '(todo-state-down effort-up))))
          ;; --=--=--=--=--=--=--=--=--=--=
          (agenda "")
          ;; --=--=--=--=--=--=--=--=--=--=
          (alltodo ""
           ((org-agenda-skip-function
             '(or (skj/org-skip-subtree-if-priority ?A)
                  (org-agenda-skip-if nil '(scheduled deadline))))
            (org-agenda-sorting-strategy '(priority-down todo-state-down effort-up)))))
         nil
         ("~/daily-agenda.html"))))
#+END_SRC

*** Run on Idle

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Run on Idle")
#+END_SRC

Basically, if you don't touch Emacs =idle-org-agenda= will display your
org-agenda after certain time. That can be useful to remember tasks after come
back to work.

#+BEGIN_SRC emacs-lisp
(use-package idle-org-agenda
  :after org
  :config
  (idle-org-agenda-mode))
#+END_SRC

*** Clock Tracking

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Clock Tracking")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'org-clock) ;; builtin

(setq
 org-clock-persist 'history
 org-remember-clock-out-on-exit t)
#+END_SRC

Active notifications are shown every 3 minute, inactive every 3

#+BEGIN_SRC emacs-lisp
(use-package org-clock-reminder
  :config (setq org-clock-reminder-interval (cons 3 10))
  (org-clock-reminder-mode))
#+END_SRC

*** Habit Tracking

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Habit Tracking")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-habit-stats
  :after org
  :config (setq org-habit-following-days 7
                org-habit-graph-column 60
                org-habit-preceding-days 28
                org-habit-show-all-today t
                org-habit-show-done-always-green t
                org-habit-show-habits-only-for-today t)
  (add-to-list 'org-modules 'org-habit t))
#+END_SRC

*** Standard Calendars

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Standard Calendars")
#+END_SRC

Remove the Bahá'í holidays, really not sure they add anything for me.

#+BEGIN_SRC emacs-lisp
(customize-set-variable 'holiday-bahai-holidays nil)
#+END_SRC

But, these are rather good to know!

#+BEGIN_SRC emacs-lisp
(use-package mexican-holidays
  :after (calendar holidays)
  :config (setq calendar-holidays
                (append calendar-holidays holiday-mexican-holidays)))
#+END_SRC

*** Google Calendar

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Google Calendar")
#+END_SRC

Emacs own /EasyPG/ picks up the wrong key if I use the primary email address, it
seems to ignore the fact that it has been revoked. Using the alternate email
for this key, should work?

#+BEGIN_SRC emacs-lisp
(require 'plstore)

(setq plstore-encrypt-to "simonkjohnston@mac.com")
#+END_SRC

Use my secrets store to load the Google Calendar credentials.

#+BEGIN_SRC emacs-lisp
(use-package skj-secrets
  :config
  (setq org-gcal-client-id (skj/secrets-value 'gcal-id)
        org-gcal-client-secret (skj/secrets-value 'gcal-secret)))
#+END_SRC

Store synced calendar entries in the following file.

#+BEGIN_SRC emacs-lisp
(defcustom skj/org-gcal-file
  (concat skj/org-directory "/gcal.org")
  "Location of `org-mode' file to sync with Google Calendar."
  :tag "Org Agenda file for Google Calendar"
  :group 'skj
  :type 'file)
#+END_SRC

Now setup the client.

#+BEGIN_SRC emacs-lisp
(use-package org-gcal
  :after org
  :config
  (setq org-gcal-fetch-file-alist (list (cons skj/primary-email
                                              skj/org-gcal-file))
        org-gcal-local-timezone calendar-time-zone-name))
#+END_SRC

Execute /=M-x org-gcal-fetch<RET>=/ to fetch new calendar updates. Or, execute
/=M-x org-gcal-post-at-point<RET>=/ to turn a =TODO= into a calendar entry.

*** Appointment Integration

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Appointment Integration")
#+END_SRC

Configure the base =appt= package.

#+BEGIN_SRC emacs-lisp
(require 'appt) ;; builtin

(setq appt-audible t
      appt-display-duration 30
      appt-display-format 'window
      appt-display-mode-line t)
#+END_SRC

Activate appointments so we get notifications.

#+BEGIN_SRC emacs-lisp
(appt-activate t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun skj/org-agenda-to-appt ()
  "Erase all reminders and rebuilt reminders for today from the agenda."
  (interactive)
  (setq appt-time-msg-list nil)
  (org-agenda-to-appt))
#+END_SRC

Rebuild the reminders every time we display the  agenda.
 
#+BEGIN_SRC emacs-lisp
(add-hook 'org-agenda-finalize-hook 'skj/org-agenda-to-appt 'append)
#+END_SRC

If we leave Emacs running overnight - reset the appointments one minute after midnight

#+BEGIN_SRC emacs-lisp
(run-at-time "24:01" nil 'skj/org-agenda-to-appt)
#+END_SRC

Run during startup so that appointments are rebuilt.
 
#+BEGIN_SRC emacs-lisp
(skj/org-agenda-to-appt)
#+END_SRC

** Babel

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Babel"))
#+END_SRC

This function is useful as we want to always add to the list of babel
languages, but also it's nice to be able to pass a single value rather
than a list in all cases.

#+BEGIN_SRC emacs-lisp
(defun skj/org-babel-load-languages (languages)
  "Add language to babel and load.

Add LANGUAGES to `'org-babel-load-languages' where LANGUAGES may
be one of the following:

1. a single symbol,
1. a pair with a symbol and a value to denote the enable
   state of the language,
1. or a list where each element is one of the two above.

Finally, the `org-babel-do-load-languages' is called with the
normalized values of LANGUAGES."
  (if (symbolp languages)
      (add-to-list 'org-babel-load-languages (cons languages t))
    (dolist (lang-pair languages)
      (let ((language (cond
                       ((symbolp lang-pair)
                        (cons lang-pair t))
                       ((and (consp lang-pair) (symbolp (car lang-pair)) (booleanp (cdr lang-pair)))
                        lang-pair)
                       (t (error "Invalid value for language: %s" lang-pair)))))
        (add-to-list 'org-babel-load-languages language))))
  (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
#+END_SRC

Load common builtin languages, also always redisplay images after =C-c C-c.=

#+BEGIN_SRC emacs-lisp
(require 'ob) ;; built into org
#+END_SRC

Enable these built-in languages. These do not have their own sections as they
do not have any specific configuration.

- [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-elisp.html][Emacs Lisp]] ...
- [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-sqlite.html][sqlite]] is a software library that implements a self-contained, serverless,
  zero-configuration, transactional SQL database engine.
- Org Babel works with several text based [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-shell.html][shells]].

#+BEGIN_SRC emacs-lisp
(skj/org-babel-load-languages '(emacs-lisp sqlite shell))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)
#+END_SRC

*** JavaScript

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "JavaScript")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'ob-js)

(skj/org-babel-load-languages 'js)

(add-to-list 'org-babel-tangle-lang-exts '("js" . "js"))
#+END_SRC

*** ditaa

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "ditaa")
#+END_SRC

DIagrams Through Ascii Art ([[https://ditaa.sourceforge.net/][ditaa]], [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-ditaa.html][ob-ditaa]]) is a command-line utility that converts
diagrams drawn using ASCII art into bitmap graphics.

#+BEGIN_SRC emacs-lisp
(skj/org-babel-load-languages 'ditaa)
(setq org-ditaa-jar-path "/opt/homebrew/opt/ditaa/libexec/ditaa-0.11.0-standalone.jar")
#+END_SRC

Use =artist-mode= when drawing diagrams in ditaa.

#+BEGIN_SRC emacs-lisp
(executable-required
 "ditaa"
 "brew install ditaa"
 "required by package `ob-ditaa'")
#+END_SRC

(let ((prefix (string-trim (shell-command-to-string (concat brew " --prefix ditaa")))))

*** GNUPlot

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "GNUPlot")
#+END_SRC

Enable the builtin [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-gnuplot.html][gnuplot babel]] support after adding the editing mode.

#+BEGIN_SRC emacs-lisp
(use-package gnuplot
  :mode ("\\.gp$" . gnuplot-mode)
  :config
  (skj/org-babel-load-languages 'gnuplot))
#+END_SRC

*** GraphViz

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "GraphViz")
#+END_SRC

Enable the builtin [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-dot.html][dot babel]] support after adding the editing mode.

#+BEGIN_SRC emacs-lisp
(use-package graphviz-dot-mode
  :config
  (unless (version<= emacs-version "26")
    (setq graphviz-dot-indent-width tab-width))
(skj/org-babel-load-languages 'dot))

(executable-required
 "dot"
 "brew install graphviz"
 "required by package `graphviz-dot-mode'")
#+END_SRC

*** PlantUML

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "PlantUML")
#+END_SRC

Enable the builtin [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-plantuml.html][PlantUML babel]] support after adding the editing mode.
Configuring this to use the =plantuml= executable.

#+BEGIN_SRC emacs-lisp
(use-package plantuml-mode           
  :config (setq plantuml-default-exec-mode 'executable)
  (skj/org-babel-load-languages 'plantuml))

(executable-required
 "plantuml"
 "brew install plantuml"
 "required by package `plantuml-mode'")

(use-package flycheck-plantuml
  :after plantuml-mode
  :config (flycheck-plantuml-setup))
#+END_SRC

** Other Stuff

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Other Stuff"))
#+END_SRC

*** Exporting

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Exporting")
#+END_SRC

The package [[https://github.com/emacsorphanage/ox-pandoc][=ox-pandoc=]] is an exporter for Org mode which converts Org-mode files to a wide
variety of other formats using the [[https://pandoc.org/][pandoc]] tool. Pandoc can produce PDFs, HTML,
presentations, markdown files, office documents and e-pub publications as well
as a number of other more specialised formats.

#+BEGIN_SRC emacs-lisp
(use-package ox-pandoc
  :after ox)
#+END_SRC

Add Org exporter backends for Markdown and [[https://github.com/larstvei/ox-gfm][Github-Flavored Markdown]].

#+BEGIN_SRC emacs-lisp
(require 'ox-md) ;; builtin

(use-package ox-gfm
  :after ox
  :commands (org-gfm-export-as-markdown org-gfm-export-to-markdown))
#+END_SRC

*** Refile and Archive

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Refile and Archive")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-refile-targets
      (quote ((nil :maxlevel . 9)
              (org-agenda-files :maxlevel . 9)
              ("archive.org" :maxlevel . 1))))
#+END_SRC

Save Org buffers after refiling.

#+BEGIN_SRC emacs-lisp
(advice-add 'org-refile :after 'org-save-all-org-buffers)
#+END_SRC

*** Progress Reporting

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Progress Reporting")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun skj/org-dashboard-filter (entry)
  (and (> (plist-get entry :progress-percent) 0)
       (< (plist-get entry :progress-percent) 100)
       (not (member "archive" (plist-get entry :tags)))))

(use-package org-dashboard
  :config (setq org-expiry-add-keyword t
                org-dashboard-filter 'skj/org-dashboard-filter))
#+END_SRC

Might also consider:

- =[[https://github.com/gizmomogwai/org-kanban][org-kanban]]=
- =[[https://github.com/ianxm/emacs-scrum][org-scrum]]=
- =[[orgtbl-ascii-plot]]= -- support for histograms within tables.
- =[[https://github.com/tbanel/orgaggregate/blob/master/README.org][orgtbl-aggregate]]=
  -- aggregating a table is creating a new table by computing sums, averages,
  and so on, out of material from the first table.

*** Extending Org Mode

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Extending Org Mode")
#+END_SRC

Flexible extensions

- =[[https://github.com/gizmomogwai/org-tagged][org-tagged]]=
  
Consider the following for writing extensions:

- =[[https://hg.sr.ht/~zck/org-parser][org-parser]]=
- =[[http://alhassy.com/org-special-block-extras/][org-special-block-extras]]=
  
** Key Bindings

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Key Bindings"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c l") #'org-store-link)
(global-set-key (kbd "C-c a") #'org-agenda)
(global-set-key (kbd "C-c c") #'org-capture)

(global-set-key (kbd "<f5>") 'org-agenda)
(global-set-key (kbd "C-<f5>") 'org-store-agenda-views)

(global-set-key (kbd "<f6> i") 'org-clock-in)
(global-set-key (kbd "<f6> o") 'org-clock-out)
(global-set-key (kbd "<f6> g") 'org-clock-goto)
(global-set-key (kbd "<f6> <f6>") 'org-clock-menu)
#+END_SRC


* Other Writing Modes

#+BEGIN_SRC emacs-lisp :exports none
(setq l1-msg "Other Writing Modes")
#+END_SRC

** Focus Mode

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Focus Mode"))
#+END_SRC

For distraction-free editing, use the command /=M-x focus-mode=/ which will dim
all but the block of text/code you are currently within.

#+BEGIN_SRC emacs-lisp
(use-package focus
  :custom-face
  (focus-unfocused ((t (:inherit font-lock-comment-face :foreground "white")))))
#+END_SRC

** Emoji Support

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Emoji Support"))
#+END_SRC

Emacs has to be able to properly render emojis, so a suitable font is
required. Noto Color Emoji is recomended for optimal results.

#+BEGIN_SRC emacs-lisp
(set-fontset-font t 'symbol (font-spec :family "Noto Color Emoji") nil 'prepend)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package company-emoji
  :after (company)
  :if window-system
  :config
  (add-to-list 'company-backends 'company-emoji)
  
  (defun --set-emoji-font (frame)
    "Adjust the font settings of FRAME so Emacs can display emoji properly."
    (if (system-mac-p)
        ;; For NS/Cocoa
        (set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji") frame 'prepend)
      ;; For Linux
      (set-fontset-font t 'symbol (font-spec :family "Symbola") frame 'prepend)))
  
  ;; For when Emacs is started in GUI mode:
  (--set-emoji-font nil)
  ;; Hook for when a frame is created with emacsclient
  ;; see https://www.gnu.org/software/emacs/manual/html_node/elisp/Creating-Frames.html
  (add-hook 'after-make-frame-functions '--set-emoji-font))
#+END_SRC

Setup ivy emoji support to use the same list as company, for consistency.

#+BEGIN_SRC emacs-lisp
(use-package ivy-emoji
  :after (ivy company-emoji)
  :if window-system
  :bind ("C-c i e" . ivy-emoji) ;; mnemonics i e = insert emoji
  :config
  (require 'company-emoji-list)
  (setq ivy-emoji-list
        (mapcar #'(lambda (emoji)
                   (concat
                    (get-text-property 0 :unicode emoji) " "
                    (substring-no-properties emoji)))     ;; Print the name
                (company-emoji-list-create))))
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Markdown"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode)

(use-package polymode)

(use-package poly-markdown :after (polymode markdown))

(autoload 'markdown-mode "markdown-mode"
  "Major mode for editing Markdown files" t)
(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))

(autoload 'gfm-mode "markdown-mode"
  "Major mode for editing GitHub Flavored Markdown files" t)
(add-to-list 'auto-mode-alist '("README\\.md\\'" . gfm-mode))
#+END_SRC

** Blogging

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Blogging"))
#+END_SRC

Editing jekyll files, using =polymode= for the mix of YAML and Markdown.

#+BEGIN_SRC emacs-lisp
(use-package jekyll-modes :after (poly-markdown))

;;(require 'jekyll-markdown-mode)
;;(add-to-list 'auto-mode-alist '("\\.md$" . jekyll-markdown-mode))
#+END_SRC

Emacs major mode for managing [[https://jekyllrb.com/][jekyll]] blogs ([[https://github.com/masasam/emacs-easy-jekyll][repo]]).

#+BEGIN_SRC emacs-lisp
(use-package easy-jekyll)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; thanks to https://cute-jumper.github.io/emacs/2013/10/06/orgmode-to-github-pages-with-jekyll
(defun org-jekyll-post-link-follow (path)
  (org-open-file-with-emacs path))

(defun org-jekyll-post-link-export (path desc format)
  (cond
   ((eq format 'html)
    (format "<a href=\"{%% post_url %s %%}\">%s</a>" (file-name-sans-extension path) desc))))

(org-add-link-type "jekyll-post" 'org-jekyll-post-link-follow 'org-jekyll-post-link-export)
#+END_SRC

** Wiki Stuff

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Wiki stuff"))
#+END_SRC

This allows direct access to edit files on the Wiki, and an Org mode exporter
via /=M-x org-mw-export-as-mediawiki<RET>=/.

#+BEGIN_SRC emacs-lisp
;; (use-package mediawiki)

(use-package ox-mediawiki
  :after (ox mediawiki))
#+END_SRC

XWiki mode is an offline editing mode only.

#+BEGIN_SRC emacs-lisp
(use-package xwiki-mode)
#+END_SRC

** LaTeX

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "LaTeX"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defcustom
  skj/latex-shared-paths
  (list (expand-file-name "~/Projects/latex/texmf"))
  "A list of directories holding shared files for LaTeX writing."
  :tag "Shared LaTeX directories"
  :group 'skj
  :type '(repeat directory))

(defcustom
  skj/bibtex-files
  (list (expand-file-name "~/Projects/latex/personal.bib"))
  "A list of BibTeX files."
  :tag "Shared BibTeX files"
  :group 'skj
  :type '(repeat file))
#+END_SRC

*** AUCTeX

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "AUCTeX"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package tex
  :ensure auctex)

(setq latex-run-command "xelatex"
      TeX-auto-save t
      TeX-parse-self t)

(use-package auctex-latexmk
  :after auctex)

(use-package latex-pretty-symbols)

(use-package latex-extra
  :after auctex
  :hook (LaTeX-mode . latex-extra-mode))
#+END_SRC

This is a group of backends for =company-mode= providing auto-completion for
AUCTeX.

#+BEGIN_SRC emacs-lisp
(use-package company-auctex
  :config
  (company-auctex-init))
#+END_SRC

This add-on defines three =company-mode= backends.

#+BEGIN_SRC emacs-lisp
(use-package company-math
 :config
  (setq company-tooltip-align-annotations t)
  ;; global activation of the unicode symbol completion
  (add-to-list 'company-backends 'company-math-symbols-unicode))
#+END_SRC

*** Bibliographies

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Bibliographies")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package biblio)

(use-package bibtex-utils)
#+END_SRC

Completion, using [[https://github.com/gbgar/company-bibtex][company-bibtex]] and [[https://github.com/tmalsburg/helm-bibtex/blob/master/README.org][ivy-bibtex]] packages.

#+BEGIN_SRC emacs-lisp
(use-package company-bibtex
  :config (setq company-bibtex-bibliography skj/bibtex-files)
  (add-to-list 'company-backends 'company-bibtex))

(use-package ivy-bibtex
  :config (setq bibtex-completion-bibliography skj/bibtex-files))
#+END_SRC

Tools to retrieve content.

#+BEGIN_SRC emacs-lisp
(use-package bibretrieve)

(use-package gscholar-bibtex)
#+END_SRC

The [[https://github.com/emacs-citar/citar][ccitar]] package provides a completing-read front-end to browse and act on BibTeX,
BibLaTeX, and CSL JSON bibliographic data, and LaTeX, markdown, and org-cite
editing support. See [[https://kristofferbalintona.me/posts/202206141852/#citar][this page]] for some configuration ideas.

#+BEGIN_SRC emacs-lisp
(use-package citar
  :config (setq citar-bibliography skj/bibtex-files))

;;(use-package citar-org
;;  :after oc
;;  :config (setq org-cite-insert-processor 'citar
;;                org-cite-follow-processor 'citar
;;                org-cite-activate-processor 'citar))
#+END_SRC

*** Preview

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Preview")
#+END_SRC

Use /=M-x latex-math-preview-expression=/

#+BEGIN_SRC emacs-lisp
(use-package latex-math-preview)

(use-package latex-preview-pane
  :config (latex-preview-pane-enable))
#+END_SRC

Automatically toggle Org mode LaTeX fragment previews as the cursor enters and exits them

#+BEGIN_SRC emacs-lisp
(use-package org-fragtog
  :hook (org-mode))
#+END_SRC

** RFC Reader

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "RFC Editing"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package rfc-mode
  :commands (rfc-mode-browse rfc-mode-read)
  :config
  (setq rfc-mode-directory (expand-file-name "~/Documents/rfc/")))
#+END_SRC

** Spell and Style Checking

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Spell and Style Checking"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package auto-dictionary
  :config
  (add-hook 'flyspell-mode-hook (lambda () (auto-dictionary-mode 1))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package flyspell-correct-ivy
  :hook ((text-mode . flyspell-mode)
         (prog-mode . flyspell-prog-mode))
  :config (setq flyspell-issue-message-flag nil
                ispell-program-name "aspell"))

(let* ((env-language (getenv "LANG"))
	   (dictionary (first (split-string env-language "\\."))))
  (setq ispell-extra-args (list (concat "--lang=" dictionary))))
#+END_SRC

[[https://github.com/bnbeckwith/writegood-mode][Writegood mode]] is a minor mode to aid in finding common writing problems. Matt
Might’s [[http://matt.might.net/articles/shell-scripts-for-passive-voice-weasel-words-duplicates/][weaselwords]] scripts inspired this mode. As well as the additional
weasel words it is possible to add to the irregular passive voice verbs in
=writegood-passive-voice-irregulars=.

#+BEGIN_SRC emacs-lisp
(use-package writegood-mode
  :bind (("\C-c g" . writegood-mode)
         ("\C-c \C-g g" . writegood-grade-level)
         ("\C-c \C-g e" . writegood-reading-ease))
  :hook ((markdown-mode . writegood-mode)
         (gfm-mode . writegood-mode)
         (LaTeX-mode . writegood-mode)
         (org-mode . writegood-mode)
         (text-mode . writegood-mode))
  :config (setq writegood-weasel-words
                (append '("least" "most" "occasionally") writegood-weasel-words)))
#+END_SRC

This is more a batch checker, you run the external tool =style= on a buffer or
region. To check writing style, execute: /=M-x smog-check-buffer<RET>=/.

#+BEGIN_SRC emacs-lisp
(use-package smog
  :config (setq smog-command "style -L en"))

(executable-required
 "style"
 "brew install style"
 "required by package `smog'")
#+END_SRC


* Developer Configuration

#+BEGIN_SRC emacs-lisp :exports none
(setq l1-msg (progress "Developer Configuration"))
#+END_SRC

** UI Settings

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "UI Settings"))
#+END_SRC

*** Prettify Things

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Prettify Things")
#+END_SRC

Emacs 24.4 comes with a builtin =prettify-symbols-mode=. It is customized by
changing =prettify-symbols-alist=.

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook #'prettify-symbols-mode)
#+END_SRC

The packages =prettify-math= and =prettify-greek= extend the configuration above.
The math package requires we set the delimiters before the module loaded.

#+BEGIN_SRC emacs-lisp
(use-package prettify-math
  :config (setq prettify-math-delimiters-alist
                '(("$" tex)
                  ("$$" tex block)
                  (("\\(" . "\\)") tex block)
                  ("`" asciimath)
                  ("``" asciimath block))))

(use-package prettify-greek
  :config (setq prettify-symbols-alist
                (append prettify-symbols-alist prettify-greek-lower)))
#+END_SRC

=fira-code-mode= is a simple minor mode for [[https://github.com/tonsky/FiraCode][Fira Code]] ligatures. You can
pre-install the fonts with the command /=M-x fira-code-mode-install-fonts<RET>=/.

#+BEGIN_SRC emacs-lisp
(use-package fira-code-mode
  :if window-system
  :hook (prog-mode . fire-code)
  :config (fira-code-mode-set-font))
#+END_SRC

*** Delimiters/Parenthesis

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Delimiters/Parenthesis")
#+END_SRC

Add [[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] for easy parenthesis matching, and [[https://github.com/Fuco1/smartparens][smartparens]] to
manage pairs.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :hook (emacs-lisp . smartparens-strict))

(use-package rainbow-delimiters
  :hook (prog-mode . 'rainbow-delimiters))
#+END_SRC

*** Indentation

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Indentation")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :hook (emacs-lisp-mode css-mode))

(use-package highlight-indent-guides
  :hook (prog-mode)
  :config
  (setq highlight-indent-guides-method 'character
        highlight-indent-guides-responsive 'stack)
  (set-face-foreground 'highlight-indent-guides-character-face "brightmagenta"))
#+END_SRC

*** Completion

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Completion")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package company
  :config
  (setq company-files-exclusions '(".git/" ".DS_Store")
        company-tooltip-align-annotations t)
  (add-hook 'web-mode-hook
            (lambda ()
              (set (make-local-variable 'company-backends) '(company-web-html))
              (company-mode t))))
#+END_SRC

*** Odds & Ends

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Odds & Ends")
#+END_SRC

This package [[https://github.com/tarsius/hl-todo][highlights TODO]]-like tags in buffers.

#+BEGIN_SRC emacs-lisp
(use-package hl-todo
  :hook (prog-mode . hl-todo-mode))
#+END_SRC

Turns on /sub-word/ [[https://www.gnu.org/software/emacs/manual/html_node/ccmode/Subword-Movement.html][movement and editing]].

#+BEGIN_SRC emacs-lisp
(use-package subword)
#+END_SRC

A simple but effective thing, `eldoc-mode= is a MinorMode which [[https://www.emacswiki.org/emacs/ElDoc][shows you]],
in the echo area, the argument list of the function call you are currently
writing.

#+BEGIN_SRC emacs-lisp
(use-package eldoc
  ;; The following works as expected
  :hook (emacs-lisp-mode cider-mode))

;; The following doesn't.
;; (turn-on-eldoc)
#+END_SRC

** Project Support

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Project Support"))
#+END_SRC

*** Projectile

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Projectile")
#+END_SRC

Projectile is a project interaction library for Emacs. Its goal is to provide
a nice set of features operating on a project level without introducing
external dependencies (when feasible).

=projectile-git-autofetch= is a minor mode for Emacs to automatically fetch
repositories you are currently working on (by default, all open repositories
known to projectile).

=project-explorer= provides a tree-based project explorer sidebar.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :after (ivy)
  :config
  (setq projectile-completion-system 'ivy
        projectile-require-project-root t
        projectile-project-search-path
        (mapcar (lambda (p)
                  (concat (file-name-as-directory skj/project-root-dir) p))
                '("emacs-little-packages" "racket" "rust" "Amazon"))))

(use-package projectile-git-autofetch
  :config (projectile-git-autofetch-mode 1))

(use-package projectile-ripgrep)

(use-package counsel-projectile)

(use-package flycheck-projectile)
#+END_SRC

Recommended keymap prefix on macOS

#+BEGIN_SRC emacs-lisp
(when (system-mac-p)
  (define-key projectile-mode-map (kbd "s-p") 'projectile-command-map))
#+END_SRC

Turn stuff on.

#+BEGIN_SRC emacs-lisp
(counsel-projectile-mode 1)

(projectile-mode +1)
#+END_SRC

*** iBuffer Integration

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "iBuffer Integration")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ibuffer-projectile
  :config (add-hook 'ibuffer-hook
                    (lambda ()
                      (ibuffer-projectile-set-filter-groups)
                      (unless (eq ibuffer-sorting-mode 'alphabetic)
                        (ibuffer-do-sort-by-alphabetic)))))
#+END_SRC

*** Project Explorer

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Project Explorer")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package project-explorer
  :bind ("<f8>" . project-explorer-toggle)
  :config (setq pe/filenotify-enabled t
                pe/inline-folders t
                pe/omit-gitignore t
                pe/side 'left
                pe/width 40))
#+END_SRC

*** Find Files

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Find Files")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package find-file-in-project
  :config (ivy-mode 1))
#+END_SRC

** Language Server (Generic)

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Language Server (Generic)"))
#+END_SRC

- Documentation: https://emacs-lsp.github.io/lsp-mode/
- Supported language servers: https://emacs-lsp.github.io/lsp-mode/page/languages/

#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :init
  (setq lsp-keymap-prefix "M-o")
  :commands lsp
  :config (setq lsp-eldoc-render-all t
                lsp-idle-delay 0.6
                lsp-keep-workspace-alive nil
                lsp-completion-provider :capf
                lsp-signature-doc-lines 5))
#+END_SRC

This package contains all the higher level UI modules of =lsp-mode=, like
flycheck support and code lenses.
 
#+BEGIN_SRC emacs-lisp
(use-package lsp-ui
  :hook (lsp-mode)
  :config (setq lsp-ui-doc-enable nil
                lsp-ui-doc-position 'bottom
                lsp-ui-peek-always-show t
                lsp-ui-peek-fontify 'always
                lsp-ui-sideline-enable t
                lsp-ui-sideline-show-hover t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;;;###autoload
(defun skj/imenu-toggle-maybe-lsp ()
  "Toggle an imenu list popup; it will use lsp-ui if it is enabled."
  (interactive)
  (if (bound-and-true-p lsp-mode)
	  (lsp-ui-imenu)
    (imenu-list-smart-toggle)))
#+END_SRC

This package provides an interactive =ivy= interface to the workspace symbol
functionality offered by =lsp-mode=.

- ~lsp-ivy-workspace-symbol~ - workspace symbols for the current workspace
- ~lsp-ivy-global-workspace-symbol~ - workspace symbols from all of the active
  workspaces.

#+BEGIN_SRC emacs-lisp :exports none
(use-package lsp-ivy)
#+END_SRC

*Key Bindings/Commands*

- =completion-at-point= for completions
- Signatures when writing methods (/=C-n=/, /=C-p=/ to cycle signatures)
- =lsp-find-definition=: /=C-c l g r=/
- =lsp-find-references=: /=C-c l g g=/
- =lsp-rename=: /=C-c l r r=/
- =lsp-format-buffer=: /=C-c l ==/
- =lsp-ui-peek-find-references= to show references inline (/=M-n=/, /=M-p=/ to cycle)

** Test and Debug

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Test and Debug"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package dap-mode)
#+END_SRC

*** DAP Settings

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "DAP Settings")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package dap-mode
  :config (setq dap-auto-configure-features
                '(sessions locals controls tooltip))
  (require 'dap-ui)
  (dap-ui-mode 1)
  (dap-ui-controls-mode 1)
  ;; Enables mouse hover support
  (dap-tooltip-mode 1)
  ;; Use tooltips for mouse hover,
  ;; if it is not enabled `dap-mode' will use the minibuffer.
  (tooltip-mode 1)
  ;; Displays floating panel with debug buttons
  (dap-ui-controls-mode 1))
#+END_SRC

*** Additional Test Tools

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "UI Settings")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package counsel-test)

(use-package coverlay)
#+END_SRC

- =toggle-test=

*** REST Client

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "REST Client")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package restclient)

(use-package company-restclient
  :after restclient
  :config (add-to-list 'company-backends 'company-restclient))

(use-package restclient-test :after restclient)

(use-package ob-restclient
  :after (org restclient)
  :config (skj/org-babel-load-languages '(restclient)))
#+END_SRC

- =soap-client=

** Data Formats

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Data Formats"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package pcsv)
(use-package csv-mode
  :mode "\\.csv\\'")

(use-package json-mode
  :mode "\\.json\\'")

(use-package toml)
(use-package toml-mode
  :mode "\\.toml\\'")

(use-package yaml-mode
  :mode "\\.yaml\\'")
(use-package flycheck-yamllint)
#+END_SRC

** Language Environments

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Language Environments"))
#+END_SRC

- =[[https://github.com/Wilfred/emacs-refactor][emr]]= -- Emacs refactoring
  
*** BNF-like

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "BNF-like")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package bnf-mode)

(use-package ebnf-mode)
#+END_SRC

*** Emacs Lisp

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Emacs Lisp")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package package-lint)

(use-package flycheck-package
  :after (flycheck package-lint))

(require 'checkdoc) ;; builtin

(add-hook 'emacs-lisp-mode-hook 'checkdoc-minor-mode)
#+END_SRC

Because =ielm= (inferior emacs lisp mode) is damn hard to remember, here's a
simple shortcut.

#+BEGIN_SRC emacs-lisp
(defalias 'emacs-lisp-repl 'ielm)
#+END_SRC

Also consider:

- ERT -- Emacs Lisp Regression Testing, builtin (add =ert-expectations=,
  =ert-junit=, and  =ert-modeline=).
- =[[https://github.com/jorgenschaefer/emacs-buttercup][buttercup]]= -- BDD for
  Emacs Lisp, along with
  =[[https://bitbucket.org/olanilsson/buttercup-junit/src/master/][buttercup-junit]]=
  for reporting.
- =undercover=
- =[[https://github.com/ecukes/ecukes][ecukes]] -- Cucumber for Emacs.

*** Common Lisp

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Common Lisp")
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; (use-package slime)
;; 
;; (use-package slime-company)
;; 
;; (use-package slime-repl-ansi-color)
;; 
;; (use-package elisp-slime-nav)
;; 
;; (setq inferior-lisp-program (locate-file "sbcl" exec-path))
#+END_SRC

*** Scheme

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Scheme")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package geiser-chez)

(use-package geiser-gauche)

(use-package geiser-racket)

(use-package macrostep-geiser
  :hook ((geiser-mode . macrostep-geiser-setup)
         (geiser-repl-mode . macrostep-geiser-setup)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package lsp-scheme
  :hook (scheme-mode . lsp-gambit-scheme))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package quack)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package scheme-complete)
#+END_SRC

*** Racket

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Racket")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package dr-racket-like-unicode)

(use-package racket-mode)

(use-package scribble-mode :after (racket-mode))
#+END_SRC

*** Ada

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Ada Language")
#+END_SRC

Not currently using this, but have used the following:

- =eglot= as an LSP client to the AdaCore (GNAT) [[https://github.com/AdaCore/ada_language_server][ALS]].
- =ada-mode=
- =ada-ref-man=

It is important to note that you not only need a compiler (again, AdaCore) but
also the [[https://alire.ada.dev/][Alire]] package manager. Download =alr= and run =alr toolchain --select= to
get an Ada environment installed.

*** Rust Language

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Rust Language")
#+END_SRC

For more information/inspiration:

- https://github.com/rust-lang/rust-mode
- https://robert.kra.hn/posts/rust-emacs-setup/

#+BEGIN_SRC emacs-lisp
(defun rustic-mode-auto-save-hook ()
  "Enable auto-saving in rustic-mode buffers."
  (when buffer-file-name
    (setq-local compilation-ask-about-save nil)))

(use-package rustic
  :after (lsp lsp-lens-mode)
  :hook ((rustic-mode . rustic-mode-auto-save-hook)
         (rustic-mode . lsp-lens-mode))
  :config
  (setq rustic-babel-format-src-block t
        rustic-babel-auto-wrap-main t
        rustic-format-on-save t
        rustic-lsp-server 'rust-analyzer
        lsp-rust-analyzer-cargo-load-out-dirs-from-check t
        lsp-rust-analyzer-cargo-watch-enable t
        lsp-rust-analyzer-cargo-watch-command "clippy"
        lsp-rust-analyzer-display-chaining-hints t
        lsp-rust-analyzer-display-closure-return-type-hints t
        lsp-rust-analyzer-display-lifetime-elision-hints-use-parameter-names nil
        lsp-rust-analyzer-display-parameter-hints t
        lsp-rust-analyzer-display-reborrow-hints t
        lsp-rust-analyzer-inlay-hints-mode t
        lsp-rust-analyzer-proc-macro-enable t
        lsp-rust-analyzer-server-display-inlay-hints t))

(add-hook 'rust-mode-hook
          (lambda () (set-fill-column 100)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package cargo-mode
  :after (rustic)
  :hook (rust-mode . cargo-minor-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package rust-auto-use
  :after (rust))

(use-package rust-playground
  :after (rust))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'rust-mode-hook 'subword-mode)
#+END_SRC

Flycheck for Rust.

#+BEGIN_SRC emacs-lisp
(use-package flycheck-rust
  :after (rustic cargo-mode)
  :config
  (setq flycheck-rustic-clippy-executable "cargo-clippy")
  (unless (member 'rustic-clippy flycheck-checkers)
    (setq flycheck-checkers (cons 'rustic-clippy flycheck-checkers))))
#+END_SRC

DAP Debug profile for Rust.

#+BEGIN_SRC emacs-lisp
(dap-register-debug-template
 "Rust::GDB Run Configuration"
 (list :type "gdb"
       :request "launch"
       :name "GDB::Run"
       :gdbpath "rust-gdb"
       :target nil
       :cwd nil))
#+END_SRC

Org-Babel Integration

#+BEGIN_SRC emacs-lisp
(use-package ob-rust :after (rust))
#+END_SRC

*** PEST Mode

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "PEST Mode")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package pest-mode
  :mode "\\.pest\\'")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(executable-required
 "pesta"
 "cargo install pesta"
 "optional extra for `pest-mode'")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package flymake-pest
  :after (pest-mode)
  :hook ((pest-mode . flymake-pest-setup)
         (pest-input-mode . flymake-pest-input-setup)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package flycheck-pest
  :after (flycheck pest-mode)
  :config (flycheck-pest-setup))
#+END_SRC

*** Ocaml

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Ocaml")
#+END_SRC

- =dune-format=
- =flycheck-ocaml=
- =learn-ocaml=
- =merlin=
- =ocamlformat=
- =opam-switch-mode=
- =tuareg=
- =utop=
  
*** SQL Stuff

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "SQL")
#+END_SRC

Support formatting SQL buffers.

#+BEGIN_SRC emacs-lisp
(use-package sqlformat
  :config (setq sqlformat-command "sqlfluff"))

(add-hook 'sql-mode-hook 'sqlformat-on-save-mode)

(use-package flymake-sqlfluff
  :after (flymake)
  :hook (sql-mode . flymake-sqlfluff-load))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(executable-required
 "sqlfluff"
 "pip3 install sqlfluff"
 "required by `flymake-sqlfluff'")
#+END_SRC

Use the builtin =sql-mode= in Org blocks.

#+BEGIN_SRC emacs-lisp
(use-package ob-sql-mode)
#+END_SRC

Emacs own interface for SQL databases.

#+BEGIN_SRC emacs-lisp
(use-package emacsql)

(use-package emacsql-sqlite-module)
#+END_SRC

*** Web Development

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Web Development")
#+END_SRC

Extensions to the standard =html-mode=.

#+BEGIN_SRC emacs-lisp
(use-package auto-rename-tag
  :hook (html-mode))

(use-package cakecrumbs
  :config
  (setq cakecrumbs-html-major-modes '(html-mode web-mode nxml-mode sgml-mode)
        cakecrumbs-scss-major-modes '(scss-mode less-css-mode css-mode))
  (cakecrumbs-auto-setup))

(defun skj/toggle-showcss()
  "Toggle showcss-mode"
  (interactive)
  (if (derived-mode-p
       'html-mode
       'nxml-mode
       'nxhtml-mode
       'web-mode
       'handlebars-mode)
      (showcss-mode 'toggle)
    (message "Not in an html mode")))

(use-package show-css
  :bind ("C-c C-k" . skj/toggle-showcss))
#+END_SRC

Completion

#+BEGIN_SRC emacs-lisp
(use-package ac-html-bootstrap)

(use-package ac-html-csswatcher)

(use-package company-web)

(use-package counsel-css)
#+END_SRC

Template page support.

#+BEGIN_SRC emacs-lisp
(use-package jinja2-mode)

(use-package web-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package react-snippets)
#+END_SRC

*** JavaScript

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "JavaScript")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :mode (("\\.js\\'" . js2-mode)
         ("\\.mjs\\'" . js2-mode)))

(use-package js2-highlight-vars)

(use-package js2-refactor
  :hook (js2-mode)
  :config (js2r-add-keybindings-with-prefix "C-c C-r"))

(use-package js2hl)

(use-package xref-js2)
#+END_SRC

Integration of [[https://beautifier.io/][beautifier.io]].

#+BEGIN_SRC emacs-lisp
(use-package web-beautify)
#+END_SRC

The underlying command-line tool is  installed by typing: =npm -g install js-beautify=.

*** Typescript

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Typescript")
#+END_SRC

See:

- https://github.com/ananthakumaran/tide
- https://github.com/emacs-typescript/ts-comint
- https://github.com/emacs-typescript/typescript.el

#+BEGIN_SRC emacs-lisp
(use-package typescript-mode)

(use-package tide)

(use-package ts-comint)
#+END_SRC

To run a TypeScript interpreter (REPL) in an inferior process window =M-x
run-ts=. For the external interpreter you'll need to run =npm install -g tsun=.

Use =typescript-mode= in Org blocks.

#+BEGIN_SRC emacs-lisp
(use-package ob-typescript)
#+END_SRC

*** Semantic Web

#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Semantic Web")
#+END_SRC

Lookup RDF prefixes

#+BEGIN_SRC emacs-lisp
(use-package rdf-prefix)
#+END_SRC

SPARQL mode, including =org-mode= blocks.

#+BEGIN_SRC emacs-lisp
(use-package sparql-mode
  :mode (("\\.sparql\\'" . sparql-mode)
         ("\\.rq\\'" . sparql-mode))
  :config (skj/org-babel-load-languages '(sparql)))
#+END_SRC

*** Proof Assistants
   
#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Proof Assistants")
#+END_SRC

[[https://proofgeneral.github.io/][Proof General]] is a generic Emacs interface for proof assistants (also known as
interactive theorem provers). It is supplied ready to use for the proof
assistants [[https://coq.inria.fr/][Coq]], EasyCrypt, qrhl, and PhoX. This package provides =coq-mode=
referenced in the sections following.

#+BEGIN_SRC emacs-lisp
(use-package proof-general)
#+END_SRC

Emacs commenting support tools for Coq proof assistance

#+BEGIN_SRC emacs-lisp
(use-package coq-commenter
  :hook (coq-mode)
  :bind (:map coq-commenter-mode-map
              ("C-;" . coq-commenter-comment-proof-in-region)
              ("C-x C-;" . coq-commenter-comment-proof-to-cursor)
              ("C-'" . coq-commenter-uncomment-proof-in-region)
              ("C-x C-'" . coq-commenter-uncomment-proof-in-buffer)))
#+END_SRC

This package includes a collection of =company-mode= back-ends for
=proof-general='s Coq mode, and other useful extensions to Proof-General.

#+BEGIN_SRC emacs-lisp
(use-package company-coq
  :hook (coq-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-contrib
  :after org
  :config
  (require 'ob-coq)
  (skj/org-babel-load-languages 'coq))
#+END_SRC

The =boogie-friends= package is an experimental collection of Emacs modes for
writing verified programs in z3 and languages of the Boogie family (including
Dafny).

#+BEGIN_SRC emacs-lisp
(use-package boogie-friends
  :mode
  ("\\.smt2\\'" . z3-smt2-mode)
  ("\\.dfy\\'" . dafny-mode))
#+END_SRC

** AWS Integration

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "AWS Integrations"))
#+END_SRC

[[https://github.com/sebasmonia/awscli-capf][awscli-capf]] provides support for AWS CLI completion, with quick access to the
vast documentation. When you type =aws= in your shell buffer, completion at
point would suggest valid commands. And by leveraging some company-mode
extensions, the docs are one =C-h= away!

#+BEGIN_SRC emacs-lisp
(use-package awscli-capf
  :config (add-hook 'shell-mode-hook
                    (lambda ()
                      (add-to-list 'completion-at-point-functions 'awscli-capf))))
#+END_SRC

[[https://github.com/baron42bba/aws-snippets][aws-snippets]] adds =yasnippet= snippets for AWS CLI and CloudFormation templates.

#+BEGIN_SRC emacs-lisp
(use-package aws-snippets)
#+END_SRC

[[https://github.com/cniles/axe][axe]] lets you use Emacs as a frontend for interacting with AWS resources. It
makes available a number of tasks, such as listing buckets, invoking lambdas
and tailing logs, ergonomically available through emacs.

#+BEGIN_SRC emacs-lisp
(use-package axe
  :config (setq axe-region 'us-west-2))
#+END_SRC

Editing and Flycheck modes for Cloud Formation Templates.

#+BEGIN_SRC emacs-lisp
(use-package cfn-mode)

(use-package flycheck-cfn
  :after cfn-mode
  :config (flycheck-cfn-setup))
#+END_SRC

Also consider =aws-ec2=.

** Developer Services

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Developer Services"))
#+END_SRC

*** Wakatime
   
#+BEGIN_SRC emacs-lisp :exports none
(progress l2-msg "Wakatime")
#+END_SRC

[[https://wakatime.com/emacs][Wakatime]] service customization. This service tries to keep track of what
projects and what tools you use as an engineer. Set the API key in =~/.wakatime.cfg=.

#+BEGIN_SRC emacs-lisp
(use-package wakatime-mode
  :config (setq wakatime-cli-path (locate-file "wakatime-cli" exec-path))
  (global-wakatime-mode))
#+END_SRC

** For Fun

Don't forget to =M-x asm-blox=!

#+BEGIN_SRC emacs-lisp
(use-package asm-blox)
#+END_SRC


* Work Configuration

#+BEGIN_SRC emacs-lisp :exports none
(setq l1-msg (progress "Work Configuration"))
#+END_SRC

Only basic information should exist in here, put the rest in external
resources referenced in [[*Work Packages]].

** Paths

#+BEGIN_SRC emacs-lisp :exports none
(setq l1-msg (progress "Paths"))
#+END_SRC

These are either common on development boxes or laptop environments.

#+BEGIN_SRC emacs-lisp :exports none
(dolist (path '("~/bin" "~/.toolbox/bin"))
  (exec-path-prepend path))
#+END_SRC

** Customization

#+BEGIN_SRC emacs-lisp :exports none
(setq l1-msg (progress "Customization"))
#+END_SRC

These variables parallel their non-work values.

#+BEGIN_SRC emacs-lisp
(defcustom
  skj/work-email
  "simonjo@amazon.com"
  "Primary email address for work."
  :tag "Work email address"
  :group 'skj
  :type 'string)

(defcustom
  skj/work-project-root-dir
  (expand-file-name (concat-path skj/project-root-dir "Amazon"))
  "Root directory for work development projects."
  :tag "Work projects' root directory"
  :group 'skj
  :type 'directory)
#+END_SRC

Add work packages that include LaTeX here.

#+BEGIN_SRC emacs-lisp
(setq skj/latex-shared-paths
      (add-to-list 'skj/latex-shared-paths
                   (concat-path skj/work-project-root-dir
                                "FreshDocumentationTemplates/configuration")))
#+END_SRC

Add any work BibTeX files here.

#+BEGIN_SRC emacs-lisp
(setq skj/bibtex-files
      (add-to-list 'skj/bibtex-files
                   (concat-path skj/work-project-root-dir
                                "SimonjoDocuments/tex-shared/amazon.bib")))
#+END_SRC

** Work Packages

#+BEGIN_SRC emacs-lisp :exports none
(setq l1-msg (progress "Work Packages"))
#+END_SRC

The =work= directory should be a symlink to a Git repository containing any
work-specific packages.

#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (concat-path user-emacs-directory "lib/work"))
#+END_SRC

** Org Mode

#+BEGIN_SRC emacs-lisp :exports none
(setq l1-msg (progress "Org Mode"))
#+END_SRC

Load initial work Org files, there may be more, but this is a start.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-files
      (append org-agenda-files
              (list (concat skj/org-directory "/work-todo.org")
                    (concat skj/org-directory "/work-travel.org")
                    (concat skj/org-directory "/work-people.org"))))
#+END_SRC


* Finishing Up

#+BEGIN_SRC emacs-lisp :exports none
(setq l1-msg (progress "Finishing Up"))
#+END_SRC

These things need to be last, some match actions taken at the start of the file.

First of all, turn advice redefinition warnings back on.

#+BEGIN_SRC emacs-lisp
(setq ad-redefinition-action 'warn)
#+END_SRC

** Reset the GC Threshold

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Reset the GC Threshold"))
#+END_SRC

Set garbage collection back to reasonable values now that startup is complete.

#+BEGIN_SRC emacs-lisp
(setq gc-cons-percentage 0.1
      gc-cons-threshold (* 2 1024 1024))
#+END_SRC

** Run Emacs as a Server?

#+BEGIN_SRC emacs-lisp :exports none
(setq l2-msg (progress l1-msg "Run Emacs as a Server?"))
#+END_SRC

Pretty self-explanatory, if we aren’t already running as a client, start the
server process.

#+BEGIN_SRC emacs-lisp
(require 'server) ;; builtin

(unless (and (fboundp 'server-running-p) (server-running-p))
  (progress l2-msg "Starting Emacs server")
  (server-start))
#+END_SRC
